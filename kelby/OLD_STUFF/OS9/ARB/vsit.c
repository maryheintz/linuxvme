#include <stdio.h>#include <math.h>#include <time.h>int sw1,sw2,sw3,sw4,sw5,sw6,sw7,sw8;struct{unsigned int trig;       unsigned int reset;       unsigned int status;       unsigned int sample;       unsigned int delay;       unsigned int rdall;       unsigned int rd3;       unsigned int rd2;       unsigned int rd1;}fermi;unsigned short *reg;unsigned int base=0xf0b40000;unsigned int base2=0x80b40000;double fermi_val[1200],fermi_volt[1200];double scut;int ibin[1024];int fdata[512],ncmprs;double width,center,pi,hpi,freq;main()  { /*  FILE *fp; */    unsigned long ext,b,c,n,a,f,q,off;    double fval;    int nevnt,nevmax,nstrtev,k,nn,l;    int ipeak,peak_val,ipd;    double xhist,yhist;    double vpulse,db,dbstp,volt;    int nloop,ncia=16,kkk,kkkcnt;    char string[80],err[80];    unsigned short data,cia;    double vin;    int max,imax;    int pl=180,ph=190;    pi=3.1415927;    hpi=0.5*pi;    center=256.0;    width=256.0;    dbstp=0.1;    vpulse=2.0;    nevmax=1000;    scut=5.0;    fsetup();    gpib_reset();/*  initialize the iotech controller - programable attenuators */    sendmessage(3, "D4 X" );  /* lf+eoi terminate */    sendmessage(3, "P1 X" );  /* select master and execute */    sendmessage(3, "F3 X" );  /* select hex */    dotset(0,20.0,0.0,1000.0,0.0,0,0);    sprintf(string,     "x-freq Mhz      y-fermi peak counts");    dotlbl(0,string);    dotset(1,20.0,0.0,2.0,0.0,0,0);    sprintf(string,     "x-freq Mhz      y-fermi peak volts");    dotlbl(1,string);    for(freq=1.0; freq<20.0; freq=freq+0.25)     {  width=250.0/freq;  /* Mhz */        printf("width=%f freq=%f\n",width,freq);/*    fp=fopen("band.dat","w");  *//*  set up the AWG2040 arbitrary waveform generator */    curve();/* --------------- INITIALIZE CAMAC --------------------------------*//*    printf("initialize camac\n"); */    b=0;    c=1;    n=25;    a=0;/*  set up control word ext */    cdreg(&ext,&b,&c,&n,&a);    off=0;    cccz(&ext);          /* initialize */     cccc(&ext);          /* clear */    ccci(&ext,&off);     /* remove crate inhibit *//*  send pulse to reset visual scaler */    f=16;    a=7;    n=2;    data=1;    cdreg(&ext,&b,&c,&n,&a);    cssa(&f,&ext,&data,&q);/*  read switches */    c_latch();    sw1 = sw(1);    sw2 = sw(2);    sw3 = sw(3);    sw4 = sw(4);    sw5 = sw(5);    sw6 = sw(6);    sw7 = sw(7);    sw8 = sw(8);/*    printf("switches  1-8= %d %d %d %d %d %d %d %d\n",      sw1,sw2,sw3,sw4,sw5,sw6,sw7,sw8); */    f_reset();    f_ctrig();/* ################ start - throw away one event to get going ########## */     s_trig();/*     db=6.0;    /* /* 1.0 volts */     db=10.5;    /* 0.6 volts */      db_set(vpulse,db,&volt);      if(sw3 == 1) printf("k=%d db=%f volt=%f\n",k,db,volt);   for(k=0;k<1024;k++) ibin[k]=0;   nstrtev=-1;   for(nevnt=0;nevnt<nevmax;nevnt++)    {/*   reset last event ------------------------------ */rstrt:       f_ctrig();       c_latch();       sw2 = sw(2);       sw3 = sw(3);       sw4 = sw(4);       sw5 = sw(5);       sw6 = sw(6);       sw7 = sw(7);       sw8 = sw(8);/*     send the laser trigger ------------------------------- */       s_trig();/*       tsleep(0x80000020); *//*     look for latch bit set ------------------------------- */       kkkcnt=0;loop:       kkk=r_latch();       kkkcnt++;       if(kkkcnt>1000)         {if(sw6 == 1) printf("no latch bit found\n");         goto rstrt;}       if(kkk != 1) goto loop;/*     go read the fermi module ------------------------------- */       f_read(&ipeak,&peak_val);       if(sw8 == 1) goto rstrt;/*     histogram the fermi readout ? ------------------------------- */       if(sw1 == 1 )        {hstrst();         hstset(0,250.0,0.0,250,1000);         sprintf(string,"ipeak=%d peak_val=%d",ipeak,peak_val);         hstlbl(0,string);         for(nn=0; nn<256; nn++)          {xhist = (double)nn + 0.5;           yhist = (double)fdata[nn];           hstacc(0,xhist,yhist);          }         hstwrt(0);         }         if(ipeak>pl && ipeak<ph) ibin[peak_val]++;     } /* end of nevnt loop */     max=0;     for(k=0;k<1024;k++)      { if(ibin[k]>max)           {imax=k;           max=ibin[k];          }      }     if(imax>10)        { fval=(double)imax;         cmprs(&fval,&vin);         if(fval>10.0)           { dotacc(0,freq,fval);            dotacc(1,freq,vin); }     } } /* end of freq loop */     plot_reset();      dotall();     plot_reset();      printf("second chance to hard copy plots\n");      dotall();}  /* end of main */    double hstfit(i,l,x)    int i,l;    double x;    {double y;     y=0.0;     return(y);     }       sw(i)        int i;        {int *adr,k,l,shft;         adr=(int *)0x80cf0000;         k=*adr;         shft=23+i;         l=(k>>shft)&1;         return(l);         }           r_latch()        {int *adr,k,l;         adr=(int *)0x80cf0000;         k=*adr;         l=k&1;         return(l);         }           c_latch()        {int *adr,k,l;         adr=(int *)0x80cf0008;         *adr=NULL;         return(0);         }           s_trig()        {int *adr,k,l;         adr=(int *)0x80cf0004;         *adr=NULL;         return(0);         }      f_reset(){ FPermit(base,0x100,3);  FPermit(base2,0x100,3);  fermi.trig=base+0x26;  fermi.reset=base+0x24;  fermi.status=base+0x22;  fermi.sample=base+0x20;  fermi.delay=base+0x1e;  fermi.rdall=base2+0x18;  fermi.rd3=base+0x14;  fermi.rd2=base+0x12;  fermi.rd1=base+0x10;  /* issue reset */  reg=(unsigned short *)fermi.reset;  *reg=0;  /* set to full 255 samples */  reg=(unsigned short *)fermi.sample;  *reg=255;  /* set delay */  reg=(unsigned short *)fermi.delay;  *reg=10;  /* set to start mode */  reg=(unsigned short *)fermi.status;  *reg=0;  return(0);}f_ctrig(){ reg=(unsigned short *)fermi.trig;  *reg=0;  return(0);}f_read(peak,peak_val)int *peak,*peak_val;{int stat,data_ready,busy,lcnt,i,dd,k,kmax; /* wait for a trigger */  lcnt=0;loop:  lcnt++;  reg = (unsigned short *)fermi.status;  stat = *reg;  data_ready = stat & 4;  busy = stat & 2;  if(lcnt > 1000 ) goto error;  if ( data_ready == 0 ) goto loop;  /* read the data and find peak channel */  k=0;  kmax=0;  reg=(unsigned short *) fermi.rd3;  for (i=0;i<255;i++)   {dd = *reg & 0x3ff;    fdata[i] = 0x3ff - dd;    if(fdata[i]>kmax)     {kmax=fdata[i];      k=i;}   fdata[0]=0;   }   *peak=k;   *peak_val=kmax;   return(0);error:   *peak=-1;   return(0);   }      db_set(vpulse,db,volt)      double vpulse,db,*volt;      { double dbset,afac;        unsigned long lout;        char string[80];        dbset=0.0;        lout=0;        if(db>64)          { dbset=dbset+64.0;            lout=lout+0x4000;            db=db-64.0;}        if(db>32)          { dbset=dbset+32.0;            lout=lout+0x2000;            db=db-32.0;}        if(db>16)          { dbset=dbset+16.0;            lout=lout+0x1000;            db=db-16.0;}        if(db>8)          { dbset=dbset+8.0;            lout=lout+0x800;            db=db-8.0;}        if(db>4)          { dbset=dbset+4.0;            lout=lout+0x400;            db=db-4.0;}        if(db>2)          { dbset=dbset+2.0;            lout=lout+0x200;            db=db-2.0;}        if(db>1)          { dbset=dbset+1.0;            lout=lout+0x100;            db=db-1.0;}        if(db>0.8)          { dbset=dbset+0.8;            lout=lout+0x8;            db=db-0.8;}        if(db>0.4)          { dbset=dbset+0.4;            lout=lout+0x4;            db=db-0.4;}        if(db>0.2)          { dbset=dbset+0.2;            lout=lout+0x2;            db=db-0.2;}        if(db>0.1)          { dbset=dbset+0.1;            lout=lout+0x1;            db=db-0.1;}        afac=-dbset/20.0;        *volt=vpulse*pow(10.0,afac);        sprintf(string,"C%x X",lout);        sendmessage(3, string );        tsleep(0x80000025);         return(0);        }unsigned char string[8000],back[8000];curve()  { int i,ii,iy,ipnt,i1,i2;    double x,y,dx,aa,bb,t;    unsigned char gpib_device=13;    sprintf(string,":DEBUG:SNOOP:STATE OFF \0");     sendmessage(gpib_device, string );    sprintf(string,"DATA:DESTINATION 'ABC.WFM' \0");     sendmessage(gpib_device, string );     sprintf(string,"DATA:WIDTH2:ENCDG SRPBINARY\0");    sendmessage(gpib_device, string );     sprintf(string,"WFMPRE:YZERO 0.0 \0");    sendmessage(gpib_device, string );     sprintf(string,"WFMPRE:YMULT 1.0e-03 \0");    sendmessage(gpib_device, string );     sprintf(string,"WFMPRE:XINCR 9.7646e-10 \0");    sendmessage(gpib_device, string );     sprintf(string,":CURVE #42048");    ipnt=13;    aa=hpi/width;    bb=(-hpi*center)/width;    for(i=0;i<1024;i++)     {t=hpi+(double)i*aa+bb;      y=0.0;      if(t>0 && t<pi) y=4095.0*sin(t);      iy=4095-(int)y;/*      printf("i=%d y=%f iy=%d\n",i,y,iy); */      i1=iy&0xff;      i2=(iy>>8)&0xff;      string[ipnt++]=(unsigned char)i2;      string[ipnt++]=(unsigned char)i1;     }    sendsize(gpib_device, string,ipnt );    sprintf(string,"CH1:WAVEFORM 'ABC.WFM' \0");     sendmessage(gpib_device, string );     sprintf(string,"CH1:OFFSET 1.0V \0");     sendmessage(gpib_device, string );     sprintf(string,"CH1:AMPL 2.0V \0");     sendmessage(gpib_device, string );     sprintf(string,":MODE TRIGGERED \0");     sendmessage(gpib_device, string );     sprintf(string,":CH1:MARKERLEVEL1:LOW -0.5V \0");     sendmessage(gpib_device, string );     sprintf(string,":CH1:MARKERLEVEL1:HIGH 0.0V \0");     sendmessage(gpib_device, string );     sprintf(string,":DATA:DESTINATION 'ABC.WFM' \0");     sendmessage(gpib_device, string );     sprintf(string,":MARKER:DATA #41024");    ipnt=19;    for(i=0;i<1024;i++)     {      if(i<256) string[ipnt]=(unsigned char)0;      if(i>255) string[ipnt]=(unsigned char)3;      if(i<2) string[ipnt]=(unsigned char)3;      ipnt++;     }    sendsize(gpib_device, string,ipnt );    sprintf(string,"OUTPUT:CH1:NORMAL:STATE 1 \0");     sendmessage(gpib_device, string );      sprintf(string,"OUTPUT:CH1:INVERTED:STATE 1 \0");     sendmessage(gpib_device, string );      sprintf(string,":CLOCK:SOURCE INTERNAL;FREQUENCY 1.0GHZ \0");     sendmessage(gpib_device, string );        return(0);     }    fsetup()    { FILE *fpm;      int k;      double r1,r2;      fpm=fopen("single_ended.dat","r");      k=0;loop:      fscanf(fpm,"%lf %lf",&r1,&r2);      if(r2>0.000080)        {fermi_val[k] = r1;        fermi_volt[k] = r2;/*        printf("k=%d  val=%f  volts=%f\n",k,r1,r2); */        k++;        goto loop;}      ncmprs=k-1;/*      printf("ncmprs=%d\n",ncmprs); */      return(0);    }    cmprs( fpeak,x )    double *fpeak,*x;    { int i,k,k1,k2;      double a1,a2,a3;      k=0;      for (i=0;i<ncmprs;i++) {k=i; if( fermi_val[i] < *fpeak ) goto out;}      k=ncmprs-1;out:      k2=k;      if(k2>ncmprs) k2=ncmprs;      if(k2<1) k2=1;      k1=k2-1;      a1=fermi_val[k2] - fermi_val[k1];      a2=fermi_volt[k2] - fermi_volt[k1];      a3 = fermi_val[k2] - *fpeak;      *x = fermi_volt[k2] - (a2*a3)/a1;      if(a1 == 0.0) printf("fpeak=%f k1=%d k2=%d a1=%f a2=%f a3=%f x=%f\n",        *fpeak,k1,k2,a1,a2,a3,*x);      return(0);      }