#include <stdio.h>#include <math.h>int fdata[3][256],ipk[3],pk[3];struct{unsigned int trig;       unsigned int reset;       unsigned int status;       unsigned int sample;       unsigned int delay;       unsigned int rdall;       unsigned int rd2;       unsigned int rd1;       unsigned int rd0;}fermi;unsigned short *reg;unsigned short *reg0,*reg1,*reg2;unsigned int fbase=0xf0b40000;unsigned int fbase2=0x80b40000;double crg[6500],fvl[6500];int id,ttcadr;int i3time,ent;char xstring[80],ystring[80],string[80];main(argc,argv,envs)int argc;char *argv[];char *envs[];{    int tube,mode,i,phase,dac,card,k;   double asum,axsum,axxsum,ped,dped,sig2,aval;   char string[80];   double fdac,charge,capacitor;   int kk,board,tim,kpk,ntry,ngood,nbad,ibt,ngd[48];   double dacval,sum,xsum,ysum;   double f1,f2,f3,b1,b2,b3,fdg,position,position2;   int ipass;   unsigned short kja1,kja2,kja3;   kk=0;   ent=0;   id=0;   ngood=0;   nbad=0;   ntry=0;   ttcadr=0x3807;   ttcvi_map(ttcadr);   fermi_setup();   multi_low(ttcadr);   set_mb_time(ttcadr,1,0);   set_mb_time(ttcadr,2,0);   set_mb_time(ttcadr,3,0);   set_mb_time(ttcadr,4,0);   for(k=1;k<49;k++)       { if(cardchk(k) != 1)            { printf(" card %d not found\n",k);           }         set_tube(ttcadr,k);         rxw_low(ttcadr);         intg_rd_low(ttcadr);         itr_low(ttcadr);         set_intg_gain(ttcadr,0);  /* s1=s2=s3=s4=0 */         trig_enable(ttcadr);         mse_high(ttcadr);         /* mse=1 */       }   multi_high(ttcadr);   capacitor = 100.0;   large_cap_enable(ttcadr);   small_cap_disable(ttcadr);   charge=800.0;   fdac = (1023.0*charge) / (2.0 * 4.096 * capacitor);   dac = (int)fdac;   charge = 2.0 * 4.096 * capacitor * (double)dac / 1023.0;   set_dac(ttcadr,dac);     tsleep(0x80000010);   tp_low(ttcadr);   phase=116;   SetTimeDes2(ttcadr,phase);     for (k=1;k<49;k++) ngd[k-1]=0;   for(i=0;i<10;i++)     { lup:       compar_reset();       inject();       compar_read15_0(&kja1);       for(ibt=0;ibt<16;ibt++)          { if( ((kja1>>ibt) & 1) != 0) ngd[ibt]++; }        compar_read31_16(&kja2);       for(ibt=0;ibt<16;ibt++)          { if( ((kja2>>ibt) & 1) != 0) ngd[ibt+16]++; }       compar_read47_32(&kja3);       for(ibt=0;ibt<16;ibt++)          { if( ((kja3>>ibt) & 1) != 0) ngd[ibt+32]++; }       tsleep(0x80000050);     if(sw(3) == 1)        { printf(" kja1=%x  kja2=%x   kja3=%x\n",kja1,kja2,kja3);         goto lup;       }     }   for(i=0;i<48;i++)     { /* if(ngd[i] != 10) printf(" card %d failed ngd=%d\n",i+1,ngd[i]); */       printf(" card %d ngd=%d\n",i+1,ngd[i]);     }/* -------- now do linearity of card from each section -------- */    multi_low(ttcadr);exit(0); for(ipass=0;ipass<4;ipass++)  { card = 12;    kk=0;    fbase=0xf0b40000;    fbase2=0x80b40000;    if(ipass==1)         { card=24;          kk=1;        }    if(ipass==2)         { card=36;          kk=2;        }    if(ipass==3)         { card=48;          kk=0;          fbase=0xf0b41000;          fbase2=0x80b41000;        }    fermi_setup();    set_tube(ttcadr,card);    trig_enable(ttcadr);    if(card<13) board = 4;    if(card>12 && card<25) board = 3;    if(card>24 && card<37) board = 2;    if(card>36) board = 1;    printf(" board=%d\n",board);    SetTimeDes2(ttcadr,172);    large_cap_enable(ttcadr);    small_cap_disable(ttcadr);    dotzro();    dotset(0,250.0,0.0,35.0,25.0,0,0);    sprintf(xstring,"time setting");    sprintf(ystring,"position");    dotlbl(0,xstring,ystring);    dotset(1,250.0,0.0,35.0,25.0,0,0);    sprintf(xstring,"time setting");    sprintf(ystring,"position2");    dotlbl(1,xstring,ystring);    for(tim=0;tim<256;tim++)      { set_mb_time(ttcadr,board,tim);        set_tube(ttcadr,card);        set_dac(ttcadr,1023);        sum=0.0;        ysum=0.0;        xsum=0.0;        for(k=0;k<10;k++)         {retry:          ntry++;          inject();          fermi_read();/*     display ? */           if(sw(1) == 1)             { asum = 0.0;              axsum = 0.0;              axxsum = 0.0;              for(i=10;i<20;i++)               { aval = (double)fdata[kk][i];                 asum = asum+1.0;                 axsum = axsum + aval;                 axxsum = axxsum + aval*aval;               }              ped = axsum / asum;              dped = 0.0;              sig2=axxsum/asum - ped*ped;              if(sig2>0.0) dped=sqrt(sig2);              sprintf(string,                "ipk=%d  pk=%d  ped=%f +/- %f",                ipk[0],pk[0],ped,dped);              evdisp(32,string,kk);             }          kpk=ipk[kk];          if(fdata[kk][kpk] < 1000)            { /*  printf("error kk=%d kpk=%d  fdata=%d\n",             kk,kpk,fdata[kk][kpk]);  */             nbad++;             goto retry;           }          ngood++;          f1 = (double)fdata[kk][ipk[kk]-1];          b1 = (double)(ipk[kk]-1);          f2 = (double)fdata[kk][ipk[kk]];          b2 = (double)(ipk[kk]);          f3 = (double)fdata[kk][ipk[kk]+1];          b3 = (double)(ipk[kk]+1);          position = (f1*b1 + f2*b2 + f3*b3) / (f1 + f2 + f3);          position2 = (fdg*f1*b1 + f2*b2 + fdg*f3*b3) / (fdg*f1 + f2 + fdg*f3);          sum=sum+1.0;          ysum=ysum+position;          xsum=xsum+position2;         }         position = ysum/sum;       position2 = xsum/sum;       dotacc(0,(double)tim,position);       dotacc(1,(double)tim,position2);       printf("time=%d   pos=%f  pos2=%f\n",tim,position,position2);              }        printf(" card %d  board %d try=%d  good=%d  bad=%d\n",      card,board,ntry,ngood,nbad);     sidev(1);     dotwrt(0);     dotwrt(1);    }  /* end of ipass loop */   }  /* end of main */     inject()       {          fermi_reset();         if(ent==0)         {/* now start pulses - take 1 */            /* setup inhibit1 to set tp high */	     SetBMode(1,0xa);  /* internal inhibit-bgo connection */	     SetInhibitDelay(1,10);	     SetInhibitDuration(1,10);	     BPutLong(1,ttcadr,1,0xc0,0x00);  /* load set tp_high into fifo1 */	     /* set inhibit2 to drop tp low (timed broadcast mode */	     SetBMode(2,0xa);	     SetInhibitDelay(2,2000);	     SetInhibitDuration(2,10);	    /* BPutLong(2,0,1,0x80,0x01);  */ /* load set tp_low into fifo2 */	     BPutShort(2,0xc0);   /* set tp low bcast command  */	     /* set inhibit3 to set latch                     */	     /* use latch-bar and inhibit3 to start fermi     */             /* will use inhibit 3 to set l1a with digitizers */             tsleep(0x80000050);             i3time=2280;/*	     printf("input i3time\n");             fscanf(stdin,"%d",&i3time);     */	     SetInhibitDelay(3,i3time);	     SetInhibitDuration(3,10);	     SetInhibitDelay(0,1);	     SetInhibitDuration(3,10);           }         if(ent != 0)               { SetInhibitDuration(1,10);             SetInhibitDuration(2,10);	     SetInhibitDuration(3,10);           }      /* wait for an event */         tsleep(0x80000010);      /* stop pulsing and reset fermi */         SetInhibitDuration(1,0);         SetInhibitDuration(2,0);	 SetInhibitDuration(3,0);           ent = 1;  }cardchk(k)int k;  {int i,status;   unsigned short shrt;   int trig,s1,s2,s3,s4,itr,ire,mse,tplo,tphi,ok;   ok=0;   status=0;   multi_low(ttcadr);   back_low(ttcadr);   set_tube(ttcadr,k);   set_intg_gain(ttcadr,5);   /* s1=s3=1 s2=s4=0 */   itr_high(ttcadr);           /* itr=1 */   intg_rd_low(ttcadr);        /* ire=0 */   mse_high(ttcadr);           /* mse=1 */   small_cap_disable(ttcadr);  /* tplo=0 */   large_cap_enable(ttcadr);   /* tphi=1 */   trig_disable(ttcadr);       /* trig=0 */   back_high(ttcadr);   back_low(ttcadr);   load_can(ttcadr);   /* fetch from 3in1 */   tsleep(0x80000001);   status=can_3in1get(id,&shrt);    /* and load can output reg */   i = (int)shrt;   trig = i & 1;   s1 = (i>>1) & 1;   s2 = (i>>2) & 1;   s3 = (i>>3) & 1;   s4 = (i>>4) & 1;   itr = (i>>5) & 1;   ire = (i>>6) & 1;   mse = (i>>7) & 1;   tplo = (i>>8) & 1;   tphi = (i>>9) & 1;   if((s1==1) && (s2==0)  && (s3==1) && (s4==0) && (itr==1) &&      (ire==0) && (mse==1) && (tplo==0) && (tphi==1) &&       (trig==0) ) ok++;   if(sw(2)==1) printf("k=%d s1..4=%d %d %d %d itr=%d ire=%d mse=%d tplo=%d tphi=%d trig=%d %x %d\n"           ,k,s1,s2,s3,s4,itr,ire,mse,tplo,tphi,trig,i,ok);   set_intg_gain(ttcadr,0xa);   /* s1=s3=0 s2=s4=1 */   itr_low(ttcadr);           /* itr=0 */   intg_rd_high(ttcadr);        /* ire=1 */   mse_low(ttcadr);           /* mse=0 */   small_cap_enable(ttcadr);  /* tplo=1 */   large_cap_disable(ttcadr);   /* tphi=0 */   trig_enable(ttcadr);       /* trig=1 */   back_high(ttcadr);   back_low(ttcadr);   load_can(ttcadr);   /* fetch from 3in1 */   tsleep(0x80000001);   status=can_3in1get(id,&shrt);    /* and load can output reg */   i = (int)shrt;   trig = i & 1;   s1 = (i>>1) & 1;   s2 = (i>>2) & 1;   s3 = (i>>3) & 1;   s4 = (i>>4) & 1;   itr = (i>>5) & 1;   ire = (i>>6) & 1;   mse = (i>>7) & 1;   tplo = (i>>8) & 1;   tphi = (i>>9) & 1;   if((s1==0) && (s2==1)  && (s3==0) && (s4==1) && (itr==0) &&      (ire==1) && (mse==0) && (tplo==1) && (tphi==0) &&       (trig==1) ) ok++;   if(sw(2)==1) printf("k=%d s1..4=%d %d %d %d itr=%d ire=%d mse=%d tplo=%d tphi=%d trig=%d %x %d\n"           ,k,s1,s2,s3,s4,itr,ire,mse,tplo,tphi,trig,i,ok);  if(ok == 2) status=1;   return(status);  }fermi_setup()  {printf("fermi_setup entered\n");   fermi.trig=fbase+0x26;   fermi.reset=fbase+0x24;   fermi.status=fbase+0x22;   fermi.sample=fbase+0x20;   fermi.delay=fbase+0x1e;   fermi.rdall=fbase2+0x18;   fermi.rd2=fbase+0x14;   fermi.rd1=fbase+0x12;   fermi.rd0=fbase+0x10;   printf("fermi_setup reset \n");/* issue reset */   reg=(unsigned short *)fermi.reset;   *reg=0;   printf("fermi_setup samples \n");/* set to full 255 samples */   reg=(unsigned short *)fermi.sample;   *reg=255;   printf("fermi_setup delay \n");/* set delay */   reg=(unsigned short *)fermi.delay;   *reg=1;   printf("fermi_setup reg0-1-2 \n");   reg0=(unsigned short *) fermi.rd0;   reg1=(unsigned short *) fermi.rd1;   reg2=(unsigned short *) fermi.rd2;   printf("fermi_setup return \n"); }fermi_reset() { /* issue reset */   reg=(unsigned short *)fermi.reset;   *reg=0; }fermi_read() { int stat,data_ready,busy,lcnt,i,k0,k1,k2,kmax0,kmax1,kmax2;   int dd0,dd1,dd2;   unsigned short sd0,sd1,sd2;   /* wait for a trigger */   lcnt=0;loop:   lcnt++;   reg = (unsigned short *)fermi.status;   stat = *reg;   data_ready = stat & 4;   busy = stat & 2;   if(lcnt > 1000 ) goto error;   if ( data_ready == 0 ) goto loop;   /* read the data and find peak channel */   k0=0;   kmax0=0;   k1=0;   kmax1=0;   k2=0;   kmax2=0;   for (i=0;i<255;i++)    { sd0 = *reg0;      dd0 = (int)sd0 & 0xfff;      fdata[0][i] = 0xfff - dd0;  /*      fdata[0][i] = dd0; */      if(fdata[0][i]>kmax0)       { kmax0=fdata[0][i];         k0=i;}      sd1 = *reg1;      dd1 = (int)sd1 & 0xfff;      fdata[1][i] = 0xfff - dd1;  /*      fdata[1][i] = dd1;  */      if(fdata[1][i]>kmax1)       { kmax1=fdata[1][i];         k1=i;}      sd2 = *reg2;      dd2 = (int)sd2 & 0xfff;      fdata[2][i] = 0xfff - dd2;  /*      fdata[2][i] = dd2;  */      if(fdata[2][i]>kmax2)       { kmax2=fdata[2][i];         k2=i;}      if(sw(4) == 1) printf("i=%d  dd0=%d  dd1=%d  dd2=%d\n",i,dd0,dd1,dd2);       }   ipk[0]=k0;   pk[0]=kmax0;   ipk[1]=k1;   pk[1]=kmax1;   ipk[2]=k2;   pk[2]=kmax2;   return(0);error:   ipk[0]=-1;   ipk[1]=-1;   ipk[2]=-1;}evdisp(nn,string,l) int nn,l; char *string; { int max,mmax,idx,idy,ny,linx,ixbas,iybas,ix,iy,iylst,kx,ky,i,k,ii;   int idel;   double dely,y,dy;   char str[5];   erasm();   max = pk[l];   mmax=5000;   if(max<4000) mmax=4000;   if(max<3000) mmax=3000;   if(max<2000) mmax=2000;   if(max<1000) mmax=1000;   if(max<800) mmax=800;   if(max<600) mmax=600;   if(max<500) mmax=500;   if(max<400) mmax=400;   if(max<200) mmax=200;   if(max<100) mmax=100;   if(max<50) mmax=50;   idx = 1600/nn;   linx = idx*nn;   ixbas = 100+(2200-linx)/2;   dy = 2400.0/(double)mmax;   iybas = 400;   mova(ixbas,iybas);   drwr(linx,0);   mova(ixbas,iybas);   iylst = 0;   for(i=0;i<nn;i++)    { ii = fdata[l][i];      y = (double)ii;      y = y*dy;      iy = (int)y;      idy = iy-iylst;      drwr(0,idy);      drwr(idx,0);      iylst=iy;    }      drwr(0,-iylst);/*  label horizontal axis */    idel=10;    if(nn>100) idel=25;    if(nn>200) idel=50;    for(i=0;i<nn+1;i=i+idel)     { ix=ixbas+idx*i;       mova(ix,iybas);       drwr(0,-30);       k=i/2;       if(k*2 == i)         { sprintf(str,"%3d",i);           kx = ix-45;           if(i<100) kx = ix-55;           if(i<10) kx=ix-75;           symb(kx,iybas-100,0.0,str);         }     }/*  label vertical axis  */    ny=mmax/100;    if(ny>10) ny=10;    if(mmax == 200) ny=4;    if(mmax == 100) ny=4;    if(mmax == 50) ny=5;    y=(double)mmax*dy;    iy = (int)y;    mova(ixbas,iybas);    drwr(0,iy);    for(i=0;i<=ny;i++)     { ky = i*mmax/ny;       y = (double)ky * dy;       iy = (int)y + iybas;       mova(ixbas,iy);       drwr(-20,0);       sprintf(str,"%4d",ky);       kx = ixbas-150;       symb(kx,iy-20,0.0,str);     }    /*  print label */    symb(200,3000,0.0,string);    plotmx(); }compar_reset() { reg=(unsigned short *)0xf0dd0016;   *reg=0; }compar_read15_0(k)unsigned short *k; { unsigned short kk;   reg=(unsigned short *)0xf0dd0014;   kk = *reg;   *k = kk;/*   printf("kk15_0 = %x\n",kk);  */ }compar_read31_16(k)unsigned short *k; { unsigned short kk;   reg=(unsigned short *)0xf0dd0012;   kk = *reg;   *k = kk;/*   printf("kk31_16 = %x\n",kk);  */ }compar_read47_32(k)unsigned short *k; { unsigned short kk;   reg=(unsigned short *)0xf0dd0010;   kk = *reg;   *k = kk;/*   printf("kk47_32 = %x\n",kk);  */ }