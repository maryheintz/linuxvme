#include <stdio.h>#include <math.h>int sw1,sw2,sw3,sw4,sw5,sw6,sw7,sw8;unsigned int base;int fdata[40],pk,ipk;unsigned short *reg0,*reg2,*reg4,*reg6,*reg8,*rega;double crg[6500],fvl[6500];unsigned int delay;int year,month,day,hour,min,sec;int lyear,lmonth,lday,lhour,lmin,lsec;int l0year,l0month,l0day,l0hour,l0min,l0sec;struct {char year;        char month;        char day;        char hour;        char minute;        char second} tims;static struct {int nev;               int month;               int day;               int hour;               int min;               double cap;               double charge;               double mc[256];               double mp[256];               double rad;} phases;static struct {int nev;               int month;               int day;               int hour;               int min;               double cap;               double cg[100];               double amp[100];               double damp[100];               double ped;               double dped;               double rad;} dacs;static struct {int month;               int day;               int hour;               int min;               int nev[6];               double ped[6];               int dc[6][20];               double volts[6][20];               double v00[6];               double v10[6];               double v01[6];               double rad;} intgs;unsigned char gpib_adr = 3;int cardno,ent;int active[49];double source,rad;    char xstring[80],ystring[80],string[80],err[80];FILE *fp_time,*fp_phase,*fp_dac,*fp_int;main(argc,argv,envs)int argc;char *argv[];char *envs[];  { int dmin,tmin,ierr,wait,timestep=3;    double tday;    dmin=0;    printf("input - card number\n");    fscanf(stdin,"%d",&cardno);    sprintf(string,"/z5/phase%d.dat",cardno);    fp_phase = fopen(string,"w");    sprintf(string,"/z5/dac%d.dat",cardno);    fp_dac = fopen(string,"w");    sprintf(string,"/z5/int%d.dat",cardno);    fp_int = fopen(string,"w");    fp_time = fopen("/z5/time.dat","w");    newtime();    l0year = 98;    l0month = 12;    l0day = 1;    l0hour = 12;    l0min = 0;    l0sec = 0;    tmin = ttinterval();    tday = (double)tmin / (24.0 * 60.0);    source = 18.86 * exp((-0.693 * tday) / 1925.1);    printf(" source = %f  tday = %f  tmin=%d\n",source,tday,tmin);    ent = 0;    rad = 0.0;    doit(0);    ent = 1;    printf(" raise source and enter 1\n");    fscanf(stdin,"%d",&wait);    printf(" wait return - now taking data\n");    newtime();    lyear = year;    lmonth = month;    lday = day;    lhour = hour;    lmin = min;    lsec = sec;    l0year = year;    l0month = month;    l0day = day;    l0hour = hour;    l0min = min;    l0sec = sec;next:    newtime();    dmin = tinterval();    if(dmin < timestep)       { sleep(10);        goto next;      }    lyear = year;    lmonth = month;    lday = day;    lhour = hour;    lmin = min;    lsec = sec;    doit(1);        sw8 = sw(8);    if(sw8 == 0) goto next;    ierr = fclose(fp_phase);    ierr = fclose(fp_dac);    ierr = fclose(fp_int);  }  /* end of main */doit(ipass)int ipass;     { double asum,axsum,axxsum,ped,dped,sig2,aval,yc;    double meanhp,meanhc,meanlp,meanlc;    double sum,xhsump,xxhsump,xhsumc,xxhsumc,xlsump,xxlsump,xlsumc,xxlsumc;    double sighp,sighc,pmaxh,cmaxh,tmaxh;    double siglp,siglc,pmaxl,cmaxl,tmaxl;    int nevnt,nevmax,nstrtev,l,nn,i,k,wait,nevent;    int isw[6],nwds,ierr;    int gain,dc,dacmax,max[6],del[6],imax;    int ipeak,timc,timf;    int zone,sector,card;    int dac,dmin,tmin;    double fdac,charge,val,ratio;    int bigain,kpeak,klo,khi,icnt,dstep;    double s,sx,sy,sxy,sev,sxev,sxxev,sxest,el,er,ep,estimator;    double sig,sx2,volt,capacitor,a,b,ddel,x,y,dely;    double pedhi,dpedhi,pedlo,dpedlo;    unsigned short cadr,tc,tf;    int kpeakh,timfh,kpeakl,timfl;    double ah,bh,al,bl;    unsigned short sval,dval;    double volt_connected,volt_no_itr,volt_no_intg;    int ntotal=0;    newtime();    tmin = ttinterval();    if(ipass != 0) rad = source * tmin / 60.0;    zone = 1;    sector = 1;    card = 41;    i = (zone<<12) | (sector<<6) | card;    cadr = (unsigned short)i;    tc = (unsigned short)20;    card_sel(cadr);    send13_3in1(2,0);   /* s1=s2=s3=s4=0 */    send4_3in1(1,0);   /* itr=0 */    send4_3in1(0,0);   /* ire=0 */    send4_3in1(3,0);   /* mse=0 */    tim1_set(tc);   /* coarse */    tf = 0;    tim2_set(tf);   /* fine */    nevmax=25;    pmaxh=0.0;    cmaxh=0.0;    tmaxh=0.0;    pmaxl=0.0;    cmaxl=0.0;    tmaxl=0.0;    timc=15;    timf=0;    tc = (unsigned short)timc;    tim1_set(tc);    tf = (unsigned short)timf;    tim2_set(tf);/* --------------------- determine higain timing -------------------*/    base = 0xf0ff0000;    delay = 0x80000005;    flex_setup();    capacitor = 5.2;    phases.cap = capacitor;    send4_3in1(4,1);   /* enable small C */    send4_3in1(5,0);   /* disable large C */    charge=11.0;    fdac = (1023.0*charge) / (8.0*capacitor);    dac = (int)fdac;    charge = 8.0 * capacitor * (double)dac / 1023.0;    phases.charge = charge;    if(sw(5) == 1) printf("higain charge=%f dac=%d capacitor=%f\n",         charge,dac,capacitor);    send13_3in1(6,dac);    rtime();    inject();   nevent=0;   for (timf=0; timf<256; timf++)  /* start l loop */   { tf = (unsigned short)timf;     tim2_set(tf);     sum=0.0;     xhsump=0.0;     xxhsump=0.0;     xhsumc=0.0;     xxhsumc=0.0;     for(nevnt=0;nevnt<nevmax;nevnt++)      {        flex_reset();        rtime();        tsleep(0x80000002);        inject();/*     go read the fermi module ------------------------------- */        flex_read();/*     display ? */         sw1 = sw(1);         if(sw1 == 1)           { asum = 0.0;            axsum = 0.0;            axxsum = 0.0;            for(i=10;i<20;i++)             { aval = (double)fdata[i];               asum = asum+1.0;               axsum = axsum + aval;               axxsum = axxsum + aval*aval;              }            ped = axsum / asum;            dped = 0.0;            sig2=axxsum/asum - ped*ped;            if(sig2>0.0) dped=sqrt(sig2);            sprintf(string,              "hi gain ipk=%d  pk=%d  ped=%f +/- %f",              ipk,pk,ped,dped);            evdisp(32,string,2);}/* now gets sums for mean calculation */       sum=sum+1.0;       yc=(double)fdata[ipk];       xhsumc=xhsumc+yc;       xxhsumc=xxhsumc+yc*yc;       yc=(double)ipk;       xhsump=xhsump+yc;       xxhsump=xxhsump+yc*yc;     } /* end of nevnt loop *//*  now get mean  */   meanhp=xhsump/sum;   sighp=0.0;   sig2=xxhsump/sum-meanhp*meanhp;   if(sig2>0.0) sighp=sqrt(sig2);   meanhc=xhsumc/sum;   sighc=0.0;   sig2=xxhsumc/sum-meanhc*meanhc;   if(sig2>0.0) sighc=sqrt(sig2);   sw3 = sw(3);   if(sw3 == 1)     { printf("\n timer=%d sum=%f\n",timf,sum);        printf("       meanhp=%f sighp=%f\n",meanhp,sighp);       printf("       meanhc=%f sighc=%f\n",meanhc,sighc);     }   if(sw(5) == 1) printf("high gain timer=%d channel=%6.1f peak=%5.1f\n",    timf,meanhp,meanhc);   if(meanhc>pmaxh && timf<125)    { pmaxh=meanhc;      cmaxh=meanhp;      tmaxh=timf; }   phases.mc[timf] = meanhc;   phases.mp[timf] = meanhp;   nevent++;   }  /* end of dac loop */   newtime();   tmin = ttinterval();    if(ipass != 0) rad = source * tmin / 60.0;   phases.rad = rad;   phases.nev = nevent-1;   phases.month = month;   phases.day = day;   phases.hour = hour;   phases.min = min;   nwds = fwrite(&phases.nev,4,1037,fp_phase);   ierr = ferror(fp_phase);   if(ierr != 0) printf(" error writing to fp_phase %x\n",ierr);/* --------------------- determine logain timing -------------------*/    base = 0xf0ee0000;    delay = 0x80000006;    flex_setup();    capacitor = 100.0;    phases.cap = capacitor;    send4_3in1(4,0);   /* disable small C */    send4_3in1(5,1);   /* dnable large C */    charge=700.0;    fdac = (1023.0*charge) / (8.0*capacitor);    dac = (int)fdac;    charge = 8.0 * capacitor * (double)dac / 1023.0;    phases.charge = charge;    if(sw(5) == 1) printf("higain charge=%f dac=%d capacitor=%f\n",         charge,dac,capacitor);    send13_3in1(6,dac);    rtime();    inject();   i=0;   nevent=0;   for (timf=0; timf<256; timf++)  /* start l loop */   { tf = (unsigned short)timf;     tim2_set(tf);     sum=0.0;     xlsump=0.0;     xxlsump=0.0;     xlsumc=0.0;     xxlsumc=0.0;     for(nevnt=0;nevnt<nevmax;nevnt++)      {        flex_reset();        rtime();        tsleep(0x80000002);        inject();/*     go read the fermi module ------------------------------- */        flex_read();/*     display ? */         sw1 = sw(1);         if(sw1 == 1)           { asum = 0.0;            axsum = 0.0;            axxsum = 0.0;            for(i=10;i<20;i++)             { aval = (double)fdata[i];               asum = asum+1.0;               axsum = axsum + aval;               axxsum = axxsum + aval*aval;              }            ped = axsum / asum;            dped = 0.0;            sig2=axxsum/asum - ped*ped;            if(sig2>0.0) dped=sqrt(sig2);            sprintf(string,              "lo gain ipk=%d  pk=%d  ped=%f +/- %f",              ipk,pk,ped,dped);            evdisp(32,string,2);}/* now gets sums for mean calculation */       sum=sum+1.0;       yc=(double)fdata[ipk];       xlsumc=xlsumc+yc;       xxlsumc=xxlsumc+yc*yc;       yc=(double)ipk;       xlsump=xlsump+yc;       xxlsump=xxlsump+yc*yc;     } /* end of nevnt loop *//*  now get mean  */   meanlp=xlsump/sum;   siglp=0.0;   sig2=xxlsump/sum-meanlp*meanlp;   if(sig2>0.0) siglp=sqrt(sig2);   meanlc=xlsumc/sum;   siglc=0.0;   sig2=xxlsumc/sum-meanlc*meanlc;   if(sig2>0.0) siglc=sqrt(sig2);   sw3 = sw(3);   if(sw3 == 1)     { printf("\n timer=%d sum=%f\n",timf,sum);        printf("       meanlp=%f siglp=%f\n",meanlp,siglp);       printf("       meanlc=%f siglc=%f\n",meanlc,siglc);     }   if(sw(5) == 1) printf(" low gain timer=%d channel=%6.1f peak=%5.1f\n",    timf,meanlp,meanlc);   if(meanlc>pmaxl && timf<125)    { pmaxl=meanlc;      cmaxl=meanlp;      tmaxl=timf; }   phases.mc[timf] = meanlc;   phases.mp[timf] = meanlp;   nevent++;   }  /* end of dac loop */   phases.nev = nevent-1;   newtime();    tmin = ttinterval();    if(ipass != 0) rad = source * tmin / 60.0;   phases.rad = rad;   phases.month = month;   phases.day = day;   phases.hour = hour;   phases.min = min;   nwds = fwrite(&phases.nev,4,1037,fp_phase);   ierr = ferror(fp_phase);   if(ierr != 0) printf(" error writing to fp_phase %x\n",ierr);   if(sw(5) == 1) printf("pmaxh=%f cmaxh=%f tmaxh=%f\n",pmaxh,cmaxh,tmaxh);   if(sw(5) == 1) printf("pmaxl=%f cmaxl=%f tmaxl=%f\n",pmaxl,cmaxl,tmaxl);/* ---------------- high gain calibration ----------------------*/    base = 0xf0ff0000;    delay = 0x80000005;    flex_setup();    capacitor = 5.2;    dacs.cap = capacitor;    send4_3in1(4,1);   /* enable small C */    send4_3in1(5,0);   /* disable large C */   kpeak=(int)(cmaxh+0.5);   klo=kpeak-2;   khi=kpeak+2;   timf=(int)(tmaxh+0.5);   if(sw(5) == 1) printf("starting higain  kpeak=%d timf=%d\n",kpeak,timf);   kpeakh = kpeak;   timfh = timf;   tf = (unsigned short)timf;   tim2_set(tf);   icnt=0;   s=0.0;   sx=0.0;   sy=0.0;   sxy=0.0;   sx2=0.0;   dstep = 4;   nevent = 0;      for (dac=0; dac<400; dac=dac+dstep)     { send13_3in1(6,dac);      volt = 8.0 * (double)dac/1023.0;      charge = volt * capacitor;      if(charge<0.0) continue;      sev = 0.0;      sxev = 0.0;      sxxev = 0.0;      sxest = 0.0;      for(nevnt=0;nevnt<nevmax;nevnt++)       {        flex_reset();        rtime();        tsleep(0x80000002);        inject();/*     go read the fermi module ------------------------------- */        flex_read();/*     display ? */         sw1 = sw(1);         if(sw1 == 1)           { asum = 0.0;            axsum = 0.0;            axxsum = 0.0;            for(i=10;i<20;i++)             { aval = (double)fdata[i];               asum = asum+1.0;               axsum = axsum + aval;               axxsum = axxsum + aval*aval;              }            ped = axsum / asum;            dped = 0.0;            sig2=axxsum/asum - ped*ped;            if(sig2>0.0) dped=sqrt(sig2);            sprintf(string,              "lo gain ipk=%d  pk=%d  ped=%f +/- %f",              ipk,pk,ped,dped);            evdisp(32,string,2);}        asum = 0.0;        axsum = 0.0;        axxsum = 0.0;        for(i=10;i<20;i++)         { aval = (double)fdata[i];           asum = asum+1.0;           axsum = axsum + aval;           axxsum = axxsum + aval*aval;          }        ped = axsum / asum;        sig2=axxsum/asum - ped*ped;        if(sig2>0.0) dped=sqrt(sig2);        if(dac == 0)             { dacs.ped = ped;              dacs.dped = dped;            }        if(fdata[ipk]>1020) goto fithi;        val = (double)fdata[kpeak] - ped;        el = (double)fdata[kpeak-1] - ped;        er = (double)fdata[kpeak+1] - ped;        ep = val;        estimator = (el-er)/ep;        if(ipk>=klo && ipk<=khi && fdata[kpeak]<1020)         { sev = sev + 1.0;           sxev = sxev + val;           sxxev = sxxev + val*val;           sxest = sxest + estimator;}                     } /* end of nevnt loop */        val=0.0;        if(sev>0.0)           {val = sxev / sev;           estimator = sxest / sev;           if(sw(5) == 1) printf(" high gain dac=%d charge=%f fmean=%f\n",           dac,charge,val);           sig=0.0;           sig2=sxxev/sev - val*val;           if(sig2>0.0) sig=sqrt(sig2);           dacs.cg[nevent] = charge;           dacs.amp[nevent] = val;           dacs.damp[nevent] = sig;           nevent++;          }        if(val>0.0 && val<1000.0)         { crg[icnt] = charge;           fvl[icnt] = val;           if(charge>0.0)            { s = s +1.0;              sx = sx + charge;              sy = sy + val;              sxy = sxy + charge*val;              sx2 = sx2 + charge*charge;}           icnt++; }   }  /* end of dac loop */   dacs.nev = nevent-1;   newtime();    tmin = ttinterval();    if(ipass != 0) rad = source * tmin / 60.0;   dacs.rad = rad;   dacs.month = month;   dacs.day = day;   dacs.hour = hour;   dacs.min = min;   nwds = fwrite(&dacs.nev,4,615,fp_dac);   ierr = ferror(fp_dac);   if(ierr != 0) printf(" error writing to fp_dac %x\n",ierr);fithi:   ddel = s*sx2 - sx*sx;   a = (sx2*sy - sx*sxy) / ddel;   b = (s*sxy - sx*sy) / ddel;   if(sw(5) == 1) printf(" higain fit results a=%f b=%f y=a+b*charge\n",a,b);   ah = a;   bh = b;   for(k=0;k<icnt;k++)    {x = crg[k];     y = a + b*x;     dely = y - fvl[k];     sw3 = sw(3);     if(sw3 == 1) printf("k=%d x=%f  y=%f  fvl[k]=%f  dely=%f\n",       k,x,y,fvl[k],dely);    }/* ---------------------- low gain calibration --------------------------*/    base = 0xf0ee0000;    delay = 0x80000006;    flex_setup();    capacitor = 100.0;    dacs.cap = capacitor;    send4_3in1(4,0);   /* disable small C */    send4_3in1(5,1);   /* enable large C */   kpeak=(int)(cmaxl+0.5);   klo=kpeak-2;   khi=kpeak+2;   timf=(int)(tmaxl+0.5);   if(sw(5) == 1) printf("starting logain  kpeak=%d timf=%d\n",kpeak,timf);   kpeakl = kpeak;   timfl = timf;   tf = (unsigned short)timf;   tim2_set(tf);   icnt=0;   s=0.0;   sx=0.0;   sy=0.0;   sxy=0.0;   sx2=0.0;   dstep = 12;   nevent=0;   for (dac=0; dac<1024; dac=dac+dstep)     { send13_3in1(6,dac);      volt = 8.0 * (double)dac/1023.0;      charge = volt * capacitor;      sev = 0.0;      sxev = 0.0;      sxxev = 0.0;      sxest = 0.0;      for(nevnt=0;nevnt<nevmax;nevnt++)       {        flex_reset();        rtime();        tsleep(0x80000002);        inject();/*     go read the fermi module ------------------------------- */        flex_read();/*     display ? */         sw1 = sw(1);         if(sw1 == 1)           { asum = 0.0;            axsum = 0.0;            axxsum = 0.0;            for(i=10;i<20;i++)             { aval = (double)fdata[i];               asum = asum+1.0;               axsum = axsum + aval;               axxsum = axxsum + aval*aval;              }            ped = axsum / asum;            dped = 0.0;            sig2=axxsum/asum - ped*ped;            if(sig2>0.0) dped=sqrt(sig2);            sprintf(string,              "lo gain ipk=%d  pk=%d  ped=%f +/- %f",              ipk,pk,ped,dped);            evdisp(32,string,2);}        asum = 0.0;        axsum = 0.0;        axxsum = 0.0;        for(i=10;i<20;i++)         { aval = (double)fdata[i];           asum = asum+1.0;           axsum = axsum + aval;           axxsum = axxsum + aval*aval;          }        ped = axsum / asum;        sig2=axxsum/asum - ped*ped;        if(sig2>0.0) dped=sqrt(sig2);        if(dac == 0)             { dacs.ped = ped;              dacs.dped = dped;            }        if(fdata[ipk]>1020) goto lofit;        val = (double)fdata[kpeak] - ped;        el = (double)fdata[kpeak-1] - ped;        er = (double)fdata[kpeak+1] - ped;        ep = val;        estimator = (el-er)/ep;        if(ipk>=klo && ipk<=khi && fdata[kpeak]<1020)         { sev = sev + 1.0;           sxev = sxev + val;           sxxev = sxxev + val * val;           sxest = sxest + estimator;}      } /* end of nevnt loop */        val=0.0;        if(sev>0.0)           {val = sxev / sev;           estimator = sxest / sev;           if(sw(5) == 1) printf("  low gain dac=%d charge=%f fmean=%f\n",           dac,charge,val);           sig=0.0;           sig2=sxxev/sev - val*val;           if(sig2>0.0) sig=sqrt(sig2);           dacs.cg[nevent] = charge;           dacs.amp[nevent] = val;           dacs.damp[nevent] = sig;           nevent++;          }        if(val>0.0 && val<1000.0)         { crg[icnt] = charge;           fvl[icnt] = val;           if(charge>50.0)            { s = s +1.0;              sx = sx + charge;              sy = sy + val;              sxy = sxy + charge*val;              sx2 = sx2 + charge*charge;}           icnt++; }   }  /* end of dac loop */   dacs.nev = nevent-1;   newtime();    tmin = ttinterval();    if(ipass != 0) rad = source * tmin / 60.0;   dacs.rad = rad;   dacs.month = month;   dacs.day = day;   dacs.hour = hour;   dacs.min = min;   nwds = fwrite(&dacs.nev,4,615,fp_dac);   ierr = ferror(fp_dac);   if(ierr != 0) printf(" error writing to fp_dac %x\n",ierr);lofit:   ddel = s*sx2 - sx*sx;   a = (sx2*sy - sx*sxy) / ddel;   b = (s*sxy - sx*sy) / ddel;   al = a;   bl = b;   if(sw(5) == 1) printf(" logain fit results a=%f b=%f y=a+b*charge\n",a,b);   for(k=0;k<icnt;k++)    {x = crg[k];     y = a + b*x;     dely = y - fvl[k];     sw3 = sw(3);     if(sw3 == 1) printf("k=%d x=%f  y=%f  fvl[k]=%f  dely=%f\n",k,x,y,fvl[k],dely);    }    ratio = bh/bl;    if(sw(5) == 1) printf("card=%d bh=%f  bl=%f  ratio=%f\n",card,bh,bl,ratio);    sw2 = sw(2);/* do the integrator test ------------------------------ */   max[0]=640;   max[1]=240;   max[2]=160;   max[3]=120;   max[4]=80;   max[5]=48;   del[0]=40;   del[1]=20;   del[2]=8;   del[3]=8;   del[4]=4;   del[5]=4;/*   isw[0]=1;   isw[1]=2;   isw[2]=0;   isw[3]=4;   isw[4]=8;   isw[5]=0xc;  */   isw[0] = 0xe;   isw[1] = 0xd;   isw[2] = 0xf;   isw[3] = 0xb;   isw[4] = 0x7;   isw[5] = 0x3;   tc = (unsigned short) 100;   tim1_set(tc);   tf = (unsigned short) 50;   tim2_set(tf);   rtime();   send4_3in1(0,0);  /* intg_rd=0 */   send4_3in1(1,0);  /* itr=0 */   send4_3in1(3,0);  /*set mse low */      for (gain=0;gain<6;gain++)    { send13_3in1(2,isw[gain]);      send13_3in1(6,0);      send4_3in1(0,0);  /* intg_rd=0 */      send4_3in1(1,0);  /* itr=0 */      tsleep(0x80000050);      go_get(&intgs.ped[gain]);      dacmax = max[gain];      k=0;      for(dc=0;dc<dacmax;dc=dc+del[gain])               { send13_3in1(6,dc);          intgs.dc[gain][k]=dc;          go_get(&intgs.volts[gain][k]);          if(sw(3) == 1) printf("gain=%d dac=%d volt=%6.3f\n",          gain,dc,intgs.volts[gain][k]);          k++;        } /* end of dac loop */      intgs.nev[gain] = k-1;/* check disconnect */          go_get(&volt_connected);          intgs.v00[gain] = volt_connected;          send4_3in1(0,1);  /* intg_rd=1 */          go_get(&volt_no_intg);          intgs.v10[gain] = volt_no_intg;          send4_3in1(0,0);  /* intg_rd=0 */          send4_3in1(1,1);  /* itr=1 */          go_get(&volt_no_itr);          intgs.v01[gain] = volt_no_itr;          printf("gain=%d volt=%6.3f  volt_no_intg=%6.3f  volt_no_itr=%6.3f\n",              gain,volt_connected,volt_no_intg,volt_no_itr);          send4_3in1(1,0);  /* itr=0 */          send4_3in1(0,0);  /* intg_rd=0 */    } /* end of gain loop */   newtime();    tmin = ttinterval();    if(ipass != 0) rad = source * tmin / 60.0;   intgs.rad = rad;   intgs.month = month;   intgs.day = day;   intgs.hour = hour;   intgs.min = min;    nwds = fwrite(&intgs.month,4,432,fp_int);    ierr = ferror(fp_int);    if(ierr != 0) printf(" error writing to fp_int %x\n",ierr);    newtime();    tmin = ttinterval();    if(ipass != 0) rad = source * tmin / 60.0;    printf(" %d  %d/%d/%d  %d:%d   %d\n",           ntotal,month,day,year,hour,min,dmin);    printf("     last event meanhp=%4.1f  meanhc=%6.2f  meanlp=%4.1f  meanlc=%6.2f rad=%f\n",       meanhp,meanhc,meanlp,meanlc,rad);    fprintf(fp_time," %d  %d/%d/%d  %d:%d   %d\n",           ntotal,month,day,year,hour,min,dmin);   } /* end of doit *//* old switch modulesw(i)  int i;  {int *adr,k,l,shft;   adr=(int *)0x80cf0000;   k=*adr;   shft=23+i;   l=(k>>shft)&1;    return(l);  }      */sw(i)   /* new switch timer module */int i;{ int k,l,shift;  unsigned short *adr;  adr = (unsigned short *)( 0xf0aa000c);  k = *adr;  shift = i-1;  l = (k>>shift) & 1;  return(l);}flex_setup()  { reg0 = (unsigned short *)base;    reg2 = (unsigned short *)(base | 0x2);    reg4 = (unsigned short *)(base | 0x4);    reg6 = (unsigned short *)(base | 0x6);    reg8 = (unsigned short *)(base | 0x8);    rega = (unsigned short *)(base | 0xa);    *reg2 = 32;  }flex_reset()  { *reg0 = 0;  }inject()  { tp_high();    tsleep(delay);     stime();    tsleep(0x80000002);/*    rtime(); */  }flex_read()  { int i,k,adr,adc_enable,read_done,adc_done,kk;    sw4 = sw(4);    pk = 0;    ipk = 0;     for(i=0;i<32;i++)      { kk = *reg8;        tsleep(0x80000001);        *rega=0; /* clock the shift register */        adr = kk & 0xff;        adc_done = (kk & 0x2000)>>13;        adc_enable = (kk & 0x4000)>>14;        read_done = (kk & 0x8000)>>15;         kk = *reg4;        k = kk & 0xfff;        k = (k>>2);  /* make it 10 bits */        fdata[i] = k;        if(k>pk)          { ipk = i;            pk = k;}        if(sw4 == 1) printf(" i=%d  adr = %x  data=%x  en=%d rd=%d  ad=%d\n",         i,adr,k,adc_enable,read_done,adc_done);      }}evdisp(nn,string) int nn; char *string; { int max,mmax,idx,idy,ny,linx,ixbas,iybas,ix,iy,iylst,kx,ky,i,k,ii;   int idel;   double dely,y,dy;   char str[5];   erasm();   max = pk;   mmax=5000;   if(max<4000) mmax=4000;   if(max<3000) mmax=3000;   if(max<2000) mmax=2000;   if(max<1000) mmax=1000;   if(max<800) mmax=800;   if(max<600) mmax=600;   if(max<500) mmax=500;   if(max<400) mmax=400;   if(max<200) mmax=200;   if(max<100) mmax=100;   if(max<50) mmax=50;   idx = 1600/nn;   linx = idx*nn;   ixbas = 100+(2200-linx)/2;   dy = 2400.0/(double)mmax;   iybas = 400;   mova(ixbas,iybas);   drwr(linx,0);   mova(ixbas,iybas);   iylst = 0;   for(i=0;i<nn;i++)    { ii = fdata[i];      y = (double)ii;      y = y*dy;      iy = (int)y;      idy = iy-iylst;      drwr(0,idy);      drwr(idx,0);      iylst=iy;    }      drwr(0,-iylst);/*  label horizontal axis */    idel=10;    if(nn>100) idel=25;    if(nn>200) idel=50;    for(i=0;i<nn+1;i=i+idel)     { ix=ixbas+idx*i;       mova(ix,iybas);       drwr(0,-30);       k=i/2;       if(k*2 == i)         { sprintf(str,"%3d",i);           kx = ix-45;           if(i<100) kx = ix-55;           if(i<10) kx=ix-75;           symb(kx,iybas-100,0.0,str);         }     }/*  label vertical axis  */    ny=mmax/100;    if(ny>10) ny=10;    if(mmax == 200) ny=4;    if(mmax == 100) ny=4;    if(mmax == 50) ny=5;    y=(double)mmax*dy;    iy = (int)y;    mova(ixbas,iybas);    drwr(0,iy);    for(i=0;i<=ny;i++)     { ky = i*mmax/ny;       y = (double)ky * dy;       iy = (int)y + iybas;       mova(ixbas,iy);       drwr(-20,0);       sprintf(str,"%4d",ky);       kx = ixbas-150;       symb(kx,iy-20,0.0,str);     }    /*  print label */    symb(200,3000,0.0,string);    plotmx(); }    double hstfit(i,l,x)    int i,l;    double x;    {double y;     y=0.0;     return(y);     }      go_get(v)      double *v;      {double volts;       char string[80];       if(ent == 0)         {gpib_reset();          sendmessage(gpib_adr,"A2 X");          sendmessage(gpib_adr,"A?");          getmessage(gpib_adr, &string[0] );/*          printf("A2 back=%s\n",string); */          sendmessage(gpib_adr,"C X");          sendmessage(gpib_adr,"C?");          getmessage(gpib_adr, &string[0] );/*          printf("C back=%s\n",string); */            sendmessage(gpib_adr,"R3 X");          sendmessage(gpib_adr,"R?");          getmessage(gpib_adr, &string[0] );/*          printf("R1,3 back=%s\n",string); */          sendmessage(gpib_adr,"N1 X");          sendmessage(gpib_adr,"N?");          getmessage(gpib_adr, &string[0] );/*          printf("N1 back=%s\n",string); */          sendmessage(gpib_adr,"G0 X");          sendmessage(gpib_adr,"G?");          getmessage(gpib_adr, &string[0] );/*          printf("G0 back=%s\n",string); */            sendmessage(gpib_adr,"Q0 X");          sendmessage(gpib_adr,"Q?");          getmessage(gpib_adr, &string[0] );/*          printf("Q0 back=%s\n",string); */          ent=1;         }          sendmessage(gpib_adr,"T6 X");          sendmessage(gpib_adr,"T?");          getmessage(gpib_adr, &string[0] );/*          printf("T6 back=%s\n",string); *//*          sleep(2); */          tsleep(0x80000020);          getmessage(gpib_adr, &string[0] );/*          printf("first readback=%s\n",string); */          sscanf(string,"%le",&volts);/*          printf("volts=%e\n",volts);  */          *v=volts;          return(0);}newtime() {  getime(&tims.year);    year = (int)tims.year;    month = (int)tims.month;    day = (int)tims.day;    hour = (int)tims.hour;    min = (int)tims.minute;    sec = (int)tims.second; }ttinterval() { static int daym[13] = {0,31,28,31,30,31,30,31,31,30,31,30,31};   int sday,dday,dhour,dmin,interval;   if(month == l0month) dday = day - l0day;   if(month != l0month)      { sday = day + daym[l0month];       dday = sday - l0day;     }   dhour = hour - l0hour;   dmin = min - l0min;   interval = dday * 1440 + dhour * 60 + dmin;/*   printf("now  %d/%d/%d %d:%d:%d\n",year,month,day,hour,min,sec);     printf("total %d/%d/%d %d:%d:%d\n",lyear,lmonth,lday,lhour,lmin,lsec);     printf("dday=%d  dhour=%d  dmin=%d\n",dday,dhour,dmin);    printf("interval = %d\n",interval);  */   return(interval); }tinterval() { static int daym[13] = {0,31,28,31,30,31,30,31,31,30,31,30,31};   int sday,dday,dhour,dmin,interval;   if(month == lmonth) dday = day - lday;   if(month != lmonth)      { sday = day + daym[lmonth];       dday = sday - lday;     }   dhour = hour - lhour;   dmin = min - lmin;   interval = dday * 1440 + dhour * 60 + dmin;/*   printf("now  %d/%d/%d %d:%d:%d\n",year,month,day,hour,min,sec);     printf("last %d/%d/%d %d:%d:%d\n",lyear,lmonth,lday,lhour,lmin,lsec);     printf("dday=%d  dhour=%d  dmin=%d\n",dday,dhour,dmin);  */   return(interval); }