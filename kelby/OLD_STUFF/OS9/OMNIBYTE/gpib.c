#include <stdio.h>#include <math.h>#include "gpib.h"/* * send byte out to aux command register * using this function will give delay * needed for prototype omnimodule*/void auxcommand(command)        unsigned char command;        {        gpib->auxcmd = command;        }/* * function to get byte from the gpib interface*/short getbyte()        {        do                {                status |= gpib->stat0;           /* get and save all status bits */                }        while (!(status & 0x20));        status &= 0xdf;                                 /* only clear BI status bit */        return(gpib->datain);        }/* * function to send a byte out onto the gpib interface*/void sendbyte(data)        unsigned char data;        {        do                {                status |= gpib->stat0;		        /*   get and save all status bits */                }        while (!(status & 0x10));        status &= 0xef;                                 /* only clear BO status bit */        gpib->dataout = data;        }/* * getmessage: * gets a message from gpib device * uses polled i/o*/unsigned long getmessage(device, buf)        unsigned char device;         register unsigned char *buf;        {        register unsigned long count = 0;        sendbyte(UNT);                  /* send untalk command */        sendbyte(UNL);                  /* send unlisten command */        sendbyte(MTA | (device & 0x1f));        sendbyte(MLA | my_address);        auxcommand(lon);        auxcommand(gts);         do                {                *buf++ = getbyte();                count++;                }        while (!(status & 0x08));        status &= 0xf7;                         /* clear END status bit */        auxcommand(tca);                        /* take control */        *buf = '\0';                            /* null terminate string */        return(count);        }/* * sendmessage: * sends a message over the gpib bus * uses polled i/o*/void sendmessage(device, buf)        unsigned char device;         register unsigned char *buf;        {        sendbyte(UNT);                  /* send untalk command */        sendbyte(UNL);                  /* send unlisten command */        sendbyte(MLA | (device & 0x1f));        sendbyte(MTA | my_address);        auxcommand(ton);        auxcommand(gts);        while (*(buf + 1))                {                sendbyte(*buf++);                }        auxcommand(feoi);               /* set EOI for the last byte */        sendbyte(*buf);        do                {                status |= gpib->stat0;           /* get and save all status bits */                }        while (!(status & 0x10));        status &= 0xef;                                 /* only clear BO status bit */        auxcommand(tca);        }/* * send a buffer over gpib using polled i/o*/void sendbuffer(device, buf, size)        unsigned char device;         register unsigned char *buf;        register unsigned long size;        {        sendbyte(UNT);                  /* send untalk command */        sendbyte(UNL);                  /* send unlisten command */        sendbyte(MLA | (device & 0x1f));        sendbyte(MTA | my_address);        auxcommand(ton);        auxcommand(gts);        while (size--)                {                sendbyte(*buf++);                }        auxcommand(feoi);               /* set EOI for the last byte */        sendbyte(*buf);        do                {                status |= gpib->stat0;           /* get and save all status bits */                }        while (!(status & 0x10));        status &= 0xef;                                 /* only clear BO status bit */        auxcommand(tca);        }/* * serial poll function * gets status byte from selected device * we must already be in control of the bus * Returns status byte or negative error word (someday)*/unsigned short serialpoll(device)        unsigned char device;                /* address of device to poll */        {        unsigned char poll;        auxcommand(cton);               /* turn off talker */        sendbyte(UNT);                  /* send untalk command */        sendbyte(UNL);                  /* send unlisten command */        sendbyte(SPE);                  /* serial poll */        sendbyte(MTA | (device & 0x1f));        auxcommand(lon);                /* turn on listener */        auxcommand(gts);                /* go to standby */        do                {                status |= gpib->stat0;           /* get and save all status bits */                }        while (!(status & 0x20));        status &= 0xdf;                                 /* only clear BI status bit */        auxcommand(tcs);        poll = gpib->datain;        auxcommand(clon);               /* turn off listener */        sendbyte(SPD);        return(poll);        }/* * routine to check device using serial poll * and compare results with desired results * on error will print message and exit*/unsigned char serialcheck(device, condition)        unsigned char device;        unsigned char condition;        {        unsigned char poll;        while((poll = serialpoll(device)) & 0x80)                ;        if (poll != condition)                {                printf("serial poll error wanted = %x actual = %x\n", condition, poll);                exit(1);                }        else                {                return(poll);                }        }void gpib_reset()        { unsigned char *adr;        unsigned long i,vmead;        unsigned char vio_status;        unsigned char zero = 0;           /* force zero write to registers */        printf("entered gpib_reset\n");        adr = (unsigned char *)0x80e00000;        *(adr+0x81) = *(adr+0x81) & 0x7f;  /* trun on fail led as check */        sleep(1);        *(adr+0x81) = 0xc0;  /* clear board fail led and allow                                 * non-privileged and supervisory accesses */        vio_status = *(adr+0x81);        printf("gpib_reset vio_status=%x\n",vio_status);	switch (vio_status & 0x7)	   {	   case 0:	     vmead = 0x80e00200;	     break;	   case 1:	     vmead = 0x80e00400;	     break;	   case 2:	     vmead = 0x80e00800;	     break;	   case 3:	     vmead = 0x80e01000;	     break;	   case 4:	     vmead = 0x80e02000;	     break;	  default:	     printf(" no baseboard\n");	     exit(1);	  }    printf("vmead=%x\n",vmead);    gpib = (struct block *)vmead;        printf("adr+1=%x\n",*(adr+1));        if (*(adr+1) != 0x3f)           { printf("module 0 does not have gpib installed.  ID = 0x%x\n",	        gpib->stat0);            exit(1);          }      status = 0;    gpib->sclatch = 0x80;    /* set latch to system controller function */    auxcommand(swrst);              /* software reset */    gpib->mask0 = zero;              /* mask all interrupts */    gpib->mask1 = zero;    gpib->address = 1;               /* set address register for 	                                              address 1 */    auxcommand(sic);                /* turn on IFC */    auxcommand(cswrst);             /* clear software reset */    auxcommand(sre);                /* turn on REN *//*    for(i = 1000; i; --i); *//* delay 100 microseconds */    sleep(1);    auxcommand(csic);               /* release IFC */ /*   *(adr+0xc1) = 0x31;  *//* BIM control register 0 */    printf("stat0=%x\n",gpib->stat0);    printf("stat0=%x\n",gpib->stat0);    printf("stat0=%x\n",gpib->stat0);  }/* * patterened after sendmessage: * but will send null bytes * sends a message over the gpib bus * uses polled i/o*/     sendsize(device, buf,ipnt)        unsigned char device;         register unsigned char *buf;        int ipnt;        {        int i;        sendbyte(UNT);                  /* send untalk command */        sendbyte(UNL);                  /* send unlisten command */        sendbyte(MLA | (device & 0x1f));        sendbyte(MTA | my_address);        auxcommand(ton);        auxcommand(gts);        for(i=0;i<ipnt-1;i++)                {                                sendbyte(*buf++);                }        auxcommand(feoi);               /* set EOI for the last byte */        sendbyte(*buf);        do                {                status |= gpib->stat0;           /* get and save all status bits */                }        while (!(status & 0x10));        status &= 0xef;                                 /* only clear BO status bit */        auxcommand(tca);        }