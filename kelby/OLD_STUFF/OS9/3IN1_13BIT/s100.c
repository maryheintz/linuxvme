#include <stdio.h>#include <math.h>#include <time.h>int sw1,sw2,sw3,sw4,sw5,sw6,sw7,sw8;int fdata[3][256],ipk[3],pk[3];struct{unsigned int trig;       unsigned int reset;       unsigned int status;       unsigned int sample;       unsigned int delay;       unsigned int rdall;       unsigned int rd2;       unsigned int rd1;       unsigned int rd0;}fermi;unsigned short *reg;unsigned short *reg0,*reg1,*reg2;unsigned int base=0xf0ee0000;unsigned int base2=0x80ee0000;main(argc,argv,envs)int argc;char *argv[];char *envs[];  { FILE *fp;    double asum,axsum,axxsum,ped,dped,sig2,aval;    int timc,timf,i,icap,l;    int zone,sector,card,time1,time2,time3,time4;    int dac;    double capacitor,dacval;    double charge,charge_true;    char xstring[80],ystring[80],string[80],err[80];    unsigned short cadr,tc,tf;    unsigned short sval,dval;    int nev = 0;    fermi_setup();    zone = 1;    sector = 1;    time1 = 0;    time2 = 0;    time3 = 0;    time4 = 0;    set_drawer_timer(zone,sector,1,time1);    set_drawer_timer(zone,sector,2,time2);    set_drawer_timer(zone,sector,3,time3);    set_drawer_timer(zone,sector,4,time4);    multi_low();    card = 47;    i = (zone<<12) | (sector<<6) | card;    cadr = (unsigned short)i;    card_sel(cadr);    send13_3in1(2,0);   /* s1=s2=s3=s4=0 */    send4_3in1(1,0);   /* itr=0 */    send4_3in1(0,1);   /* ire=0 */    send4_3in1(3,1);   /* mse=0 */    send4_3in1(4,1);   /* small C enable */    send4_3in1(5,0);   /* large C disable */    send4_3in1(7,1);   /* trig enable */    tc = (unsigned short)25;    tim1_set(tc);   /* coarse */    tf = 0;    tim2_set(tf);   /* fine */    capacitor = 5.2;/*    charge = 3.0;    dacval = (charge * 1023.0 ) / (2.0 * 4.096* capacitor);    if(dacval > 1023.0) dacval = 1023.0;    dac = (int) dacval;  */    dac = 10;    charge = ( 2.0 * 4.096 * capacitor *(double)dac ) / 1023.0;    printf(" charge=%f  dacval=%f  dac=%x(hex)  cap=%f\n",           charge,dacval,dac,capacitor);    fermi_setup();    send13_3in1(6,dac);        rtime();loop:        nev++;        fermi_reset();        tp_high();        tsleep(5);        tp_low();        if(sw(1) == 1) goto loop;        if(nev < 100) goto loop;}  /* end of main */fermi_setup() { FPermit(base,0x100,3);   FPermit(base2,0x100,3);   fermi.trig=base+0x26;   fermi.reset=base+0x24;   fermi.status=base+0x22;   fermi.sample=base+0x20;   fermi.delay=base+0x1e;   fermi.rdall=base2+0x18;   fermi.rd2=base+0x14;   fermi.rd1=base+0x12;   fermi.rd0=base+0x10;/* issue reset */   reg=(unsigned short *)fermi.reset;   *reg=0;/* set to full 255 samples */   reg=(unsigned short *)fermi.sample;   *reg=255;/* set delay */   reg=(unsigned short *)fermi.delay;   *reg=2;   reg0=(unsigned short *) fermi.rd0;   reg1=(unsigned short *) fermi.rd1;   reg2=(unsigned short *) fermi.rd2; }fermi_reset() { /* issue reset */   reg=(unsigned short *)fermi.reset;   *reg=0; }fermi_read() { int stat,data_ready,busy,lcnt,i,k0,k1,k2,kmax0,kmax1,kmax2;   int dd0,dd1,dd2;   unsigned short sd0,sd1,sd2;   /* wait for a trigger */   lcnt=0;loop:   lcnt++;   reg = (unsigned short *)fermi.status;   stat = *reg;   data_ready = stat & 4;   busy = stat & 2;   if(lcnt > 1000 ) goto error;   if ( data_ready == 0 ) goto loop;   /* read the data and find peak channel */   k0=0;   kmax0=0;   k1=0;   kmax1=0;   k2=0;   kmax2=0;   for (i=0;i<255;i++)    { sd0 = *reg0;      dd0 = (int)sd0 & 0xfff;      fdata[0][i] = 0xfff - dd0;      if(fdata[0][i]>kmax0)       { kmax0=fdata[0][i];         k0=i;}      sd1 = *reg1;      dd1 = (int)sd1 & 0xfff;      fdata[1][i] = 0xfff - dd1;      if(fdata[1][i]>kmax1)       { kmax1=fdata[1][i];         k1=i;}      sd2 = *reg2;      dd2 = (int)sd2 & 0xfff;      fdata[2][i] = 0xfff - dd2;      if(fdata[2][i]>kmax2)       { kmax2=fdata[2][i];         k2=i;}      sw4 = sw(4);      if(sw4 == 1) printf("i=%d  dd0=%d  dd1=%d  dd2=$d\n",i,dd0,dd1,dd2);     }   ipk[0]=k0;   pk[0]=kmax0;   ipk[1]=k1;   pk[1]=kmax1;   ipk[2]=k2;   pk[2]=kmax2;   return(0);error:   ipk[0]=-1;   ipk[1]=-1;   ipk[2]=-1;}sw(i)   /* new switch timer module */int i;{ int k,l,shift;  unsigned short *adr;  adr = (unsigned short *)( 0xf0aa000c);  k = *adr;  shift = i-1;  l = (k>>shift) & 1;  return(l);}