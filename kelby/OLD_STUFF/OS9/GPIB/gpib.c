#include "gpib.h"/* * send byte out to aux command register * using this function will give delay * needed for prototype omnimodule*/void auxcommand(command)        unsigned char command;        {        gpib->auxcmd = command;        }/* * function to get byte from the gpib interface*/short getbyte()        {        register GPIB *pio = gpib;        do                {                status |= pio->stat0;           /* get and save all status bits */                }        while (!(status & 0x20));        status &= 0xdf;                                 /* only clear BI status bit */        return(pio->datain);        }/* * function to send a byte out onto the gpib interface*/void sendbyte(data)        unsigned char data;        {        register GPIB *pio = gpib;        do                {                status |= pio->stat0;      /*   get and save all status bits */                }        while (!(status & 0x10));        status &= 0xef;                                 /* only clear BO status bit */        pio->dataout = data;        }/* * getmessage: * gets a message from gpib device * uses polled i/o*/unsigned long getmessage(device, buf)        unsigned char device;         register unsigned char *buf;        {        register GPIB *pio = gpib;        register unsigned long count = 0;        sendbyte(UNT);                  /* send untalk command */        sendbyte(UNL);                  /* send unlisten command */        sendbyte(MTA | (device & 0x1f));        sendbyte(MLA | my_address);        auxcommand(lon);        auxcommand(gts);         do                {                *buf++ = getbyte();                count++;                }        while (!(status & 0x08));        status &= 0xf7;                         /* clear END status bit */        auxcommand(tca);                        /* take control */        *buf = '\0';                            /* null terminate string */        return(count);        }/* * sendmessage: * sends a message over the gpib bus * uses polled i/o*/void sendmessage(device, buf)        unsigned char device;         register unsigned char *buf;        {        register GPIB *pio = gpib;        sendbyte(UNT);                  /* send untalk command */        sendbyte(UNL);                  /* send unlisten command */        sendbyte(MLA | (device & 0x1f));        sendbyte(MTA | my_address);        auxcommand(ton);        auxcommand(gts);        while (*(buf + 1))                {                sendbyte(*buf++);                }        auxcommand(feoi);               /* set EOI for the last byte */        sendbyte(*buf);        do                {                status |= pio->stat0;           /* get and save all status bits */                }        while (!(status & 0x10));        status &= 0xef;                                 /* only clear BO status bit */        auxcommand(tca);        }/* * send a buffer over gpib using polled i/o*/void sendbuffer(device, buf, size)        unsigned char device;         register unsigned char *buf;        register unsigned long size;        {        register GPIB *pio = gpib;        sendbyte(UNT);                  /* send untalk command */        sendbyte(UNL);                  /* send unlisten command */        sendbyte(MLA | (device & 0x1f));        sendbyte(MTA | my_address);        auxcommand(ton);        auxcommand(gts);        while (size--)                {                sendbyte(*buf++);                }        auxcommand(feoi);               /* set EOI for the last byte */        sendbyte(*buf);        do                {                status |= pio->stat0;           /* get and save all status bits */                }        while (!(status & 0x10));        status &= 0xef;                                 /* only clear BO status bit */        auxcommand(tca);        }/* * serial poll function * gets status byte from selected device * we must already be in control of the bus * Returns status byte or negative error word (someday)*/unsigned short serialpoll(device)        unsigned char device;                /* address of device to poll */        {        register GPIB *pio = gpib;        unsigned char poll;        auxcommand(cton);               /* turn off talker */        sendbyte(UNT);                  /* send untalk command */        sendbyte(UNL);                  /* send unlisten command */        sendbyte(SPE);                  /* serial poll */        sendbyte(MTA | (device & 0x1f));        auxcommand(lon);                /* turn on listener */        auxcommand(gts);                /* go to standby */        do                {                status |= pio->stat0;           /* get and save all status bits */                }        while (!(status & 0x20));        status &= 0xdf;                                 /* only clear BI status bit */        auxcommand(tcs);        poll = pio->datain;        auxcommand(clon);               /* turn off listener */        sendbyte(SPD);        return(poll);        }/* * routine to check device using serial poll * and compare results with desired results * on error will print message and exit*/unsigned char serialcheck(device, condition)        unsigned char device;        unsigned char condition;        {        unsigned char poll;        while((poll = serialpoll(device)) & 0x80)                ;        if (poll != condition)                {                printf("serial poll error wanted = %x actual = %x\n", condition, poll);                exit(1);                }        else                {                return(poll);                }        }/* * setup for controller function from a reset condition * vio board specific configuration done here. Base address * of omnimodule determined based on VIO board block size * and assuming plugged in as module 0.*/void gpib_reset()        {        register unsigned char *pvio = vio;        register GPIB *pio;        unsigned long i;        unsigned char vio_status;        unsigned char zero = 0;           /* force zero write to registers */        unsigned long a1,a2;        printf("pvio=%x\n",(int)pvio);        *(pvio + 0x81) = *(pvio + 0x81) & 0x7f;                  /* turn on bd fail led as check *//*        printf("led set on\n"); */        sleep(1);/*        printf("setting led back off\n"); */        *(pvio + 0x81) = 0xc0;  /* clear board fail led and allow                                 * non-privileged and supervisory accesses */        vio_status = *(pvio +0x81);/*        printf("gpib_reset vio_status=%x\n",vio_status); */        switch (vio_status & 0x7) {         /* determine omnimodule base address */        case 0:          a1 = (unsigned long)pvio;          a2 = a1 + 0x200;          pio = (GPIB *)a2;          break;        case 1:          a1 = (unsigned long)pvio;          a2 = a1 + 0x400;          pio = (GPIB *)a2;          break;        case 2:          a1 = (unsigned long)pvio;          a2 = a1 + 0x800;          pio = (GPIB *)a2;          break;        case 3:          a1 = (unsigned long)pvio;          a2 = a1 + 0x1000;          pio = (GPIB *)a2;          break;        case 4:          a1 = (unsigned long)pvio;          a2 = a1 + 0x2000;          pio = (GPIB *)a2;          break;        default:          exit(1);              /* invalid setting causes bus error */        }        if (*(pvio + 1) != 0x3f)           {          printf("module 0 does not have gpib installed.  ID = 0x%x\n", *(pvio + 1));          exit(1);          }        gpib = pio;        printf("pio = %x\n",(int)pio);        status = 0;        pio->sclatch = 0x80;    /* set latch to system controller function */        printf(" sclatch stat0=%x  stat1=%x\n",pio->stat0,pio->stat1);        auxcommand(swrst);              /* software reset */        printf(" swrst stat0=%x  stat1=%x\n",pio->stat0,pio->stat1);        pio->mask0 = zero;              /* mask all interrupts */        pio->mask1 = zero;        printf(" mask stat0=%x  stat1=%x\n",pio->stat0,pio->stat1);        pio->address = 1;               /* set address register for address 1 */        printf(" adr stat0=%x  stat1=%x\n",pio->stat0,pio->stat1);        auxcommand(sic);                /* turn on IFC */        printf(" sic stat0=%x  stat1=%x\n",pio->stat0,pio->stat1);        auxcommand(cswrst);             /* clear software reset */        printf(" cswrst stat0=%x  stat1=%x\n",pio->stat0,pio->stat1);        auxcommand(sre);                /* turn on REN */        printf(" sre stat0=%x  stat1=%x\n",pio->stat0,pio->stat1);        for(i = 1000; i; --i);  /* delay 100 microseconds */        auxcommand(csic);               /* release IFC */        printf(" csic stat0=%x  stat1=%x\n",pio->stat0,pio->stat1);        printf(" gpib stat0=%x  stat1=%x\n",gpib->stat0,gpib->stat1);/*        *(pvio + 0xc1) = 0x31;*/  /* BIM control register 0 = 00110001                                 * IRQ level = 1                                 * Enable interrupts                                 * gpib omnimodule will supply vertor */        }/* * patterened after sendmessage: * but will send null bytes * sends a message over the gpib bus * uses polled i/o*/     sendsize(device, buf,ipnt)        unsigned char device;         register unsigned char *buf;        int ipnt;        {        int i;        register GPIB *pio = gpib;        sendbyte(UNT);                  /* send untalk command */        sendbyte(UNL);                  /* send unlisten command */        sendbyte(MLA | (device & 0x1f));        sendbyte(MTA | my_address);        auxcommand(ton);        auxcommand(gts);        for(i=0;i<ipnt-1;i++)                {                                sendbyte(*buf++);                }        auxcommand(feoi);               /* set EOI for the last byte */        sendbyte(*buf);        do                {                status |= pio->stat0;           /* get and save all status bits */                }        while (!(status & 0x10));        status &= 0xef;                                 /* only clear BO status bit */        auxcommand(tca);        }