<aiaff>
856444      0           68          849644      0           4658        4826        0           1193070196  200         0           100640      10  annotate.c`
#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "gd.h"

/* A neat little utility which adds freetype text to
	existing JPEG images. Type annotate -h for instructions. 
	Thanks to Joel Dubiner for supporting this work. -TBB */

enum
{
  left, center, right
};

int
main (int argc, char *argv[])
{
#ifndef HAVE_LIBFREETYPE
  /* 2.0.12 */
  fprintf (stderr, "annotate is not useful without freetype.\n"
	   "Install freetype, then './configure; make clean; make install'\n"
	   "the gd library again.\n");
  return 1;
#else
  gdImagePtr im;
  char *iin, *iout;
  FILE *in, *out;
  char s[1024];
  int bounds[8];
  int lines = 1;
  int color = gdTrueColor (0, 0, 0);
  char font[1024];
  int size = 12;
  int align = left;
  int x = 0, y = 0;
  char *fontError;
  strcpy (font, "times");
  if (argc != 3)
    {
      fprintf (stderr, "Usage: annotate imagein.jpg imageout.jpg\n\n");
      fprintf (stderr, "Standard input should consist of\n");
      fprintf (stderr, "lines in the following formats:\n");
      fprintf (stderr, "color r g b (0-255 each) [a (0-127, 0 is opaque)]\n");
      fprintf (stderr, "font fontname\n");
      fprintf (stderr, "size pointsize\n");
      fprintf (stderr, "align (left|right|center)\n");
      fprintf (stderr, "move x y\n");
      fprintf (stderr, "text actual-output-text\n\n");
      fprintf (stderr,
	       "If the file 'paris.ttf' exists in /usr/share/fonts/truetype or in a\n");
      fprintf (stderr,
	       "location specified in the GDFONTPATH environment variable, 'font paris' is\n");
      fprintf (stderr,
	       "sufficient. You may also specify the full, rooted path of a font file.\n");
      exit (1);
    }
  iin = argv[1];
  iout = argv[2];
  in = fopen (iin, "rb");
  if (!in)
    {
      fprintf (stderr, "Couldn't open %s\n", iin);
      exit (2);
    }
#ifdef HAVE_LIBJPEG
  im = gdImageCreateFromJpeg (in);
#else
  fprintf (stderr, "No JPEG library support available.\n");
#endif
  fclose (in);
  if (!im)
    {
      fprintf (stderr, "%s did not load properly\n", iin);
      exit (3);
    }
  while (fgets (s, sizeof (s), stdin))
    {
      char *st;
      char *text;
      st = strtok (s, " \t\r\n");
      if (!st)
	{
	  /* Be nice about blank lines */
	  continue;
	}
      if (!strcmp (st, "font"))
	{
	  char *st = strtok (0, " \t\r\n");
	  if (!st)
	    {
	      goto badLine;
	    }
	  strcpy (font, st);
	}
      else if (!strcmp (st, "align"))
	{
	  char *st = strtok (0, " \t\r\n");
	  if (!st)
	    {
	      goto badLine;
	    }
	  if (!strcmp (st, "left"))
	    {
	      align = 0;
	    }
	  else if (!strcmp (st, "center"))
	    {
	      align = 1;
	    }
	  else if (!strcmp (st, "right"))
	    {
	      align = 2;
	    }
	}
      else if (!strcmp (st, "size"))
	{
	  char *st = strtok (0, " \t\r\n");
	  if (!st)
	    {
	      goto badLine;
	    }
	  size = atoi (st);
	}
      else if (!strcmp (st, "color"))
	{
	  char *st = strtok (0, "\r\n");
	  int r, g, b, a = 0;
	  if (!st)
	    {
	      goto badLine;
	    }
	  if (sscanf (st, "%d %d %d %d", &r, &g, &b, &a) < 3)
	    {
	      fprintf (stderr, "Bad color at line %d\n", lines);
	      exit (2);
	    }
	  color = gdTrueColorAlpha (r, g, b, a);
	}
      else if (!strcmp (st, "move"))
	{
	  char *st = strtok (0, "\r\n");
	  if (!st)
	    {
	      goto badLine;
	    }
	  if (sscanf (st, "%d %d", &x, &y) != 2)
	    {
	      fprintf (stderr, "Missing coordinates at line %d\n", lines);
	      exit (3);
	    }
	}
      else if (!strcmp (st, "text"))
	{
	  int rx = x;
	  text = strtok (0, "\r\n");
	  if (!text)
	    {
	      text = "";
	    }
	  gdImageStringFT (0, bounds, color, font, size, 0, x, y, text);
	  switch (align)
	    {
	    case left:
	      break;
	    case center:
	      rx -= (bounds[2] - bounds[0]) / 2;
	      break;
	    case right:
	      rx -= (bounds[2] - bounds[0]);
	      break;
	    }
	  fontError = gdImageStringFT (im, 0, color, font,
				       size, 0, rx, y, text);
	  if (fontError)
	    {
	      fprintf (stderr, "font error at line %d: %s\n", lines,
		       fontError);
	      exit (7);
	    }
	  y -= (bounds[7] - bounds[1]);
	}
      else
	{
	  goto badLine;
	}
      lines++;
      continue;
    badLine:
      fprintf (stderr, "Bad syntax, line %d\n", lines);
      exit (4);
    }
  out = fopen (iout, "wb");
  if (!out)
    {
      fprintf (stderr, "Cannot create %s\n", iout);
      exit (5);
    }
#ifdef HAVE_LIBJPEG
  gdImageJpeg (im, out, 95);
#else
  fprintf (stderr, "No JPEG library support available.\n");
#endif
  gdImageDestroy (im);
  fclose (out);
  return 0;
#endif /* HAVE_LIBFREETYPE */
}
78625       83546       68          1193070198  200         0           100640      4   gd.c`
/* $Id: gd.c,v 1.49.2.16 2007/06/19 20:25:51 pajoye Exp $ */
#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include <stdio.h>
#include <math.h>
#include <string.h>
#include <stdlib.h>
/* 2.03: don't include zlib here or we can't build without PNG */
#include "gd.h"
#include "gdhelpers.h"

/* 2.0.12: this now checks the clipping rectangle */
#define gdImageBoundsSafeMacro(im, x, y) (!((((y) < (im)->cy1) || ((y) > (im)->cy2)) || (((x) < (im)->cx1) || ((x) > (im)->cx2))))

#ifdef _OSD_POSIX		/* BS2000 uses the EBCDIC char set instead of ASCII */
#define CHARSET_EBCDIC
#define __attribute__(any)	/*nothing */
#endif
/*_OSD_POSIX*/

#ifndef CHARSET_EBCDIC
#define ASC(ch)  ch
#else /*CHARSET_EBCDIC */
#define ASC(ch) gd_toascii[(unsigned char)ch]
static const unsigned char gd_toascii[256] = {
/*00 */ 0x00, 0x01, 0x02, 0x03, 0x85, 0x09, 0x86, 0x7f,
  0x87, 0x8d, 0x8e, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,	/*................ */
/*10 */ 0x10, 0x11, 0x12, 0x13, 0x8f, 0x0a, 0x08, 0x97,
  0x18, 0x19, 0x9c, 0x9d, 0x1c, 0x1d, 0x1e, 0x1f,	/*................ */
/*20 */ 0x80, 0x81, 0x82, 0x83, 0x84, 0x92, 0x17, 0x1b,
  0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x05, 0x06, 0x07,	/*................ */
/*30 */ 0x90, 0x91, 0x16, 0x93, 0x94, 0x95, 0x96, 0x04,
  0x98, 0x99, 0x9a, 0x9b, 0x14, 0x15, 0x9e, 0x1a,	/*................ */
/*40 */ 0x20, 0xa0, 0xe2, 0xe4, 0xe0, 0xe1, 0xe3, 0xe5,
  0xe7, 0xf1, 0x60, 0x2e, 0x3c, 0x28, 0x2b, 0x7c,	/* .........`.<(+| */
/*50 */ 0x26, 0xe9, 0xea, 0xeb, 0xe8, 0xed, 0xee, 0xef,
  0xec, 0xdf, 0x21, 0x24, 0x2a, 0x29, 0x3b, 0x9f,	/*&.........!$*);. */
/*60 */ 0x2d, 0x2f, 0xc2, 0xc4, 0xc0, 0xc1, 0xc3, 0xc5,
  0xc7, 0xd1, 0x5e, 0x2c, 0x25, 0x5f, 0x3e, 0x3f,
/*-/........^,%_>?*/
/*70 */ 0xf8, 0xc9, 0xca, 0xcb, 0xc8, 0xcd, 0xce, 0xcf,
  0xcc, 0xa8, 0x3a, 0x23, 0x40, 0x27, 0x3d, 0x22,	/*..........:#@'=" */
/*80 */ 0xd8, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,
  0x68, 0x69, 0xab, 0xbb, 0xf0, 0xfd, 0xfe, 0xb1,	/*.abcdefghi...... */
/*90 */ 0xb0, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f, 0x70,
  0x71, 0x72, 0xaa, 0xba, 0xe6, 0xb8, 0xc6, 0xa4,	/*.jklmnopqr...... */
/*a0 */ 0xb5, 0xaf, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78,
  0x79, 0x7a, 0xa1, 0xbf, 0xd0, 0xdd, 0xde, 0xae,	/*..stuvwxyz...... */
/*b0 */ 0xa2, 0xa3, 0xa5, 0xb7, 0xa9, 0xa7, 0xb6, 0xbc,
  0xbd, 0xbe, 0xac, 0x5b, 0x5c, 0x5d, 0xb4, 0xd7,	/*...........[\].. */
/*c0 */ 0xf9, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47,
  0x48, 0x49, 0xad, 0xf4, 0xf6, 0xf2, 0xf3, 0xf5,	/*.ABCDEFGHI...... */
/*d0 */ 0xa6, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f, 0x50,
  0x51, 0x52, 0xb9, 0xfb, 0xfc, 0xdb, 0xfa, 0xff,	/*.JKLMNOPQR...... */
/*e0 */ 0xd9, 0xf7, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58,
  0x59, 0x5a, 0xb2, 0xd4, 0xd6, 0xd2, 0xd3, 0xd5,	/*..STUVWXYZ...... */
/*f0 */ 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,
  0x38, 0x39, 0xb3, 0x7b, 0xdc, 0x7d, 0xda, 0x7e	/*0123456789.{.}.~ */
};
#endif /*CHARSET_EBCDIC */

extern int gdCosT[];
extern int gdSinT[];

static void gdImageBrushApply (gdImagePtr im, int x, int y);
static void gdImageTileApply (gdImagePtr im, int x, int y);
BGD_DECLARE(int) gdImageGetTrueColorPixel (gdImagePtr im, int x, int y);

BGD_DECLARE(gdImagePtr) gdImageCreate (int sx, int sy)
{
  int i;
  gdImagePtr im;

  if (overflow2(sizeof (unsigned char *), sy)) {
		return NULL;
  }
  if (overflow2(sizeof (unsigned char *), sx)) {
		return NULL;
  }

  im = (gdImage *) gdMalloc (sizeof (gdImage));
	if (!im) {
		return NULL;
	}

  memset (im, 0, sizeof (gdImage));
  /* Row-major ever since gd 1.3 */
  im->pixels = (unsigned char **) gdMalloc (sizeof (unsigned char *) * sy);
	if (!im->pixels) {
		gdFree(im);
		return NULL;
	}

  im->polyInts = 0;
  im->polyAllocated = 0;
  im->brush = 0;
  im->tile = 0;
  im->style = 0;
  for (i = 0; (i < sy); i++)
    {
      /* Row-major ever since gd 1.3 */
      im->pixels[i] = (unsigned char *) gdCalloc (sx, sizeof (unsigned char));
			if (!im->pixels[i]) 
			{
				for (--i ; i >= 0; i--)
				{
					gdFree(im->pixels[i]);
				}
				gdFree(im->pixels);
				gdFree(im);
				return NULL;
			}

    }
  im->sx = sx;
  im->sy = sy;
  im->colorsTotal = 0;
  im->transparent = (-1);
  im->interlace = 0;
  im->thick = 1;
  im->AA = 0;
  for (i = 0; (i < gdMaxColors); i++)
    {
      im->open[i] = 1;
      im->red[i] = 0;
      im->green[i] = 0;
      im->blue[i] = 0;
    };
  im->trueColor = 0;
  im->tpixels = 0;
  im->cx1 = 0;
  im->cy1 = 0;
  im->cx2 = im->sx - 1;
  im->cy2 = im->sy - 1;
  return im;
}

BGD_DECLARE(gdImagePtr) gdImageCreateTrueColor (int sx, int sy)
{
  int i;
  gdImagePtr im;

  if (overflow2(sx, sy)) {
    return NULL;
  }

  if (overflow2(sizeof (int *), sy)) {
    return 0;
  }

  if (overflow2(sizeof(int), sx)) {
    return NULL;
  }

  im = (gdImage *) gdMalloc (sizeof (gdImage));
  if (!im) {
    return 0;
  }
  memset (im, 0, sizeof (gdImage));

  im->tpixels = (int **) gdMalloc (sizeof (int *) * sy);
  if (!im->tpixels) {
    gdFree(im);
    return 0;
  }
  im->polyInts = 0;
  im->polyAllocated = 0;
  im->brush = 0;
  im->tile = 0;
  im->style = 0;
  for (i = 0; (i < sy); i++)
    {
      im->tpixels[i] = (int *) gdCalloc (sx, sizeof (int));
      if (!im->tpixels[i]) {
        /* 2.0.34 */
        i--;
        while (i >= 0) {
          gdFree(im->tpixels[i]);
          i--;
        }
        gdFree(im->tpixels);
        gdFree(im);
        return 0;
      }
    }
  im->sx = sx;
  im->sy = sy;
  im->transparent = (-1);
  im->interlace = 0;
  im->trueColor = 1;
  /* 2.0.2: alpha blending is now on by default, and saving of alpha is
     off by default. This allows font antialiasing to work as expected
     on the first try in JPEGs -- quite important -- and also allows 
     for smaller PNGs when saving of alpha channel is not really 
     desired, which it usually isn't! */
  im->saveAlphaFlag = 0;
  im->alphaBlendingFlag = 1;
  im->thick = 1;
  im->AA = 0;
  im->cx1 = 0;
  im->cy1 = 0;
  im->cx2 = im->sx - 1;
  im->cy2 = im->sy - 1;
  return im;
}

BGD_DECLARE(void) gdImageDestroy (gdImagePtr im)
{
  int i;
  if (im->pixels)
    {
      for (i = 0; (i < im->sy); i++)
	{
	  gdFree (im->pixels[i]);
	}
      gdFree (im->pixels);
    }
  if (im->tpixels)
    {
      for (i = 0; (i < im->sy); i++)
	{
	  gdFree (im->tpixels[i]);
	}
      gdFree (im->tpixels);
    }
  if (im->polyInts)
    {
      gdFree (im->polyInts);
    }
  if (im->style)
    {
      gdFree (im->style);
    }
  gdFree (im);
}

BGD_DECLARE(int) gdImageColorClosest (gdImagePtr im, int r, int g, int b)
{
  return gdImageColorClosestAlpha (im, r, g, b, gdAlphaOpaque);
}

BGD_DECLARE(int) gdImageColorClosestAlpha (gdImagePtr im, int r, int g, int b, int a)
{
  int i;
  long rd, gd, bd, ad;
  int ct = (-1);
  int first = 1;
  long mindist = 0;
  if (im->trueColor)
    {
      return gdTrueColorAlpha (r, g, b, a);
    }
  for (i = 0; (i < (im->colorsTotal)); i++)
    {
      long dist;
      if (im->open[i])
	{
	  continue;
	}
      rd = (im->red[i] - r);
      gd = (im->green[i] - g);
      bd = (im->blue[i] - b);
      /* gd 2.02: whoops, was - b (thanks to David Marwood) */
      /* gd 2.16: was blue rather than alpha! Geez! Thanks to 
         Artur Jakub Jerzak */
      ad = (im->alpha[i] - a);
      dist = rd * rd + gd * gd + bd * bd + ad * ad;
      if (first || (dist < mindist))
	{
	  mindist = dist;
	  ct = i;
	  first = 0;
	}
    }
  return ct;
}

/* This code is taken from http://www.acm.org/jgt/papers/SmithLyons96/hwb_rgb.html, an article
 * on colour conversion to/from RBG and HWB colour systems. 
 * It has been modified to return the converted value as a * parameter. 
 */

#define RETURN_HWB(h, w, b) {HWB->H = h; HWB->W = w; HWB->B = b; return HWB;}
#define RETURN_RGB(r, g, b) {RGB->R = r; RGB->G = g; RGB->B = b; return RGB;}
#define HWB_UNDEFINED -1
#define SETUP_RGB(s, r, g, b) {s.R = r/255.0; s.G = g/255.0; s.B = b/255.0;}

#define MIN(a,b) ((a)<(b)?(a):(b))
#define MIN3(a,b,c) ((a)<(b)?(MIN(a,c)):(MIN(b,c)))
#define MAX(a,b) ((a)<(b)?(b):(a))
#define MAX3(a,b,c) ((a)<(b)?(MAX(b,c)):(MAX(a,c)))


/*
 * Theoretically, hue 0 (pure red) is identical to hue 6 in these transforms. Pure 
 * red always maps to 6 in this implementation. Therefore UNDEFINED can be 
 * defined as 0 in situations where only unsigned numbers are desired.
 */
typedef struct
{
  float R, G, B;
}
RGBType;
typedef struct
{
  float H, W, B;
}
HWBType;

static HWBType *
RGB_to_HWB (RGBType RGB, HWBType * HWB)
{

  /*
   * RGB are each on [0, 1]. W and B are returned on [0, 1] and H is  
   * returned on [0, 6]. Exception: H is returned UNDEFINED if W == 1 - B.  
   */

  float R = RGB.R, G = RGB.G, B = RGB.B, w, v, b, f;
  int i;

  w = MIN3 (R, G, B);
  v = MAX3 (R, G, B);
  b = 1 - v;
  if (v == w)
    RETURN_HWB (HWB_UNDEFINED, w, b);
  f = (R == w) ? G - B : ((G == w) ? B - R : R - G);
  i = (R == w) ? 3 : ((G == w) ? 5 : 1);
  RETURN_HWB (i - f / (v - w), w, b);

}

static float
HWB_Diff (int r1, int g1, int b1, int r2, int g2, int b2)
{
  RGBType RGB1, RGB2;
  HWBType HWB1, HWB2;
  float diff;

  SETUP_RGB (RGB1, r1, g1, b1);
  SETUP_RGB (RGB2, r2, g2, b2);

  RGB_to_HWB (RGB1, &HWB1);
  RGB_to_HWB (RGB2, &HWB2);

  /*
   * I made this bit up; it seems to produce OK results, and it is certainly
   * more visually correct than the current RGB metric. (PJW)
   */

  if ((HWB1.H == HWB_UNDEFINED) || (HWB2.H == HWB_UNDEFINED))
    {
      diff = 0;			/* Undefined hues always match... */
    }
  else
    {
      diff = fabs (HWB1.H - HWB2.H);
      if (diff > 3)
	{
	  diff = 6 - diff;	/* Remember, it's a colour circle */
	}
    }

  diff =
    diff * diff + (HWB1.W - HWB2.W) * (HWB1.W - HWB2.W) + (HWB1.B -
							   HWB2.B) * (HWB1.B -
								      HWB2.B);

  return diff;
}


#if 0
/*
 * This is not actually used, but is here for completeness, in case someone wants to
 * use the HWB stuff for anything else...
 */
static RGBType *
HWB_to_RGB (HWBType HWB, RGBType * RGB)
{

  /* 
   * H is given on [0, 6] or UNDEFINED. W and B are given on [0, 1].  
   * RGB are each returned on [0, 1]. 
   */

  float h = HWB.H, w = HWB.W, b = HWB.B, v, n, f;
  int i;

  v = 1 - b;
  if (h == HWB_UNDEFINED)
    RETURN_RGB (v, v, v);
  i = floor (h);
  f = h - i;
  if (i & 1)
    f = 1 - f;			/* if i is odd */
  n = w + f * (v - w);		/* linear interpolation between w and v */
  switch (i)
    {
    case 6:
    case 0:
      RETURN_RGB (v, n, w);
    case 1:
      RETURN_RGB (n, v, w);
    case 2:
      RETURN_RGB (w, v, n);
    case 3:
      RETURN_RGB (w, n, v);
    case 4:
      RETURN_RGB (n, w, v);
    case 5:
      RETURN_RGB (v, w, n);
    }

  return RGB;

}
#endif

BGD_DECLARE(int) gdImageColorClosestHWB (gdImagePtr im, int r, int g, int b)
{
  int i;
  /* long rd, gd, bd; */
  int ct = (-1);
  int first = 1;
  float mindist = 0;
  if (im->trueColor)
    {
      return gdTrueColor (r, g, b);
    }
  for (i = 0; (i < (im->colorsTotal)); i++)
    {
      float dist;
      if (im->open[i])
	{
	  continue;
	}
      dist = HWB_Diff (im->red[i], im->green[i], im->blue[i], r, g, b);
      if (first || (dist < mindist))
	{
	  mindist = dist;
	  ct = i;
	  first = 0;
	}
    }
  return ct;
}

BGD_DECLARE(int) gdImageColorExact (gdImagePtr im, int r, int g, int b)
{
  return gdImageColorExactAlpha (im, r, g, b, gdAlphaOpaque);
}

BGD_DECLARE(int) gdImageColorExactAlpha (gdImagePtr im, int r, int g, int b, int a)
{
  int i;
  if (im->trueColor)
    {
      return gdTrueColorAlpha (r, g, b, a);
    }
  for (i = 0; (i < (im->colorsTotal)); i++)
    {
      if (im->open[i])
	{
	  continue;
	}
      if ((im->red[i] == r) &&
	  (im->green[i] == g) && (im->blue[i] == b) && (im->alpha[i] == a))
	{
	  return i;
	}
    }
  return -1;
}

BGD_DECLARE(int) gdImageColorAllocate (gdImagePtr im, int r, int g, int b)
{
  return gdImageColorAllocateAlpha (im, r, g, b, gdAlphaOpaque);
}

BGD_DECLARE(int) gdImageColorAllocateAlpha (gdImagePtr im, int r, int g, int b, int a)
{
  int i;
  int ct = (-1);
  if (im->trueColor)
    {
      return gdTrueColorAlpha (r, g, b, a);
    }
  for (i = 0; (i < (im->colorsTotal)); i++)
    {
      if (im->open[i])
	{
	  ct = i;
	  break;
	}
    }
  if (ct == (-1))
    {
      ct = im->colorsTotal;
      if (ct == gdMaxColors)
	{
	  return -1;
	}
      im->colorsTotal++;
    }
  im->red[ct] = r;
  im->green[ct] = g;
  im->blue[ct] = b;
  im->alpha[ct] = a;
  im->open[ct] = 0;
  return ct;
}

/*
 * gdImageColorResolve is an alternative for the code fragment:
 *
 *      if ((color=gdImageColorExact(im,R,G,B)) < 0)
 *        if ((color=gdImageColorAllocate(im,R,G,B)) < 0)
 *          color=gdImageColorClosest(im,R,G,B);
 *
 * in a single function.    Its advantage is that it is guaranteed to
 * return a color index in one search over the color table.
 */

BGD_DECLARE(int) gdImageColorResolve (gdImagePtr im, int r, int g, int b)
{
  return gdImageColorResolveAlpha (im, r, g, b, gdAlphaOpaque);
}

BGD_DECLARE(int) gdImageColorResolveAlpha (gdImagePtr im, int r, int g, int b, int a)
{
  int c;
  int ct = -1;
  int op = -1;
  long rd, gd, bd, ad, dist;
  long mindist = 4 * 255 * 255;	/* init to max poss dist */
  if (im->trueColor)
    {
      return gdTrueColorAlpha (r, g, b, a);
    }

  for (c = 0; c < im->colorsTotal; c++)
    {
      if (im->open[c])
	{
	  op = c;		/* Save open slot */
	  continue;		/* Color not in use */
	}
      if (c == im->transparent)
	{
	  /* don't ever resolve to the color that has
	   * been designated as the transparent color */
	  continue;
	}
      rd = (long) (im->red[c] - r);
      gd = (long) (im->green[c] - g);
      bd = (long) (im->blue[c] - b);
      ad = (long) (im->alpha[c] - a);
      dist = rd * rd + gd * gd + bd * bd + ad * ad;
      if (dist < mindist)
	{
	  if (dist == 0)
	    {
	      return c;		/* Return exact match color */
	    }
	  mindist = dist;
	  ct = c;
	}
    }
  /* no exact match.  We now know closest, but first try to allocate exact */
  if (op == -1)
    {
      op = im->colorsTotal;
      if (op == gdMaxColors)
	{			/* No room for more colors */
	  return ct;		/* Return closest available color */
	}
      im->colorsTotal++;
    }
  im->red[op] = r;
  im->green[op] = g;
  im->blue[op] = b;
  im->alpha[op] = a;
  im->open[op] = 0;
  return op;			/* Return newly allocated color */
}

BGD_DECLARE(void) gdImageColorDeallocate (gdImagePtr im, int color)
{
  if (im->trueColor)
    {
      return;
    }
  /* Mark it open. */
  im->open[color] = 1;
}

BGD_DECLARE(void) gdImageColorTransparent (gdImagePtr im, int color)
{
  if (!im->trueColor)
    {
      if (im->transparent != -1)
	{
	  im->alpha[im->transparent] = gdAlphaOpaque;
	}
      if (color != -1)
	{
	  im->alpha[color] = gdAlphaTransparent;
	}
    }
  im->transparent = color;
}

BGD_DECLARE(void) gdImagePaletteCopy (gdImagePtr to, gdImagePtr from)
{
  int i;
  int x, y, p;
  int xlate[256];
  if (to->trueColor)
    {
      return;
    }
  if (from->trueColor)
    {
      return;
    }

  for (i = 0; i < 256; i++)
    {
      xlate[i] = -1;
    };

  for (x = 0; x < (to->sx); x++)
    {
      for (y = 0; y < (to->sy); y++)
	{
          /* Optimization: no gdImageGetPixel */
	  p = to->pixels[y][x];
	  if (xlate[p] == -1)
	    {
	      /* This ought to use HWB, but we don't have an alpha-aware
	         version of that yet. */
	      xlate[p] =
		gdImageColorClosestAlpha (from, to->red[p], to->green[p],
					  to->blue[p], to->alpha[p]);
	      /*printf("Mapping %d (%d, %d, %d, %d) to %d (%d, %d, %d, %d)\n", */
	      /*      p,  to->red[p], to->green[p], to->blue[p], to->alpha[p], */
	      /*      xlate[p], from->red[xlate[p]], from->green[xlate[p]], from->blue[xlate[p]], from->alpha[xlate[p]]); */
	    };
          /* Optimization: no gdImageSetPixel */
	  to->pixels[y][x] = xlate[p];
	};
    };

  for (i = 0; (i < (from->colorsTotal)); i++)
    {
      /*printf("Copying color %d (%d, %d, %d, %d)\n", i, from->red[i], from->blue[i], from->green[i], from->alpha[i]); */
      to->red[i] = from->red[i];
      to->blue[i] = from->blue[i];
      to->green[i] = from->green[i];
      to->alpha[i] = from->alpha[i];
      to->open[i] = 0;
    };

  for (i = from->colorsTotal; (i < to->colorsTotal); i++)
    {
      to->open[i] = 1;
    };

  to->colorsTotal = from->colorsTotal;

}

/* 2.0.10: before the drawing routines, some code to clip points that are
 * outside the drawing window.  Nick Atty (nick@canalplan.org.uk)
 *
 * This is the Sutherland Hodgman Algorithm, as implemented by
 * Duvanenko, Robbins and Gyurcsik - SH(DRG) for short.  See Dr Dobb's
 * Journal, January 1996, pp107-110 and 116-117
 *
 * Given the end points of a line, and a bounding rectangle (which we
 * know to be from (0,0) to (SX,SY)), adjust the endpoints to be on
 * the edges of the rectangle if the line should be drawn at all,
 * otherwise return a failure code */

/* this does "one-dimensional" clipping: note that the second time it
   is called, all the x parameters refer to height and the y to width
   - the comments ignore this (if you can understand it when it's
   looking at the X parameters, it should become clear what happens on
   the second call!)  The code is simplified from that in the article,
   as we know that gd images always start at (0,0) */

/* 2.0.26, TBB: we now have to respect a clipping rectangle, it won't
	necessarily start at 0. */

static int
clip_1d (int *x0, int *y0, int *x1, int *y1, int mindim, int maxdim)
{
  double m;			/* gradient of line */
  if (*x0 < mindim)
    {				/* start of line is left of window */
      if (*x1 < mindim)		/* as is the end, so the line never cuts the window */
	return 0;
      m = (*y1 - *y0) / (double) (*x1 - *x0);	/* calculate the slope of the line */
      /* adjust x0 to be on the left boundary (ie to be zero), and y0 to match */
      *y0 -= m * (*x0 - mindim);
      *x0 = mindim;
      /* now, perhaps, adjust the far end of the line as well */
      if (*x1 > maxdim)
	{
	  *y1 += m * (maxdim - *x1);
	  *x1 = maxdim;
	}
      return 1;
    }
  if (*x0 > maxdim)
    {				/* start of line is right of window -
				   complement of above */
      if (*x1 > maxdim)		/* as is the end, so the line misses the window */
	return 0;
      m = (*y1 - *y0) / (double) (*x1 - *x0);	/* calculate the slope of the line */
      *y0 += m * (maxdim - *x0);	/* adjust so point is on the right
					   boundary */
      *x0 = maxdim;
      /* now, perhaps, adjust the end of the line */
      if (*x1 < mindim)
	{
	  *y1 -= m * (*x1 - mindim);
	  *x1 = mindim;
	}
      return 1;
    }
  /* the final case - the start of the line is inside the window */
  if (*x1 > maxdim)
    {				/* other end is outside to the right */
      m = (*y1 - *y0) / (double) (*x1 - *x0);	/* calculate the slope of the line */
      *y1 += m * (maxdim - *x1);
      *x1 = maxdim;
      return 1;
    }
  if (*x1 < mindim)
    {				/* other end is outside to the left */
      m = (*y1 - *y0) / (double) (*x1 - *x0);	/* calculate the slope of the line */
      *y1 -= m * (*x1 - mindim);
      *x1 = mindim;
      return 1;
    }
  /* only get here if both points are inside the window */
  return 1;
}

/* end of line clipping code */

BGD_DECLARE(void) gdImageSetPixel (gdImagePtr im, int x, int y, int color)
{
  int p;
  switch (color)
    {
    case gdStyled:
      if (!im->style)
	{
	  /* Refuse to draw if no style is set. */
	  return;
	}
      else
	{
	  p = im->style[im->stylePos++];
	}
      if (p != (gdTransparent))
	{
	  gdImageSetPixel (im, x, y, p);
	}
      im->stylePos = im->stylePos % im->styleLength;
      break;
    case gdStyledBrushed:
      if (!im->style)
	{
	  /* Refuse to draw if no style is set. */
	  return;
	}
      p = im->style[im->stylePos++];
      if ((p != gdTransparent) && (p != 0))
	{
	  gdImageSetPixel (im, x, y, gdBrushed);
	}
      im->stylePos = im->stylePos % im->styleLength;
      break;
    case gdBrushed:
      gdImageBrushApply (im, x, y);
      break;
    case gdTiled:
      gdImageTileApply (im, x, y);
      break;
    case gdAntiAliased:
      /* This shouldn't happen (2.0.26) because we just call
        gdImageAALine now, but do something sane. */
      gdImageSetPixel(im, x, y, im->AA_color);
      break;
    default:
      if (gdImageBoundsSafeMacro (im, x, y))
	{
	  if (im->trueColor)
	    {
	      if (im->alphaBlendingFlag)
		{
		  im->tpixels[y][x] = gdAlphaBlend (im->tpixels[y][x], color);
		}
	      else
		{
		  im->tpixels[y][x] = color;
		}
	    }
	  else
	    {
	      im->pixels[y][x] = color;
	    }
	}
      break;
    }
}

static void
gdImageBrushApply (gdImagePtr im, int x, int y)
{
  int lx, ly;
  int hy;
  int hx;
  int x1, y1, x2, y2;
  int srcx, srcy;
  if (!im->brush)
    {
      return;
    }
  hy = gdImageSY (im->brush) / 2;
  y1 = y - hy;
  y2 = y1 + gdImageSY (im->brush);
  hx = gdImageSX (im->brush) / 2;
  x1 = x - hx;
  x2 = x1 + gdImageSX (im->brush);
  srcy = 0;
  if (im->trueColor)
    {
      if (im->brush->trueColor)
	{
	  for (ly = y1; (ly < y2); ly++)
	    {
	      srcx = 0;
	      for (lx = x1; (lx < x2); lx++)
		{
		  int p;
		  p = gdImageGetTrueColorPixel (im->brush, srcx, srcy);
		  /* 2.0.9, Thomas Winzig: apply simple full transparency */
		  if (p != gdImageGetTransparent (im->brush))
		    {
		      gdImageSetPixel (im, lx, ly, p);
		    }
		  srcx++;
		}
	      srcy++;
	    }
	}
      else
	{
	  /* 2.0.12: Brush palette, image truecolor (thanks to Thorben Kundinger
	     for pointing out the issue) */
	  for (ly = y1; (ly < y2); ly++)
	    {
	      srcx = 0;
	      for (lx = x1; (lx < x2); lx++)
		{
		  int p, tc;
		  p = gdImageGetPixel (im->brush, srcx, srcy);
		  tc = gdImageGetTrueColorPixel (im->brush, srcx, srcy);
		  /* 2.0.9, Thomas Winzig: apply simple full transparency */
		  if (p != gdImageGetTransparent (im->brush))
		    {
		      gdImageSetPixel (im, lx, ly, tc);
		    }
		  srcx++;
		}
	      srcy++;
	    }
	}
    }
  else
    {
      for (ly = y1; (ly < y2); ly++)
	{
	  srcx = 0;
	  for (lx = x1; (lx < x2); lx++)
	    {
	      int p;
	      p = gdImageGetPixel (im->brush, srcx, srcy);
	      /* Allow for non-square brushes! */
	      if (p != gdImageGetTransparent (im->brush))
		{
		  /* Truecolor brush. Very slow
		     on a palette destination. */
		  if (im->brush->trueColor)
		    {
		      gdImageSetPixel (im, lx, ly,
				       gdImageColorResolveAlpha (im,
								 gdTrueColorGetRed
								 (p),
								 gdTrueColorGetGreen
								 (p),
								 gdTrueColorGetBlue
								 (p),
								 gdTrueColorGetAlpha
								 (p)));
		    }
		  else
		    {
		      gdImageSetPixel (im, lx, ly, im->brushColorMap[p]);
		    }
		}
	      srcx++;
	    }
	  srcy++;
	}
    }
}

static void
gdImageTileApply (gdImagePtr im, int x, int y)
{
  int srcx, srcy;
  int p;
  if (!im->tile)
    {
      return;
    }
  srcx = x % gdImageSX (im->tile);
  srcy = y % gdImageSY (im->tile);
  if (im->trueColor)
    {
      p = gdImageGetTrueColorPixel (im->tile, srcx, srcy);
			if (p != gdImageGetTransparent (im->tile)) {
	      gdImageSetPixel (im, x, y, p);
			}
    }
  else
    {
      p = gdImageGetPixel (im->tile, srcx, srcy);
      /* Allow for transparency */
      if (p != gdImageGetTransparent (im->tile))
	{
	  if (im->tile->trueColor)
	    {
	      /* Truecolor tile. Very slow
	         on a palette destination. */
	      gdImageSetPixel (im, x, y,
			       gdImageColorResolveAlpha (im,
							 gdTrueColorGetRed
							 (p),
							 gdTrueColorGetGreen
							 (p),
							 gdTrueColorGetBlue
							 (p),
							 gdTrueColorGetAlpha
							 (p)));
	    }
	  else
	    {
	      gdImageSetPixel (im, x, y, im->tileColorMap[p]);
	    }
	}
    }
}

BGD_DECLARE(int) gdImageGetPixel (gdImagePtr im, int x, int y)
{
  if (gdImageBoundsSafeMacro (im, x, y))
    {
      if (im->trueColor)
	{
	  return im->tpixels[y][x];
	}
      else
	{
	  return im->pixels[y][x];
	}
    }
  else
    {
      return 0;
    }
}

BGD_DECLARE(int) gdImageGetTrueColorPixel (gdImagePtr im, int x, int y)
{
  int p = gdImageGetPixel (im, x, y);
  if (!im->trueColor)
    {
      return gdTrueColorAlpha (im->red[p], im->green[p], im->blue[p],
			       (im->transparent == p) ? gdAlphaTransparent :
			       im->alpha[p]);
    }
  else
    {
      return p;
    }
}

BGD_DECLARE(void) gdImageAABlend (gdImagePtr im)
{
  /* NO-OP, kept for library compatibility. */
}

static void gdImageAALine (gdImagePtr im, int x1, int y1, int x2, int y2, int col);

static void gdImageHLine(gdImagePtr im, int y, int x1, int x2, int col)
{
	if (im->thick > 1) {
		int thickhalf = im->thick >> 1;
		gdImageFilledRectangle(im, x1, y - thickhalf, x2, y + im->thick - thickhalf - 1, col);
	} else {
		if (x2 < x1) {
			int t = x2;
			x2 = x1;
			x1 = t;
		}

		for (;x1 <= x2; x1++) {
			gdImageSetPixel(im, x1, y, col);
		}
	}
	return;
}

static void gdImageVLine(gdImagePtr im, int x, int y1, int y2, int col)
{
	if (im->thick > 1) {
		int thickhalf = im->thick >> 1;
		gdImageFilledRectangle(im, x - thickhalf, y1, x + im->thick - thickhalf - 1, y2, col);
	} else {
		if (y2 < y1) {
			int t = y1;
			y1 = y2;
			y2 = t;
		}

		for (;y1 <= y2; y1++) {
			gdImageSetPixel(im, x, y1, col);
		}
	}
	return;
}

/* Bresenham as presented in Foley & Van Dam */
BGD_DECLARE(void) gdImageLine (gdImagePtr im, int x1, int y1, int x2, int y2, int color)
{
  int dx, dy, incr1, incr2, d, x, y, xend, yend, xdirflag, ydirflag;
  int wid;
  int w, wstart;
  int thick;

  if (color == gdAntiAliased)
    {
      /* 
        gdAntiAliased passed as color: use the much faster, much cheaper
        and equally attractive gdImageAALine implementation. That
        clips too, so don't clip twice.
      */
      gdImageAALine(im, x1, y1, x2, y2, im->AA_color); 
      return;
    }
  /* 2.0.10: Nick Atty: clip to edges of drawing rectangle, return if no
     points need to be drawn. 2.0.26, TBB: clip to edges of clipping
     rectangle. We were getting away with this because gdImageSetPixel
     is used for actual drawing, but this is still more efficient and opens
     the way to skip per-pixel bounds checking in the future. */

  if (clip_1d (&x1, &y1, &x2, &y2, im->cx1, im->cx2) == 0)
    return;
  if (clip_1d (&y1, &x1, &y2, &x2, im->cy1, im->cy2) == 0)
    return;
  thick = im->thick;

  dx = abs (x2 - x1);
  dy = abs (y2 - y1);

	if (dx == 0) {
		gdImageVLine(im, x1, y1, y2, color);
		return;
	} else if (dy == 0) {
		gdImageHLine(im, y1, x1, x2, color);
		return;
	}

  if (dy <= dx)
    {
      /* More-or-less horizontal. use wid for vertical stroke */
      /* Doug Claar: watch out for NaN in atan2 (2.0.5) */
      if ((dx == 0) && (dy == 0))
	{
	  wid = 1;
	}
      else
	{
	  /* 2.0.12: Michael Schwartz: divide rather than multiply;
	     TBB: but watch out for /0! */
	  double ac = cos (atan2 (dy, dx));
	  if (ac != 0)
	    {
	      wid = thick / ac;
	    }
	  else
	    {
	      wid = 1;
	    }
	  if (wid == 0)
	    {
	      wid = 1;
	    }
	}
      d = 2 * dy - dx;
      incr1 = 2 * dy;
      incr2 = 2 * (dy - dx);
      if (x1 > x2)
	{
	  x = x2;
	  y = y2;
	  ydirflag = (-1);
	  xend = x1;
	}
      else
	{
	  x = x1;
	  y = y1;
	  ydirflag = 1;
	  xend = x2;
	}

      /* Set up line thickness */
      wstart = y - wid / 2;
      for (w = wstart; w < wstart + wid; w++)
	gdImageSetPixel (im, x, w, color);

      if (((y2 - y1) * ydirflag) > 0)
	{
	  while (x < xend)
	    {
	      x++;
	      if (d < 0)
		{
		  d += incr1;
		}
	      else
		{
		  y++;
		  d += incr2;
		}
	      wstart = y - wid / 2;
	      for (w = wstart; w < wstart + wid; w++)
		gdImageSetPixel (im, x, w, color);
	    }
	}
      else
	{
	  while (x < xend)
	    {
	      x++;
	      if (d < 0)
		{
		  d += incr1;
		}
	      else
		{
		  y--;
		  d += incr2;
		}
	      wstart = y - wid / 2;
	      for (w = wstart; w < wstart + wid; w++)
		gdImageSetPixel (im, x, w, color);
	    }
	}
    }
  else
    {
      /* More-or-less vertical. use wid for horizontal stroke */
      /* 2.0.12: Michael Schwartz: divide rather than multiply;
         TBB: but watch out for /0! */
      double as = sin (atan2 (dy, dx));
      if (as != 0)
	{
	  wid = thick / as;
	}
      else
	{
	  wid = 1;
	}
      if (wid == 0)
	wid = 1;

      d = 2 * dx - dy;
      incr1 = 2 * dx;
      incr2 = 2 * (dx - dy);
      if (y1 > y2)
	{
	  y = y2;
	  x = x2;
	  yend = y1;
	  xdirflag = (-1);
	}
      else
	{
	  y = y1;
	  x = x1;
	  yend = y2;
	  xdirflag = 1;
	}

      /* Set up line thickness */
      wstart = x - wid / 2;
      for (w = wstart; w < wstart + wid; w++)
	gdImageSetPixel (im, w, y, color);

      if (((x2 - x1) * xdirflag) > 0)
	{
	  while (y < yend)
	    {
	      y++;
	      if (d < 0)
		{
		  d += incr1;
		}
	      else
		{
		  x++;
		  d += incr2;
		}
	      wstart = x - wid / 2;
	      for (w = wstart; w < wstart + wid; w++)
		gdImageSetPixel (im, w, y, color);
	    }
	}
      else
	{
	  while (y < yend)
	    {
	      y++;
	      if (d < 0)
		{
		  d += incr1;
		}
	      else
		{
		  x--;
		  d += incr2;
		}
	      wstart = x - wid / 2;
	      for (w = wstart; w < wstart + wid; w++)
		gdImageSetPixel (im, w, y, color);
	    }
	}
    }

}
static void dashedSet (gdImagePtr im, int x, int y, int color,
		       int *onP, int *dashStepP, int wid, int vert);

BGD_DECLARE(void) gdImageDashedLine (gdImagePtr im, int x1, int y1, int x2, int y2, int color)
{
  int dx, dy, incr1, incr2, d, x, y, xend, yend, xdirflag, ydirflag;
  int dashStep = 0;
  int on = 1;
  int wid;
  int vert;
  int thick = im->thick;

  dx = abs (x2 - x1);
  dy = abs (y2 - y1);
  if (dy <= dx)
    {
      /* More-or-less horizontal. use wid for vertical stroke */
      /* 2.0.12: Michael Schwartz: divide rather than multiply;
         TBB: but watch out for /0! */
      double as = sin (atan2 (dy, dx));
      if (as != 0)
	{
	  wid = thick / as;
	}
      else
	{
	  wid = 1;
	}
      vert = 1;

      d = 2 * dy - dx;
      incr1 = 2 * dy;
      incr2 = 2 * (dy - dx);
      if (x1 > x2)
	{
	  x = x2;
	  y = y2;
	  ydirflag = (-1);
	  xend = x1;
	}
      else
	{
	  x = x1;
	  y = y1;
	  ydirflag = 1;
	  xend = x2;
	}
      dashedSet (im, x, y, color, &on, &dashStep, wid, vert);
      if (((y2 - y1) * ydirflag) > 0)
	{
	  while (x < xend)
	    {
	      x++;
	      if (d < 0)
		{
		  d += incr1;
		}
	      else
		{
		  y++;
		  d += incr2;
		}
	      dashedSet (im, x, y, color, &on, &dashStep, wid, vert);
	    }
	}
      else
	{
	  while (x < xend)
	    {
	      x++;
	      if (d < 0)
		{
		  d += incr1;
		}
	      else
		{
		  y--;
		  d += incr2;
		}
	      dashedSet (im, x, y, color, &on, &dashStep, wid, vert);
	    }
	}
    }
  else
    {
      /* 2.0.12: Michael Schwartz: divide rather than multiply;
         TBB: but watch out for /0! */
      double as = sin (atan2 (dy, dx));
      if (as != 0)
	{
	  wid = thick / as;
	}
      else
	{
	  wid = 1;
	}
      vert = 0;

      d = 2 * dx - dy;
      incr1 = 2 * dx;
      incr2 = 2 * (dx - dy);
      if (y1 > y2)
	{
	  y = y2;
	  x = x2;
	  yend = y1;
	  xdirflag = (-1);
	}
      else
	{
	  y = y1;
	  x = x1;
	  yend = y2;
	  xdirflag = 1;
	}
      dashedSet (im, x, y, color, &on, &dashStep, wid, vert);
      if (((x2 - x1) * xdirflag) > 0)
	{
	  while (y < yend)
	    {
	      y++;
	      if (d < 0)
		{
		  d += incr1;
		}
	      else
		{
		  x++;
		  d += incr2;
		}
	      dashedSet (im, x, y, color, &on, &dashStep, wid, vert);
	    }
	}
      else
	{
	  while (y < yend)
	    {
	      y++;
	      if (d < 0)
		{
		  d += incr1;
		}
	      else
		{
		  x--;
		  d += incr2;
		}
	      dashedSet (im, x, y, color, &on, &dashStep, wid, vert);
	    }
	}
    }
}

static void
dashedSet (gdImagePtr im, int x, int y, int color,
	   int *onP, int *dashStepP, int wid, int vert)
{
  int dashStep = *dashStepP;
  int on = *onP;
  int w, wstart;

  dashStep++;
  if (dashStep == gdDashSize)
    {
      dashStep = 0;
      on = !on;
    }
  if (on)
    {
      if (vert)
	{
	  wstart = y - wid / 2;
	  for (w = wstart; w < wstart + wid; w++)
	    gdImageSetPixel (im, x, w, color);
	}
      else
	{
	  wstart = x - wid / 2;
	  for (w = wstart; w < wstart + wid; w++)
	    gdImageSetPixel (im, w, y, color);
	}
    }
  *dashStepP = dashStep;
  *onP = on;
}

BGD_DECLARE(int) gdImageBoundsSafe (gdImagePtr im, int x, int y)
{
  return gdImageBoundsSafeMacro (im, x, y);
}

BGD_DECLARE(void) gdImageChar (gdImagePtr im, gdFontPtr f, int x, int y, int c, int color)
{
  int cx, cy;
  int px, py;
  int fline;
  cx = 0;
  cy = 0;
#ifdef CHARSET_EBCDIC
  c = ASC (c);
#endif /*CHARSET_EBCDIC */
  if ((c < f->offset) || (c >= (f->offset + f->nchars)))
    {
      return;
    }
  fline = (c - f->offset) * f->h * f->w;
  for (py = y; (py < (y + f->h)); py++)
    {
      for (px = x; (px < (x + f->w)); px++)
	{
	  if (f->data[fline + cy * f->w + cx])
	    {
	      gdImageSetPixel (im, px, py, color);
	    }
	  cx++;
	}
      cx = 0;
      cy++;
    }
}

BGD_DECLARE(void) gdImageCharUp (gdImagePtr im, gdFontPtr f, int x, int y, int c, int color)
{
  int cx, cy;
  int px, py;
  int fline;
  cx = 0;
  cy = 0;
#ifdef CHARSET_EBCDIC
  c = ASC (c);
#endif /*CHARSET_EBCDIC */
  if ((c < f->offset) || (c >= (f->offset + f->nchars)))
    {
      return;
    }
  fline = (c - f->offset) * f->h * f->w;
  for (py = y; (py > (y - f->w)); py--)
    {
      for (px = x; (px < (x + f->h)); px++)
	{
	  if (f->data[fline + cy * f->w + cx])
	    {
	      gdImageSetPixel (im, px, py, color);
	    }
	  cy++;
	}
      cy = 0;
      cx++;
    }
}

BGD_DECLARE(void) gdImageString (gdImagePtr im, gdFontPtr f,
	       int x, int y, unsigned char *s, int color)
{
  int i;
  int l;
  l = strlen ((char *) s);
  for (i = 0; (i < l); i++)
    {
      gdImageChar (im, f, x, y, s[i], color);
      x += f->w;
    }
}

BGD_DECLARE(void) gdImageStringUp (gdImagePtr im, gdFontPtr f,
		 int x, int y, unsigned char *s, int color)
{
  int i;
  int l;
  l = strlen ((char *) s);
  for (i = 0; (i < l); i++)
    {
      gdImageCharUp (im, f, x, y, s[i], color);
      y -= f->w;
    }
}

static int strlen16 (unsigned short *s);

BGD_DECLARE(void) gdImageString16 (gdImagePtr im, gdFontPtr f,
		 int x, int y, unsigned short *s, int color)
{
  int i;
  int l;
  l = strlen16 (s);
  for (i = 0; (i < l); i++)
    {
      gdImageChar (im, f, x, y, s[i], color);
      x += f->w;
    }
}

BGD_DECLARE(void) gdImageStringUp16 (gdImagePtr im, gdFontPtr f,
		   int x, int y, unsigned short *s, int color)
{
  int i;
  int l;
  l = strlen16 (s);
  for (i = 0; (i < l); i++)
    {
      gdImageCharUp (im, f, x, y, s[i], color);
      y -= f->w;
    }
}

static int
strlen16 (unsigned short *s)
{
  int len = 0;
  while (*s)
    {
      s++;
      len++;
    }
  return len;
}

#ifndef HAVE_LSQRT
/* If you don't have a nice square root function for longs, you can use
   ** this hack
 */
long
lsqrt (long n)
{
  long result = (long) sqrt ((double) n);
  return result;
}
#endif

/* s and e are integers modulo 360 (degrees), with 0 degrees
   being the rightmost extreme and degrees changing clockwise.
   cx and cy are the center in pixels; w and h are the horizontal 
   and vertical diameter in pixels. Nice interface, but slow.
   See gd_arc_f_buggy.c for a better version that doesn't 
   seem to be bug-free yet. */

BGD_DECLARE(void) gdImageArc (gdImagePtr im, int cx, int cy, int w, int h, int s, int e,
	    int color)
{
  gdImageFilledArc (im, cx, cy, w, h, s, e, color, gdNoFill);
}

BGD_DECLARE(void) gdImageFilledArc (gdImagePtr im, int cx, int cy, int w, int h, int s, int e,
		  int color, int style)
{
  gdPoint pts[3];
  int i;
  int lx = 0, ly = 0;
  int fx = 0, fy = 0;

  if ((s % 360)  == (e % 360)) {
	  s = 0; e = 360;
  } else {
	  if (s > 360) {
		  s = s % 360;
	  }

	  if (e > 360) {
		  e = e % 360;
	  }

	  while (s < 0) {
		  s += 360;
	  }

	  while (e < s) {
		  e += 360;
	  }

	  if (s == e) {
		  s = 0; e = 360;
	  }
  }

  for (i = s; (i <= e); i++)
    {
      int x, y;
      x = ((long) gdCosT[i % 360] * (long) w / (2 * 1024)) + cx;
      y = ((long) gdSinT[i % 360] * (long) h / (2 * 1024)) + cy;
      if (i != s)
	{
	  if (!(style & gdChord))
	    {
		if (style & gdNoFill)
		{
		  gdImageLine (im, lx, ly, x, y, color);
		}
	      else
		{
		  /* This is expensive! */
		  pts[0].x = lx;
		  pts[0].y = ly;
		  pts[1].x = x;
		  pts[1].y = y;
		  pts[2].x = cx;
		  pts[2].y = cy;
		  gdImageFilledPolygon (im, pts, 3, color);
		}
	    }
	}
      else
	{
	  fx = x;
	  fy = y;
	}
      lx = x;
      ly = y;
    }
  if (style & gdChord)
    {
      if (style & gdNoFill)
	{
	  if (style & gdEdged)
	    {
	      gdImageLine (im, cx, cy, lx, ly, color);
	      gdImageLine (im, cx, cy, fx, fy, color);
	    }
	  gdImageLine (im, fx, fy, lx, ly, color);
	}
      else
	{
	  pts[0].x = fx;
	  pts[0].y = fy;
	  pts[1].x = lx;
	  pts[1].y = ly;
	  pts[2].x = cx;
	  pts[2].y = cy;
	  gdImageFilledPolygon (im, pts, 3, color);
	}
    }
  else
    {
      if (style & gdNoFill)
	{
	  if (style & gdEdged)
	    {
	      gdImageLine (im, cx, cy, lx, ly, color);
	      gdImageLine (im, cx, cy, fx, fy, color);
	    }
	}
    }
}

BGD_DECLARE(void) gdImageFilledEllipse (gdImagePtr im, int mx, int my, int w, int h, int c)
{
	int x=0,mx1=0,mx2=0,my1=0,my2=0;
	long aq,bq,dx,dy,r,rx,ry,a,b;
	int i;
	int old_y1,old_y2;

	a=w>>1;
	b=h>>1;

	gdImageLine(im, mx-a, my, mx+a, my, c);

	mx1 = mx-a;my1 = my;
	mx2 = mx+a;my2 = my;

	aq = a * a;
	bq = b * b;
	dx = aq << 1;
	dy = bq << 1;
	r  = a * bq;
	rx = r << 1;
	ry = 0;
	x = a;
	old_y2=-2;
	old_y1=-2;
	while (x > 0){
		if (r > 0) {
			my1++;my2--;
			ry +=dx;
			r  -=ry;
		}
		if (r <= 0){
			x--;
			mx1++;mx2--;
			rx -=dy;
			r  +=rx;
		}
		if(old_y2!=my2){
			for(i=mx1;i<=mx2;i++){
				gdImageSetPixel(im,i,my1,c);
			}
		}
		if(old_y2!=my2){
			for(i=mx1;i<=mx2;i++){
				gdImageSetPixel(im,i,my2,c);
			}
		}
		old_y2 = my2;
		old_y1 = my1;
	}
}

BGD_DECLARE(void) gdImageFillToBorder (gdImagePtr im, int x, int y, int border, int color)
{
  int lastBorder;
  /* Seek left */
  int leftLimit, rightLimit;
  int i;
	int restoreAlphaBleding;

  if (border < 0)
    {
      /* Refuse to fill to a non-solid border */
      return;
    }

	leftLimit = (-1);

	restoreAlphaBleding = im->alphaBlendingFlag;
	im->alphaBlendingFlag = 0;

  for (i = x; (i >= 0); i--)
    {
      if (gdImageGetPixel (im, i, y) == border)
	{
	  break;
	}
      gdImageSetPixel (im, i, y, color);
      leftLimit = i;
    }
  if (leftLimit == (-1))
    {
			im->alphaBlendingFlag = restoreAlphaBleding;
      return;
    }
  /* Seek right */
  rightLimit = x;
  for (i = (x + 1); (i < im->sx); i++)
    {
      if (gdImageGetPixel (im, i, y) == border)
	{
	  break;
	}
      gdImageSetPixel (im, i, y, color);
      rightLimit = i;
    }
  /* Look at lines above and below and start paints */
  /* Above */
  if (y > 0)
    {
      lastBorder = 1;
      for (i = leftLimit; (i <= rightLimit); i++)
	{
	  int c;
	  c = gdImageGetPixel (im, i, y - 1);
	  if (lastBorder)
	    {
	      if ((c != border) && (c != color))
		{
		  gdImageFillToBorder (im, i, y - 1, border, color);
		  lastBorder = 0;
		}
	    }
	  else if ((c == border) || (c == color))
	    {
	      lastBorder = 1;
	    }
	}
    }
  /* Below */
  if (y < ((im->sy) - 1))
    {
      lastBorder = 1;
      for (i = leftLimit; (i <= rightLimit); i++)
	{
	  int c = gdImageGetPixel (im, i, y + 1);
	  if (lastBorder)
	    {
	      if ((c != border) && (c != color))
		{
		  gdImageFillToBorder (im, i, y + 1, border, color);
		  lastBorder = 0;
		}
	    }
	  else if ((c == border) || (c == color))
	    {
	      lastBorder = 1;
	    }
	}
    }
	im->alphaBlendingFlag = restoreAlphaBleding;
}

/*
 * set the pixel at (x,y) and its 4-connected neighbors
 * with the same pixel value to the new pixel value nc (new color).
 * A 4-connected neighbor:  pixel above, below, left, or right of a pixel.
 * ideas from comp.graphics discussions.
 * For tiled fill, the use of a flag buffer is mandatory. As the tile image can
 * contain the same color as the color to fill. To do not bloat normal filling
 * code I added a 2nd private function.
 */

static int gdImageTileGet (gdImagePtr im, int x, int y)
{
	int srcx, srcy;
	int tileColor,p;
	if (!im->tile) {
		return -1;
	}
	srcx = x % gdImageSX(im->tile);
	srcy = y % gdImageSY(im->tile);
	p = gdImageGetPixel(im->tile, srcx, srcy);
	if (p == im->tile->transparent) {
		tileColor = im->transparent;
	} else if (im->trueColor) {
		if (im->tile->trueColor) {
			tileColor = p;
		} else {
			tileColor = gdTrueColorAlpha( gdImageRed(im->tile,p), gdImageGreen(im->tile,p), gdImageBlue (im->tile,p), gdImageAlpha (im->tile,p));
		}
	} else {
		if (im->tile->trueColor) {
			tileColor = gdImageColorResolveAlpha(im, gdTrueColorGetRed (p), gdTrueColorGetGreen (p), gdTrueColorGetBlue (p), gdTrueColorGetAlpha (p));
		} else {
			tileColor = p;
			tileColor = gdImageColorResolveAlpha(im, gdImageRed (im->tile,p), gdImageGreen (im->tile,p), gdImageBlue (im->tile,p), gdImageAlpha (im->tile,p));
		}
	}
	return tileColor;
}



/* horizontal segment of scan line y */
struct seg {int y, xl, xr, dy;};

/* max depth of stack */
#define FILL_MAX 1200000
#define FILL_PUSH(Y, XL, XR, DY) \
    if (sp<stack+FILL_MAX*10 && Y+(DY)>=0 && Y+(DY)<wy2) \
    {sp->y = Y; sp->xl = XL; sp->xr = XR; sp->dy = DY; sp++;}

#define FILL_POP(Y, XL, XR, DY) \
    {sp--; Y = sp->y+(DY = sp->dy); XL = sp->xl; XR = sp->xr;}

void _gdImageFillTiled(gdImagePtr im, int x, int y, int nc);
BGD_DECLARE(void) gdImageFill(gdImagePtr im, int x, int y, int nc)
{
	int l, x1, x2, dy;
	int oc;   /* old pixel value */
	int wx2,wy2;

	int alphablending_bak;

	/* stack of filled segments */
	/* struct seg stack[FILL_MAX],*sp = stack;; */
	struct seg *stack;
	struct seg *sp;

	if (!im->trueColor && nc > (im->colorsTotal - 1)) {
		return;
	}

	alphablending_bak = im->alphaBlendingFlag;	
	im->alphaBlendingFlag = 0;

	if (nc==gdTiled) {
		_gdImageFillTiled(im,x,y,nc);
		im->alphaBlendingFlag = alphablending_bak;
		return;
	}

	wx2=im->sx;wy2=im->sy;
	oc = gdImageGetPixel(im, x, y);
	if (oc==nc || x<0 || x>wx2 || y<0 || y>wy2) {
		im->alphaBlendingFlag = alphablending_bak;	
		return;
	}

	/* Do not use the 4 neighbors implementation with
   * small images
   */
	if (im->sx < 4) {
		int ix = x, iy = y, c;
		do {
			c = gdImageGetPixel(im, ix, iy);
			if (c != oc) {
				goto done;
			}
			gdImageSetPixel(im, ix, iy, nc);
		} while(ix++ < (im->sx -1));
		ix = x; iy = y + 1;
		do {
			c = gdImageGetPixel(im, ix, iy);
			if (c != oc) {
				goto done;
			}
			gdImageSetPixel(im, ix, iy, nc);
		} while(ix++ < (im->sx -1));
		goto done;
	}

	stack = (struct seg *)gdMalloc(sizeof(struct seg) * ((int)(im->sy*im->sx)/4));
	if (!stack) {
		return;
	}
	sp = stack;

	/* required! */
	FILL_PUSH(y,x,x,1);
	/* seed segment (popped 1st) */
 	FILL_PUSH(y+1, x, x, -1);
	while (sp>stack) {
		FILL_POP(y, x1, x2, dy);

		for (x=x1; x>=0 && gdImageGetPixel(im,x, y)==oc; x--) {
			gdImageSetPixel(im,x, y, nc);
		}
		if (x>=x1) {
			goto skip;
		}
		l = x+1;

                /* leak on left? */
		if (l<x1) {
			FILL_PUSH(y, l, x1-1, -dy);
		}
		x = x1+1;
		do {
			for (; x<=wx2 && gdImageGetPixel(im,x, y)==oc; x++) {
				gdImageSetPixel(im, x, y, nc);
			}
			FILL_PUSH(y, l, x-1, dy);
			/* leak on right? */
			if (x>x2+1) {
				FILL_PUSH(y, x2+1, x-1, -dy);
			}
skip:			for (x++; x<=x2 && (gdImageGetPixel(im, x, y)!=oc); x++);

			l = x;
		} while (x<=x2);
	}

	gdFree(stack);

done:
	im->alphaBlendingFlag = alphablending_bak;	
}

void _gdImageFillTiled(gdImagePtr im, int x, int y, int nc)
{
	int i,l, x1, x2, dy;
	int oc;   /* old pixel value */
	int tiled;
	int wx2,wy2;
	/* stack of filled segments */
	struct seg *stack;
	struct seg *sp;

	int **pts;
	if(!im->tile){
		return;
	}

	wx2=im->sx;wy2=im->sy;
	tiled = nc==gdTiled;

	nc =  gdImageTileGet(im,x,y);
	pts = (int **) gdCalloc(sizeof(int *) * im->sy, sizeof(int));
	if (!pts) {
		return;
	}

	for (i=0; i<im->sy;i++) {
		pts[i] = (int *) gdCalloc(im->sx, sizeof(int));

		if (!pts[i]) {
			for (--i ; i >= 0; i--) {
				gdFree(pts[i]);
			}
			return;
		}
	}

	stack = (struct seg *)gdMalloc(sizeof(struct seg) * ((int)(im->sy*im->sx)/4));
	if (!stack) {
		return;
	}
	sp = stack;

	oc = gdImageGetPixel(im, x, y);

	/* required! */
	FILL_PUSH(y,x,x,1);
	/* seed segment (popped 1st) */
 	FILL_PUSH(y+1, x, x, -1);
	while (sp>stack) {
		FILL_POP(y, x1, x2, dy);
		for (x=x1; x>=0 && (!pts[y][x] && gdImageGetPixel(im,x,y)==oc); x--) {
			if (pts[y][x]){
				/* we should never be here */
				break;
			}
			nc = gdImageTileGet(im,x,y);
			pts[y][x]=1;
			gdImageSetPixel(im,x, y, nc);
		}
		if (x>=x1) {
			goto skip;
		}
		l = x+1;

		/* leak on left? */
		if (l<x1) {
			FILL_PUSH(y, l, x1-1, -dy);
		}
		x = x1+1;
		do {
			for (; x<wx2 && (!pts[y][x] && gdImageGetPixel(im,x, y)==oc) ; x++) {
				if (pts[y][x]){
					/* we should never be here */
					break;
				}
				nc = gdImageTileGet(im,x,y);
				pts[y][x]=1;
				gdImageSetPixel(im, x, y, nc);
			}
			FILL_PUSH(y, l, x-1, dy);
			/* leak on right? */
			if (x>x2+1) {
				FILL_PUSH(y, x2+1, x-1, -dy);
			}
skip:			for (x++; x<=x2 && (pts[y][x] || gdImageGetPixel(im,x, y)!=oc); x++);
			l = x;
		} while (x<=x2);
	}
	for (i=0; i<im->sy;i++) {
		gdFree(pts[i]);
	}
	gdFree(pts);
	gdFree(stack);
}

BGD_DECLARE(void) gdImageRectangle (gdImagePtr im, int x1, int y1, int x2, int y2, int color)
{
	int x1h = x1, x1v = x1, y1h = y1, y1v = y1, x2h = x2, x2v = x2, y2h = y2, y2v = y2;
	int thick = im->thick;
	int half1 = 1;
	int t;

	if (y2 < y1) {
		t=y1;
		y1 = y2;
		y2 = t;

		t = x1;
		x1 = x2;
		x2 = t;
	}

	x1h = x1; x1v = x1; y1h = y1; y1v = y1; x2h = x2; x2v = x2; y2h = y2; y2v = y2;
	if (thick > 1) {
		int cx, cy, x1ul, y1ul, x2lr, y2lr;
		int half = thick >> 1;
		half1 = thick - half;
		x1ul = x1 - half;
		y1ul = y1 - half;
		
		x2lr = x2 + half;
		y2lr = y2 + half;

		cy = y1ul + thick;
		while (cy-- > y1ul) {
			cx = x1ul - 1;
			while (cx++ < x2lr) {
				gdImageSetPixel(im, cx, cy, color);
			}
		}

		cy = y2lr - thick;
		while (cy++ < y2lr) {
			cx = x1ul - 1;
			while (cx++ < x2lr) {
				gdImageSetPixel(im, cx, cy, color);
			}
		}

		cy = y1ul + thick - 1;
		while (cy++ < y2lr -thick) {
			cx = x1ul - 1;
			while (cx++ < x1ul + thick) {
				gdImageSetPixel(im, cx, cy, color);
			}
		}

		cy = y1ul + thick - 1;
		while (cy++ < y2lr -thick) {
			cx = x2lr - thick - 1;
			while (cx++ < x2lr) {
				gdImageSetPixel(im, cx, cy, color);
			}
		}

		return;
	} else {
		y1v = y1h + 1;
		y2v = y2h - 1;
		gdImageLine(im, x1h, y1h, x2h, y1h, color);
		gdImageLine(im, x1h, y2h, x2h, y2h, color);
		gdImageLine(im, x1v, y1v, x1v, y2v, color);
		gdImageLine(im, x2v, y1v, x2v, y2v, color);
	}
}

BGD_DECLARE(void) gdImageFilledRectangle (gdImagePtr im, int x1, int y1, int x2, int y2,
			int color)
{
  int x, y;
  /* Nick Atty: limit the points at the edge.  Note that this also
     nicely kills any plotting for rectangles completely outside the
     window as it makes the tests in the for loops fail */
  if (x1 < 0)
	  x1 = 0;
  if (x1 > gdImageSX (im))
	  x1 = gdImageSX (im);
  if (y1 < 0)
	  y1 = 0;
  if (y1 > gdImageSY (im))
	  y1 = gdImageSY (im);

  if (x1 > x2) {
	  x = x1;
	  x1 = x2;
	  x2 = x;
  }
  if (y1 > y2) {
	  y = y1;
	  y1 = y2;
	  y2 = y;
  }

  for (y = y1; (y <= y2); y++)
    {
      for (x = x1; (x <= x2); x++)
	{
	  gdImageSetPixel (im, x, y, color);
	}
    }
}

BGD_DECLARE(void) gdImageCopy (gdImagePtr dst, gdImagePtr src, int dstX, int dstY, int srcX,
	     int srcY, int w, int h)
{
  int c;
  int x, y;
  int tox, toy;
  int i;
  int colorMap[gdMaxColors];

  if (dst->trueColor) {
	  /* 2.0: much easier when the destination is truecolor. */
	  /* 2.0.10: needs a transparent-index check that is still valid if
	   *          * the source is not truecolor. Thanks to Frank Warmerdam.
	   */

	  if (src->trueColor) {
		  for (y = 0; (y < h); y++) {
			  for (x = 0; (x < w); x++) {
				  int c = gdImageGetTrueColorPixel (src, srcX + x, srcY + y);
				  gdImageSetPixel (dst, dstX + x, dstY + y, c);
			  }
		  }
	  } else {
		  /* source is palette based */
		  for (y = 0; (y < h); y++) {
			  for (x = 0; (x < w); x++) {
				  int c = gdImageGetPixel (src, srcX + x, srcY + y);
				  if (c != src->transparent) {
					  gdImageSetPixel(dst, dstX + x, dstY + y, gdTrueColorAlpha(src->red[c], src->green[c], src->blue[c], src->alpha[c]));
				  }
			  }
		  }
	  }
	  return;
  }

  for (i = 0; (i < gdMaxColors); i++)
  {
	  colorMap[i] = (-1);
  }
  toy = dstY;
  for (y = srcY; (y < (srcY + h)); y++)
  {
	  tox = dstX;
	  for (x = srcX; (x < (srcX + w)); x++)
	  {
		  int nc;
		  int mapTo;
		  c = gdImageGetPixel (src, x, y);
		  /* Added 7/24/95: support transparent copies */
		  if (gdImageGetTransparent (src) == c)
		  {
			  tox++;
			  continue;
		  }
		  /* Have we established a mapping for this color? */
		  if (src->trueColor)
		  {
			  /* 2.05: remap to the palette available in the
				 destination image. This is slow and
				 works badly, but it beats crashing! Thanks 
				 to Padhrig McCarthy. */
	      mapTo = gdImageColorResolveAlpha (dst,
						gdTrueColorGetRed (c),
						gdTrueColorGetGreen (c),
						gdTrueColorGetBlue (c),
						gdTrueColorGetAlpha (c));
	    }
	  else if (colorMap[c] == (-1))
	    {
	      /* If it's the same image, mapping is trivial */
	      if (dst == src)
		{
		  nc = c;
		}
	      else
		{
		  /* Get best match possible. This
		     function never returns error. */
		  nc = gdImageColorResolveAlpha (dst,
						 src->red[c], src->green[c],
						 src->blue[c], src->alpha[c]);
		}
	      colorMap[c] = nc;
	      mapTo = colorMap[c];
	    }
	  else
	    {
	      mapTo = colorMap[c];
	    }
	  gdImageSetPixel (dst, tox, toy, mapTo);
	  tox++;
	}
      toy++;
    }
}

/* This function is a substitute for real alpha channel operations,
   so it doesn't pay attention to the alpha channel. */
BGD_DECLARE(void) gdImageCopyMerge (gdImagePtr dst, gdImagePtr src, int dstX, int dstY,
		  int srcX, int srcY, int w, int h, int pct)
{

  int c, dc;
  int x, y;
  int tox, toy;
  int ncR, ncG, ncB;
  toy = dstY;
  for (y = srcY; (y < (srcY + h)); y++)
    {
      tox = dstX;
      for (x = srcX; (x < (srcX + w)); x++)
	{
	  int nc;
	  c = gdImageGetPixel (src, x, y);
	  /* Added 7/24/95: support transparent copies */
	  if (gdImageGetTransparent (src) == c)
	    {
	      tox++;
	      continue;
	    }
	  /* If it's the same image, mapping is trivial */
	  if (dst == src)
	    {
	      nc = c;
	    }
	  else
	    {
	      dc = gdImageGetPixel (dst, tox, toy);

	      ncR = gdImageRed (src, c) * (pct / 100.0)
		+ gdImageRed (dst, dc) * ((100 - pct) / 100.0);
	      ncG = gdImageGreen (src, c) * (pct / 100.0)
		+ gdImageGreen (dst, dc) * ((100 - pct) / 100.0);
	      ncB = gdImageBlue (src, c) * (pct / 100.0)
		+ gdImageBlue (dst, dc) * ((100 - pct) / 100.0);

	      /* Find a reasonable color */
	      nc = gdImageColorResolve (dst, ncR, ncG, ncB);
	    }
	  gdImageSetPixel (dst, tox, toy, nc);
	  tox++;
	}
      toy++;
    }
}

/* This function is a substitute for real alpha channel operations,
   so it doesn't pay attention to the alpha channel. */
BGD_DECLARE(void) gdImageCopyMergeGray (gdImagePtr dst, gdImagePtr src, int dstX, int dstY,
		      int srcX, int srcY, int w, int h, int pct)
{

  int c, dc;
  int x, y;
  int tox, toy;
  int ncR, ncG, ncB;
  float g;
  toy = dstY;
  for (y = srcY; (y < (srcY + h)); y++)
    {
      tox = dstX;
      for (x = srcX; (x < (srcX + w)); x++)
	{
	  int nc;
	  c = gdImageGetPixel (src, x, y);
	  /* Added 7/24/95: support transparent copies */
	  if (gdImageGetTransparent (src) == c)
	    {
	      tox++;
	      continue;
	    }
	  /* 
	   * If it's the same image, mapping is NOT trivial since we 
	   * merge with greyscale target, but if pct is 100, the grey 
	   * value is not used, so it becomes trivial. pjw 2.0.12. 
	   */
	  if (dst == src && pct == 100)
	    {
	      nc = c;
	    }
	  else
	    {
	      dc = gdImageGetPixel (dst, tox, toy);
	      g = 0.29900 * gdImageRed(dst, dc)
		+ 0.58700 * gdImageGreen(dst, dc) + 0.11400 * gdImageBlue(dst, dc);

	      ncR = gdImageRed (src, c) * (pct / 100.0)
		+ g * ((100 - pct) / 100.0);
	      ncG = gdImageGreen (src, c) * (pct / 100.0)
		+ g * ((100 - pct) / 100.0);
	      ncB = gdImageBlue (src, c) * (pct / 100.0)
		+ g * ((100 - pct) / 100.0);

	      /* First look for an exact match */
	      nc = gdImageColorExact (dst, ncR, ncG, ncB);
	      if (nc == (-1))
		{
		  /* No, so try to allocate it */
		  nc = gdImageColorAllocate (dst, ncR, ncG, ncB);
		  /* If we're out of colors, go for the
		     closest color */
		  if (nc == (-1))
		    {
		      nc = gdImageColorClosest (dst, ncR, ncG, ncB);
		    }
		}
	    }
	  gdImageSetPixel (dst, tox, toy, nc);
	  tox++;
	}
      toy++;
    }
}

BGD_DECLARE(void) gdImageCopyResized (gdImagePtr dst, gdImagePtr src, int dstX, int dstY,
		    int srcX, int srcY, int dstW, int dstH, int srcW,
		    int srcH)
{
  int c;
  int x, y;
  int tox, toy;
  int ydest;
  int i;
  int colorMap[gdMaxColors];
  /* Stretch vectors */
  int *stx;
  int *sty;
  /* We only need to use floating point to determine the correct
     stretch vector for one line's worth. */
  if (overflow2(sizeof (int), srcW)) {
    return;
  }
  if (overflow2(sizeof (int), srcH)) {
    return;
  }
  stx = (int *) gdMalloc (sizeof (int) * srcW);
	if (!stx) {
		return;
	}

  sty = (int *) gdMalloc (sizeof (int) * srcH);
	if (!sty) {
		return;
	}

  /* Fixed by Mao Morimoto 2.0.16 */
  for (i = 0; (i < srcW); i++)
    {
      stx[i] = dstW * (i + 1) / srcW - dstW * i / srcW;
    }
  for (i = 0; (i < srcH); i++)
    {
      sty[i] = dstH * (i + 1) / srcH - dstH * i / srcH;
    }
  for (i = 0; (i < gdMaxColors); i++)
    {
      colorMap[i] = (-1);
    }
  toy = dstY;
  for (y = srcY; (y < (srcY + srcH)); y++)
    {
      for (ydest = 0; (ydest < sty[y - srcY]); ydest++)
	{
	  tox = dstX;
	  for (x = srcX; (x < (srcX + srcW)); x++)
	    {
	      int nc = 0;
	      int mapTo;
	      if (!stx[x - srcX])
		{
		  continue;
		}
	      if (dst->trueColor)
		{
		  /* 2.0.9: Thorben Kundinger: Maybe the source image is not 
		     a truecolor image */
		  if (!src->trueColor)
		    {
		      int tmp = gdImageGetPixel (src, x, y);
		      mapTo = gdImageGetTrueColorPixel (src, x, y);
		      if (gdImageGetTransparent (src) == tmp)
			{
			  /* 2.0.21, TK: not tox++ */
			  tox += stx[x - srcX];
			  continue;
			}
		    }
		  else
		    {
		      /* TK: old code follows */
		      mapTo = gdImageGetTrueColorPixel (src, x, y);
		      /* Added 7/24/95: support transparent copies */
		      if (gdImageGetTransparent (src) == mapTo)
			{
			  /* 2.0.21, TK: not tox++ */
			  tox += stx[x - srcX];
			  continue;
			}
		    }
		}
	      else
		{
		  c = gdImageGetPixel (src, x, y);
		  /* Added 7/24/95: support transparent copies */
		  if (gdImageGetTransparent (src) == c)
		    {
		      tox += stx[x - srcX];
		      continue;
		    }
		  if (src->trueColor)
		    {
		      /* Remap to the palette available in the
		         destination image. This is slow and
		         works badly. */
		      mapTo = gdImageColorResolveAlpha (dst,
							gdTrueColorGetRed (c),
							gdTrueColorGetGreen
							(c),
							gdTrueColorGetBlue
							(c),
							gdTrueColorGetAlpha
							(c));
		    }
		  else
		    {
		      /* Have we established a mapping for this color? */
		      if (colorMap[c] == (-1))
			{
			  /* If it's the same image, mapping is trivial */
			  if (dst == src)
			    {
			      nc = c;
			    }
			  else
			    {
			      /* Find or create the best match */
			      /* 2.0.5: can't use gdTrueColorGetRed, etc with palette */
			      nc = gdImageColorResolveAlpha (dst,
							     gdImageRed (src,
									 c),
							     gdImageGreen
							     (src, c),
							     gdImageBlue (src,
									  c),
							     gdImageAlpha
							     (src, c));
			    }
			  colorMap[c] = nc;
			}
		      mapTo = colorMap[c];
		    }
		}
	      for (i = 0; (i < stx[x - srcX]); i++)
		{
		  gdImageSetPixel (dst, tox, toy, mapTo);
		  tox++;
		}
	    }
	  toy++;
	}
    }
  gdFree (stx);
  gdFree (sty);
}

/* gd 2.0.8: gdImageCopyRotated is added. Source 
	is a rectangle, with its upper left corner at
	srcX and srcY. Destination is the *center* of
        the rotated copy. Angle is in degrees, same as
        gdImageArc. Floating point destination center
	coordinates allow accurate rotation of 
	objects of odd-numbered width or height. */

BGD_DECLARE(void) gdImageCopyRotated (gdImagePtr dst,
		    gdImagePtr src,
		    double dstX, double dstY,
		    int srcX, int srcY,
		    int srcWidth, int srcHeight, int angle)
{
  double dx, dy;
  double radius = sqrt (srcWidth * srcWidth + srcHeight * srcHeight);
  double aCos = cos (angle * .0174532925);
  double aSin = sin (angle * .0174532925);
  double scX = srcX + ((double) srcWidth) / 2;
  double scY = srcY + ((double) srcHeight) / 2;
  int cmap[gdMaxColors];
  int i;

	/* 
		 2.0.34: transparency preservation. The transparentness of
		 the transparent color is more important than its hue.
	*/
	if (src->transparent != -1) {
		if (dst->transparent == -1) {
			dst->transparent = src->transparent;
		}
	}

  for (i = 0; (i < gdMaxColors); i++)
    {
      cmap[i] = (-1);
    }
  for (dy = dstY - radius; (dy <= dstY + radius); dy++)
    {
      for (dx = dstX - radius; (dx <= dstX + radius); dx++)
	{
	  double sxd = (dx - dstX) * aCos - (dy - dstY) * aSin;
	  double syd = (dy - dstY) * aCos + (dx - dstX) * aSin;
	  int sx = sxd + scX;
	  int sy = syd + scY;
	  if ((sx >= srcX) && (sx < srcX + srcWidth) &&
	      (sy >= srcY) && (sy < srcY + srcHeight))
	    {
				int c = gdImageGetPixel (src, sx, sy);
				/* 2.0.34: transparency wins */
				if (c == src->transparent) 
				{
					gdImageSetPixel (dst, dx, dy, dst->transparent);
				}  
					else if (!src->trueColor)
				{
		  /* Use a table to avoid an expensive
		     lookup on every single pixel */
		  if (cmap[c] == -1)
		    {
		      cmap[c] = gdImageColorResolveAlpha (dst,
							  gdImageRed (src, c),
							  gdImageGreen (src,
									c),
							  gdImageBlue (src,
								       c),
							  gdImageAlpha (src,
									c));
		    }
		  gdImageSetPixel (dst, dx, dy, cmap[c]);
		}
	      else
		{
		  gdImageSetPixel (dst,
				   dx, dy,
				   gdImageColorResolveAlpha (dst,
							     gdImageRed (src,
									 c),
							     gdImageGreen
							     (src, c),
							     gdImageBlue (src,
									  c),
							     gdImageAlpha
							     (src, c)));
		}
	    }
	}
    }
}

/* When gd 1.x was first created, floating point was to be avoided.
   These days it is often faster than table lookups or integer
   arithmetic. The routine below is shamelessly, gloriously
   floating point. TBB */

/* 2.0.10: cast instead of floor() yields 35% performance improvement. 
	Thanks to John Buckman. */

#define floor2(exp) ((long) exp)
/*#define floor2(exp) floor(exp)*/

BGD_DECLARE(void) gdImageCopyResampled (gdImagePtr dst,
		      gdImagePtr src,
		      int dstX, int dstY,
		      int srcX, int srcY,
		      int dstW, int dstH, int srcW, int srcH)
{
  int x, y;
  double sy1, sy2, sx1, sx2;
  if (!dst->trueColor)
    {
      gdImageCopyResized (dst, src, dstX, dstY, srcX, srcY, dstW, dstH,
			  srcW, srcH);
      return;
    }
  for (y = dstY; (y < dstY + dstH); y++)
    {
      sy1 = ((double) y - (double) dstY) * (double) srcH / (double) dstH;
      sy2 = ((double) (y + 1) - (double) dstY) * (double) srcH /
	(double) dstH;
      for (x = dstX; (x < dstX + dstW); x++)
	{
	  double sx, sy;
	  double spixels = 0;
	  double red = 0.0, green = 0.0, blue = 0.0, alpha = 0.0;
	  sx1 = ((double) x - (double) dstX) * (double) srcW / dstW;
	  sx2 = ((double) (x + 1) - (double) dstX) * (double) srcW / dstW;
	  sy = sy1;
	  do
	    {
	      double yportion;
	      if (floor2 (sy) == floor2 (sy1))
		{
		  yportion = 1.0 - (sy - floor2 (sy));
		  if (yportion > sy2 - sy1)
		    {
		      yportion = sy2 - sy1;
		    }
		  sy = floor2 (sy);
		}
	      else if (sy == floor2 (sy2))
		{
		  yportion = sy2 - floor2 (sy2);
		}
	      else
		{
		  yportion = 1.0;
		}
	      sx = sx1;
	      do
		{
		  double xportion;
		  double pcontribution;
		  int p;
		  if (floor2 (sx) == floor2 (sx1))
		    {
		      xportion = 1.0 - (sx - floor2 (sx));
		      if (xportion > sx2 - sx1)
			{
			  xportion = sx2 - sx1;
			}
		      sx = floor2 (sx);
		    }
		  else if (sx == floor2 (sx2))
		    {
		      xportion = sx2 - floor2 (sx2);
		    }
		  else
		    {
		      xportion = 1.0;
		    }
		  pcontribution = xportion * yportion;
		  /* 2.08: previously srcX and srcY were ignored. 
		     Andrew Pattison */
		  p = gdImageGetTrueColorPixel (src,
						(int) sx + srcX,
						(int) sy + srcY);
		  red += gdTrueColorGetRed (p) * pcontribution;
		  green += gdTrueColorGetGreen (p) * pcontribution;
		  blue += gdTrueColorGetBlue (p) * pcontribution;
		  alpha += gdTrueColorGetAlpha (p) * pcontribution;
		  spixels += xportion * yportion;
		  sx += 1.0;
		}
	      while (sx < sx2);
	      sy += 1.0;
	    }
	  while (sy < sy2);
	  if (spixels != 0.0)
	    {
	      red /= spixels;
	      green /= spixels;
	      blue /= spixels;
	      alpha /= spixels;
	    }
	  /* Clamping to allow for rounding errors above */
	  if (red > 255.0)
	    {
	      red = 255.0;
	    }
	  if (green > 255.0)
	    {
	      green = 255.0;
	    }
	  if (blue > 255.0)
	    {
	      blue = 255.0;
	    }
	  if (alpha > gdAlphaMax)
	    {
	      alpha = gdAlphaMax;
	    }
	  gdImageSetPixel (dst,
			   x, y,
			   gdTrueColorAlpha ((int) red,
					     (int) green,
					     (int) blue, (int) alpha));
	}
    }
}

BGD_DECLARE(gdImagePtr) gdImageCreateFromXbm (FILE * fd)
{
  gdImagePtr im;
  int bit;
  int w, h;
  int bytes;
  int ch;
  int i, x, y;
  char *sp;
  char s[161];
  if (!fgets (s, 160, fd))
    {
      return 0;
    }
  sp = &s[0];
  /* Skip #define */
  sp = strchr (sp, ' ');
  if (!sp)
    {
      return 0;
    }
  /* Skip width label */
  sp++;
  sp = strchr (sp, ' ');
  if (!sp)
    {
      return 0;
    }
  /* Get width */
  w = atoi (sp + 1);
  if (!w)
    {
      return 0;
    }
  if (!fgets (s, 160, fd))
    {
      return 0;
    }
  sp = s;
  /* Skip #define */
  sp = strchr (sp, ' ');
  if (!sp)
    {
      return 0;
    }
  /* Skip height label */
  sp++;
  sp = strchr (sp, ' ');
  if (!sp)
    {
      return 0;
    }
  /* Get height */
  h = atoi (sp + 1);
  if (!h)
    {
      return 0;
    }
  /* Skip declaration line */
  if (!fgets (s, 160, fd))
    {
      return 0;
    }
  bytes = (w * h / 8) + 1;
  im = gdImageCreate (w, h);
  if (!im) {
    return 0;
  }

  gdImageColorAllocate (im, 255, 255, 255);
  gdImageColorAllocate (im, 0, 0, 0);
  x = 0;
  y = 0;
  for (i = 0; (i < bytes); i++)
    {
      char h[3];
      unsigned int b;
      /* Skip spaces, commas, CRs, 0x */
      while (1)
	{
	  ch = getc (fd);
	  if (ch == EOF)
	    {
	      goto fail;
	    }
	  if (ch == 'x')
	    {
	      break;
	    }
	}
      /* Get hex value */
      ch = getc (fd);
      if (ch == EOF)
	{
	  goto fail;
	}
      h[0] = ch;
      ch = getc (fd);
      if (ch == EOF)
	{
	  goto fail;
	}
      h[1] = ch;
      h[2] = '\0';
      sscanf (h, "%x", &b);
      for (bit = 1; (bit <= 128); (bit = bit << 1))
	{
	  gdImageSetPixel (im, x++, y, (b & bit) ? 1 : 0);
	  if (x == im->sx)
	    {
	      x = 0;
	      y++;
	      if (y == im->sy)
		{
		  return im;
		}
	      /* Fix 8/8/95 */
	      break;
	    }
	}
    }
  /* Shouldn't happen */
  fprintf (stderr, "Error: bug in gdImageCreateFromXbm!\n");
  return 0;
fail:
  gdImageDestroy (im);
  return 0;
}

BGD_DECLARE(void) gdImagePolygon (gdImagePtr im, gdPointPtr p, int n, int c)
{
  if (!n)
    {
      return;
    }


  gdImageLine (im, p->x, p->y, p[n - 1].x, p[n - 1].y, c);
  gdImageOpenPolygon (im, p, n, c);
}

BGD_DECLARE(void) gdImageOpenPolygon (gdImagePtr im, gdPointPtr p, int n, int c)
{
  int i;
  int lx, ly;
  if (!n)
    {
      return;
    }


  lx = p->x;
  ly = p->y;
  for (i = 1; (i < n); i++)
    {
      p++;
      gdImageLine (im, lx, ly, p->x, p->y, c);
      lx = p->x;
      ly = p->y;
    }

}

/* THANKS to Kirsten Schulz for the polygon fixes! */

/* The intersection finding technique of this code could be improved  */
/* by remembering the previous intertersection, and by using the slope. */
/* That could help to adjust intersections  to produce a nice */
/* interior_extrema. */

#if 0
static void horizontalLine(gdImagePtr im, int minx, int maxx, int y,
	int fill_color);
#endif

BGD_DECLARE(void) gdImageFilledPolygon (gdImagePtr im, gdPointPtr p, int n, int c)
{
  int i;
  int j;
  int index;
  int y;
  int miny, maxy;
  int x1, y1;
  int x2, y2;
  int ind1, ind2;
  int ints;
  int fill_color;
  if (!n)
    {
      return;
    }


  if (!im->polyAllocated)
    {
      if (overflow2(sizeof (int), n)) {
        return;
      }
      im->polyInts = (int *) gdMalloc (sizeof (int) * n);
			if (!im->polyInts) {
				return;
			}
      im->polyAllocated = n;
    }
  if (im->polyAllocated < n)
    {
      while (im->polyAllocated < n)
	{
	  im->polyAllocated *= 2;
	}
      if (overflow2(sizeof (int), im->polyAllocated)) {
        return;
      }
      im->polyInts = (int *) gdRealloc (im->polyInts,
					sizeof (int) * im->polyAllocated);
			if (!im->polyInts) {
				return;
			}
    }
  miny = p[0].y;
  maxy = p[0].y;
  for (i = 1; (i < n); i++)
    {
      if (p[i].y < miny)
	{
	  miny = p[i].y;
	}
      if (p[i].y > maxy)
	{
	  maxy = p[i].y;
	}
    }
  /* 2.0.16: Optimization by Ilia Chipitsine -- don't waste time offscreen */
  /* 2.0.26: clipping rectangle is even better */
  if (miny < im->cy1)
    {
      miny = im->cy1;
    }
  if (maxy > im->cy2)
    {
      maxy = im->cy2;
    }
  /* Fix in 1.3: count a vertex only once */
  for (y = miny; (y <= maxy); y++)
    {
/*1.4           int interLast = 0; */
/*              int dirLast = 0; */
/*              int interFirst = 1; */
/* 2.0.26+      int yshift = 0; */
      if (c == gdAntiAliased) {
        fill_color = im->AA_color;
      } else {
        fill_color = c;
      }
      ints = 0;
      for (i = 0; (i < n); i++)
	{
	  if (!i)
	    {
	      ind1 = n - 1;
	      ind2 = 0;
	    }
	  else
	    {
	      ind1 = i - 1;
	      ind2 = i;
	    }
	  y1 = p[ind1].y;
	  y2 = p[ind2].y;
	  if (y1 < y2)
	    {
	      x1 = p[ind1].x;
	      x2 = p[ind2].x;
	    }
	  else if (y1 > y2)
	    {
	      y2 = p[ind1].y;
	      y1 = p[ind2].y;
	      x2 = p[ind1].x;
	      x1 = p[ind2].x;
	    }
	  else
	    {
	      continue;
	    }

	  /* Do the following math as float intermediately, and round to ensure
	   * that Polygon and FilledPolygon for the same set of points have the
	   * same footprint. */
 
	  if ((y >= y1) && (y < y2))
	    {
	      im->polyInts[ints++] = (int) ((float) ((y - y1) * (x2 - x1)) /
		(float) (y2 - y1) + 0.5 + x1);
	    }
	  else if ((y == maxy) && (y > y1) && (y <= y2))
	    {
	      im->polyInts[ints++] = (int) ((float) ((y - y1) * (x2 - x1)) /
		(float) (y2 - y1) + 0.5 + x1);
	    }
	}
      /* 
        2.0.26: polygons pretty much always have less than 100 points,
        and most of the time they have considerably less. For such trivial
        cases, insertion sort is a good choice. Also a good choice for
        future implementations that may wish to indirect through a table.
      */
      for (i = 1; (i < ints); i++) {
        index = im->polyInts[i];
        j = i;
        while ((j > 0) && (im->polyInts[j - 1] > index)) {
          im->polyInts[j] = im->polyInts[j - 1];
          j--;
        }
        im->polyInts[j] = index;
      }
      for (i = 0; (i < (ints)); i += 2)
	{
#if 0
          int minx = im->polyInts[i];
          int maxx = im->polyInts[i + 1];
#endif
          /* 2.0.29: back to gdImageLine to prevent segfaults when
            performing a pattern fill */
          gdImageLine (im, im->polyInts[i], y, im->polyInts[i + 1], y,
            fill_color);
	}
    }
  /* If we are drawing this AA, then redraw the border with AA lines. */
  /* This doesn't work as well as I'd like, but it doesn't clash either. */
  if (c == gdAntiAliased) {
    gdImagePolygon (im, p, n, c);
  } 
}

#if 0
static void horizontalLine(gdImagePtr im, int minx, int maxx, int y,
	int fill_color)
{
  /* 2.0.27: potential corruption fixed by John Ellson */
  if (minx < im->cx1) minx = im->cx1;
  if (maxx < minx) maxx = minx;
  if (maxx > im->cx2) maxx = im->cx2;
  if (minx > maxx) minx = maxx;
                                                                                                                                        
  if (y < im->cy1) y = im->cy1;
  if (y > im->cy2) y = im->cy2;
                                                                                                                                        
  if (im->trueColor) {
    while (minx <= maxx) {
      im->tpixels[y][minx++] = fill_color;
    }
  } else {
    while (minx <= maxx) {
      im->pixels[y][minx++] = fill_color;
    }
  }
}
#endif

static void gdImageSetAAPixelColor(gdImagePtr im, int x, int y, int color, int t);

BGD_DECLARE(void) gdImageSetStyle (gdImagePtr im, int *style, int noOfPixels)
{
  if (im->style)
    {
      gdFree (im->style);
    }
  if (overflow2(sizeof (int), noOfPixels)) {
    return;
  }   	
  im->style = (int *) gdMalloc (sizeof (int) * noOfPixels);
	if (!im->style) {
		return;
	}
  memcpy (im->style, style, sizeof (int) * noOfPixels);
  im->styleLength = noOfPixels;
  im->stylePos = 0;
}

BGD_DECLARE(void) gdImageSetThickness (gdImagePtr im, int thickness)
{
  im->thick = thickness;
}

BGD_DECLARE(void) gdImageSetBrush (gdImagePtr im, gdImagePtr brush)
{
  int i;
  im->brush = brush;
  if ((!im->trueColor) && (!im->brush->trueColor))
    {
      for (i = 0; (i < gdImageColorsTotal (brush)); i++)
	{
	  int index;
	  index = gdImageColorResolveAlpha (im,
					    gdImageRed (brush, i),
					    gdImageGreen (brush, i),
					    gdImageBlue (brush, i),
					    gdImageAlpha (brush, i));
	  im->brushColorMap[i] = index;
	}
    }
}

BGD_DECLARE(void) gdImageSetTile (gdImagePtr im, gdImagePtr tile)
{
  int i;
  im->tile = tile;
  if ((!im->trueColor) && (!im->tile->trueColor))
    {
      for (i = 0; (i < gdImageColorsTotal (tile)); i++)
	{
	  int index;
	  index = gdImageColorResolveAlpha (im,
					    gdImageRed (tile, i),
					    gdImageGreen (tile, i),
					    gdImageBlue (tile, i),
					    gdImageAlpha (tile, i));
	  im->tileColorMap[i] = index;
	}
    }
}

BGD_DECLARE(void) gdImageSetAntiAliased (gdImagePtr im, int c)
{
  im->AA = 1;
  im->AA_color = c;
  im->AA_dont_blend = -1;
}

BGD_DECLARE(void) gdImageSetAntiAliasedDontBlend (gdImagePtr im, int c, int dont_blend)
{
  im->AA = 1;
  im->AA_color = c;
  im->AA_dont_blend = dont_blend;
}

BGD_DECLARE(void) gdImageInterlace (gdImagePtr im, int interlaceArg)
{
  im->interlace = interlaceArg;
}

BGD_DECLARE(int) gdImageCompare (gdImagePtr im1, gdImagePtr im2)
{
  int x, y;
  int p1, p2;
  int cmpStatus = 0;
  int sx, sy;

  if (im1->interlace != im2->interlace)
    {
      cmpStatus |= GD_CMP_INTERLACE;
    }

  if (im1->transparent != im2->transparent)
    {
      cmpStatus |= GD_CMP_TRANSPARENT;
    }

  if (im1->trueColor != im2->trueColor)
    {
      cmpStatus |= GD_CMP_TRUECOLOR;
    }

  sx = im1->sx;
  if (im1->sx != im2->sx)
    {
      cmpStatus |= GD_CMP_SIZE_X + GD_CMP_IMAGE;
      if (im2->sx < im1->sx)
	{
	  sx = im2->sx;
	}
    }

  sy = im1->sy;
  if (im1->sy != im2->sy)
    {
      cmpStatus |= GD_CMP_SIZE_Y + GD_CMP_IMAGE;
      if (im2->sy < im1->sy)
	{
	  sy = im2->sy;
	}
    }

  if (im1->colorsTotal != im2->colorsTotal)
    {
      cmpStatus |= GD_CMP_NUM_COLORS;
    }

  for (y = 0; (y < sy); y++)
    {
      for (x = 0; (x < sx); x++)
	{
	  p1 =
	    im1->trueColor ? gdImageTrueColorPixel (im1, x,
						    y) :
	    gdImagePalettePixel (im1, x, y);
	  p2 =
	    im2->trueColor ? gdImageTrueColorPixel (im2, x,
						    y) :
	    gdImagePalettePixel (im2, x, y);
	  if (gdImageRed (im1, p1) != gdImageRed (im2, p2))
	    {
	      cmpStatus |= GD_CMP_COLOR + GD_CMP_IMAGE;
	      break;
	    }
	  if (gdImageGreen (im1, p1) != gdImageGreen (im2, p2))
	    {
	      cmpStatus |= GD_CMP_COLOR + GD_CMP_IMAGE;
	      break;
	    }
	  if (gdImageBlue (im1, p1) != gdImageBlue (im2, p2))
	    {
	      cmpStatus |= GD_CMP_COLOR + GD_CMP_IMAGE;
	      break;
	    }
#if 0
	  /* Soon we'll add alpha channel to palettes */
	  if (gdImageAlpha (im1, p1) != gdImageAlpha (im2, p2))
	    {
	      cmpStatus |= GD_CMP_COLOR + GD_CMP_IMAGE;
	      break;
	    }
#endif
	}
      if (cmpStatus & GD_CMP_COLOR)
	{
	  break;
	};
    }

  return cmpStatus;
}


/* Thanks to Frank Warmerdam for this superior implementation
	of gdAlphaBlend(), which merges alpha in the
	destination color much better. */

BGD_DECLARE(int) gdAlphaBlend (int dst, int src)
{
    int src_alpha = gdTrueColorGetAlpha(src);
    int dst_alpha, alpha, red, green, blue;
    int src_weight, dst_weight, tot_weight;

/* -------------------------------------------------------------------- */
/*      Simple cases we want to handle fast.                            */
/* -------------------------------------------------------------------- */
    if( src_alpha == gdAlphaOpaque )
        return src;

    dst_alpha = gdTrueColorGetAlpha(dst);
    if( src_alpha == gdAlphaTransparent )
        return dst;
    if( dst_alpha == gdAlphaTransparent )
        return src;

/* -------------------------------------------------------------------- */
/*      What will the source and destination alphas be?  Note that      */
/*      the destination weighting is substantially reduced as the       */
/*      overlay becomes quite opaque.                                   */
/* -------------------------------------------------------------------- */
    src_weight = gdAlphaTransparent - src_alpha;
    dst_weight = (gdAlphaTransparent - dst_alpha) * src_alpha / gdAlphaMax;
    tot_weight = src_weight + dst_weight;
    
/* -------------------------------------------------------------------- */
/*      What red, green and blue result values will we use?             */
/* -------------------------------------------------------------------- */
    alpha = src_alpha * dst_alpha / gdAlphaMax;

    red = (gdTrueColorGetRed(src) * src_weight
           + gdTrueColorGetRed(dst) * dst_weight) / tot_weight;
    green = (gdTrueColorGetGreen(src) * src_weight
           + gdTrueColorGetGreen(dst) * dst_weight) / tot_weight;
    blue = (gdTrueColorGetBlue(src) * src_weight
           + gdTrueColorGetBlue(dst) * dst_weight) / tot_weight;

/* -------------------------------------------------------------------- */
/*      Return merged result.                                           */
/* -------------------------------------------------------------------- */
    return ((alpha << 24) + (red << 16) + (green << 8) + blue);
}

BGD_DECLARE(void) gdImageAlphaBlending (gdImagePtr im, int alphaBlendingArg)
{
  im->alphaBlendingFlag = alphaBlendingArg;
}

BGD_DECLARE(void) gdImageSaveAlpha (gdImagePtr im, int saveAlphaArg)
{
  im->saveAlphaFlag = saveAlphaArg;
}

BGD_DECLARE(void) gdImageSetClip (gdImagePtr im, int x1, int y1, int x2, int y2)
{
  if (x1 < 0)
    {
      x1 = 0;
    }
  if (x1 >= im->sx)
    {
      x1 = im->sx - 1;
    }
  if (x2 < 0)
    {
      x2 = 0;
    }
  if (x2 >= im->sx)
    {
      x2 = im->sx - 1;
    }
  if (y1 < 0)
    {
      y1 = 0;
    }
  if (y1 >= im->sy)
    {
      y1 = im->sy - 1;
    }
  if (y2 < 0)
    {
      y2 = 0;
    }
  if (y2 >= im->sy)
    {
      y2 = im->sy - 1;
    }
  im->cx1 = x1;
  im->cy1 = y1;
  im->cx2 = x2;
  im->cy2 = y2;
}

BGD_DECLARE(void) gdImageGetClip (gdImagePtr im, int *x1P, int *y1P, int *x2P, int *y2P)
{
  *x1P = im->cx1;
  *y1P = im->cy1;
  *x2P = im->cx2;
  *y2P = im->cy2;
}

/*
 * Added on 2003/12 by Pierre-Alain Joye (pajoye@pearfr.org)
 * */
#define BLEND_COLOR(a, nc, c, cc) \
nc = (cc) + (((((c) - (cc)) * (a)) + ((((c) - (cc)) * (a)) >> 8) + 0x80) >> 8);

static void gdImageSetAAPixelColor(gdImagePtr im, int x, int y, int color, int t)
{
	int dr,dg,db,p,r,g,b;

	/* 2.0.34: watch out for out of range calls */
	if (!gdImageBoundsSafeMacro(im, x, y)) {
		return;
	}
	p = gdImageGetPixel(im,x,y);
        /* TBB: we have to implement the dont_blend stuff to provide
          the full feature set of the old implementation */
        if ((p == color)
	  || ((p == im->AA_dont_blend)
	      && (t != 0x00)))
        {
          return;
        }
	dr = gdTrueColorGetRed(color);
	dg = gdTrueColorGetGreen(color);
	db = gdTrueColorGetBlue(color);

	r = gdTrueColorGetRed(p);
	g = gdTrueColorGetGreen(p);
	b = gdTrueColorGetBlue(p);

	BLEND_COLOR(t, dr, r, dr);
	BLEND_COLOR(t, dg, g, dg);
	BLEND_COLOR(t, db, b, db);
	im->tpixels[y][x] = gdTrueColorAlpha(dr, dg, db,  gdAlphaOpaque);
}  

static void gdImageAALine (gdImagePtr im, int x1, int y1, int x2, int y2, int col)
{
	/* keep them as 32bits */
	long x, y, inc;
	long dx, dy,tmp;

	if (!im->trueColor) {
		/* TBB: don't crash when the image is of the wrong type */
		gdImageLine(im, x1, y1, x2, y2, col);
		return;
	}
        /* TBB: use the clipping rectangle */
        if (clip_1d (&x1, &y1, &x2, &y2, im->cx1, im->cx2) == 0)
          return;
        if (clip_1d (&y1, &x1, &y2, &x2, im->cy1, im->cy2) == 0)
          return;
	dx = x2 - x1;
	dy = y2 - y1;

	/* Axis aligned lines */
	if (dx == 0) {
		gdImageVLine(im, x1, y1, y2, col);
		return;
	} else if (dy == 0) {
		gdImageHLine(im, y1, x1, x2, col);
		return;
	}

	if (dx == 0 && dy == 0) {
		/* TBB: allow setting points */
		gdImageSetAAPixelColor(im, x1, y1, col, 0xFF);
		return;
	}
	if (abs(dx) > abs(dy)) {
		if (dx < 0) {
			tmp = x1;
			x1 = x2;
			x2 = tmp;
			tmp = y1;
			y1 = y2;
			y2 = tmp;
			dx = x2 - x1;
			dy = y2 - y1;
		}
		x = x1 << 16;
		y = y1 << 16;
		inc = (dy * 65536) / dx;
		/* TBB: set the last pixel for consistency (<=) */
		while ((x >> 16) <= x2) {
			gdImageSetAAPixelColor(im, x >> 16, y >> 16, col, (y >> 8) & 0xFF);
			gdImageSetAAPixelColor(im, x >> 16, (y >> 16) + 1,col, (~y >> 8) & 0xFF);
			x += (1 << 16);
			y += inc;
		}
	} else {
		if (dy < 0) {
			tmp = x1;
			x1 = x2;
			x2 = tmp;
			tmp = y1;
			y1 = y2;
			y2 = tmp;
			dx = x2 - x1;
			dy = y2 - y1;
		}
		x = x1 << 16;
		y = y1 << 16;
		inc = (dx * 65536) / dy;
		/* TBB: set the last pixel for consistency (<=) */
		while ((y>>16) <= y2) {
			gdImageSetAAPixelColor(im, x >> 16, y >> 16, col, (x >> 8) & 0xFF);
			gdImageSetAAPixelColor(im, (x >> 16) + 1, (y >> 16),col, (~x >> 8) & 0xFF);
			x += inc;
			y += (1<<16);
		}
	}
}
 1405        85054       4826        1193070198  200         0           100640      12  gd2copypal.c`

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include <stdio.h>
#include <stdlib.h>
#include "gd.h"

/* A short program which converts a .png file into a .gd file, for
   your convenience in creating images on the fly from a
   basis image that must be loaded quickly. The .gd format
   is not intended to be a general-purpose format. */

int
main (int argc, char **argv)
{
  gdImagePtr im;
  gdImagePtr pal;
  FILE *in, *out;
  if (argc != 3)
    {
      fprintf (stderr, "Usage: gd2copypal palettefile.gd2 filename.gd2\n");
      exit (1);
    }
  in = fopen (argv[1], "rb");
  if (!in)
    {
      fprintf (stderr, "Palette file does not exist!\n");
      exit (1);
    }
  pal = gdImageCreateFromGd2 (in);
  fclose (in);
  if (!pal)
    {
      fprintf (stderr, "Palette is not in GD2 format!\n");
      exit (1);
    }

  in = fopen (argv[2], "rb");
  if (!in)
    {
      fprintf (stderr, "Input file does not exist!\n");
      exit (1);
    }
  im = gdImageCreateFromGd2 (in);
  fclose (in);
  if (!im)
    {
      fprintf (stderr, "Input is not in GD2 format!\n");
      exit (1);
    }

  gdImagePaletteCopy (im, pal);

  out = fopen (argv[2], "wb");
  if (!out)
    {
      fprintf (stderr, "Output file cannot be written to!\n");
      gdImageDestroy (im);
      exit (1);
    }
  gdImageGd2 (im, out, 128, 2);
  fclose (out);
  gdImageDestroy (pal);
  gdImageDestroy (im);

  return 0;
}
 1284        86438       83546       1193070198  200         0           100640      9   gd2time.c `
#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include <stdio.h>
#include <stdlib.h>		/* for atoi */
#include <time.h>		/* For time */
#include "gd.h"

/* A short program which converts a .png file into a .gd file, for
   your convenience in creating images on the fly from a
   basis image that must be loaded quickly. The .gd format
   is not intended to be a general-purpose format. */

int
main (int argc, char **argv)
{
  gdImagePtr im;
  FILE *in;
  int x, y, w, h;
  int c;
  int i;
  int t0;

  if (argc != 7)
    {
      fprintf (stderr, "Usage: gd2time filename.gd count x y w h\n");
      exit (1);
    }

  c = atoi (argv[2]);
  x = atoi (argv[3]);
  y = atoi (argv[4]);
  w = atoi (argv[5]);
  h = atoi (argv[6]);

  printf ("Extracting %d times from (%d, %d), size is %dx%d\n", c, x, y, w,
	  h);

  t0 = time (0);
  for (i = 0; i < c; i++)
    {
      in = fopen (argv[1], "rb");
      if (!in)
	{
	  fprintf (stderr, "Input file does not exist!\n");
	  exit (1);
	}

      im = gdImageCreateFromGd2Part (in, x, y, w, h);
      fclose (in);

      if (!im)
	{
	  fprintf (stderr, "Error reading source file!\n");
	  exit (1);
	}
      gdImageDestroy (im);
    };
  t0 = time (0) - t0;
  printf ("%d seconds to extract (& destroy) %d times\n", t0, c);

  return 0;
}
940         87478       85054       1193070198  200         0           100640      10  gd2togif.c`
#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include <stdio.h>
#include <stdlib.h>

#include "gd.h"

/* A short program which converts a .gif file into a .gd file, for
	your convenience in creating images on the fly from a
	basis image that must be loaded quickly. The .gd format
	is not intended to be a general-purpose format. */

int main(int argc, char **argv)
{
	gdImagePtr im;
	FILE *in, *out;
	if (argc != 3) {
		fprintf(stderr, "Usage: gd2togif filename.gd2 filename.gif\n");
		exit(1);
	}
	in = fopen(argv[1], "rb");
	if (!in) {
		fprintf(stderr, "Input file does not exist!\n");
		exit(1);
	}
	im = gdImageCreateFromGd2(in);
	fclose(in);
	if (!im) {
		fprintf(stderr, "Input is not in GIF format!\n");
		exit(1);
	}
	out = fopen(argv[2], "wb");
	if (!out) {
		fprintf(stderr, "Output file cannot be written to!\n");
		gdImageDestroy(im);
		exit(1);	
	}
	gdImageGif(im, out);
	fclose(out);
	gdImageDestroy(im);

	return 0;
}

1546        89124       86438       1193070198  200         0           100640      10  gd2topng.c`

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include <stdio.h>
#include <stdlib.h>
#include "gd.h"

/* A short program which converts a .png file into a .gd2 file, for
   your convenience in creating images on the fly from a
   basis image that must be loaded quickly. The .gd2 format
   is not intended to be a general-purpose format. */

int
main (int argc, char **argv)
{
  gdImagePtr im;
  FILE *in, *out;
  int x=0, y=0, w=0, h=0;
  if ((argc != 3) && (argc != 7))
    {
      fprintf (stderr,
	       "Usage: gd2topng filename.gd2 filename.png [srcx srcy width height]\n");
      fprintf (stderr,
	       "If the coordinates are absent,t he entire image is converted.\n");
      exit (1);
    }
  if (argc == 7)
    {
      x = atoi (argv[3]);
      y = atoi (argv[4]);
      w = atoi (argv[5]);
      h = atoi (argv[6]);
    }
  in = fopen (argv[1], "rb");
  if (!in)
    {
      fprintf (stderr, "Input file does not exist!\n");
      exit (1);
    }
  if (argc == 7)
    {
      im = gdImageCreateFromGd2Part (in, x, y, w, h);
    }
  else
    {
      im = gdImageCreateFromGd2 (in);
    }
  fclose (in);
  if (!im)
    {
      fprintf (stderr, "Input is not in GD2 format!\n");
      exit (1);
    }
  out = fopen (argv[2], "wb");
  if (!out)
    {
      fprintf (stderr, "Output file cannot be written to!\n");
      gdImageDestroy (im);
      exit (1);
    }
#ifdef HAVE_LIBPNG
  gdImagePng (im, out);
#else
  fprintf (stderr, "No PNG library support available.\n");
#endif
  fclose (out);
  gdImageDestroy (im);

  return 0;
}
5808        95030       87478       1193070200  200         0           100640      7   gd_gd.c `
#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include <stdio.h>
#include <math.h>
#include <string.h>
#include <stdlib.h>
#include "gd.h"

#define TRUE 1
#define FALSE 0

/* Use this for commenting out debug-print statements. */
/* Just use the first '#define' to allow all the prints... */
/*#define GD2_DBG(s) (s) */
#define GD2_DBG(s)

/* */
/* Shared code to read color tables from gd file. */
/* */
int
_gdGetColors (gdIOCtx * in, gdImagePtr im, int gd2xFlag)
{
  int i;
  if (gd2xFlag)
    {
      int trueColorFlag;
      if (!gdGetByte (&trueColorFlag, in))
	{
	  goto fail1;
	}
      /* 2.0.12: detect bad truecolor .gd files created by pre-2.0.12.
         Beginning in 2.0.12 truecolor is indicated by the initial 2-byte
         signature. */
      if (trueColorFlag != im->trueColor)
	{
	  goto fail1;
	}
      /* This should have been a word all along */
      if (!im->trueColor)
	{
	  if (!gdGetWord (&im->colorsTotal, in))
	    {
	      goto fail1;
	    }
	}
      /* Int to accommodate truecolor single-color transparency */
      if (!gdGetInt (&im->transparent, in))
	{
	  goto fail1;
	}
    }
  else
    {
      if (!gdGetByte (&im->colorsTotal, in))
	{
	  goto fail1;
	}
      if (!gdGetWord (&im->transparent, in))
	{
	  goto fail1;
	}
      if (im->transparent == 257)
	{
	  im->transparent = (-1);
	}
    }
  GD2_DBG (printf
	   ("Pallette had %d colours (T=%d)\n", im->colorsTotal,
	    im->transparent));
  if (im->trueColor)
    {
      return TRUE;
    }
  for (i = 0; (i < gdMaxColors); i++)
    {
      if (!gdGetByte (&im->red[i], in))
	{
	  goto fail1;
	}
      if (!gdGetByte (&im->green[i], in))
	{
	  goto fail1;
	}
      if (!gdGetByte (&im->blue[i], in))
	{
	  goto fail1;
	}
      if (gd2xFlag)
	{
	  if (!gdGetByte (&im->alpha[i], in))
	    {
	      goto fail1;
	    }
	}
    }

  for (i = 0; (i < im->colorsTotal); i++)
    {
      im->open[i] = 0;
    };

  return TRUE;
fail1:
  return FALSE;
}

/* */
/* Use the common basic header info to make the image object. */
/* */
static gdImagePtr
_gdCreateFromFile (gdIOCtx * in, int *sx, int *sy)
{
  gdImagePtr im;
  int gd2xFlag = 0;
  int trueColorFlag = 0;
  if (!gdGetWord (sx, in))
    {
      goto fail1;
    }
  if ((*sx == 65535) || (*sx == 65534))
    {
      /* This is a gd 2.0 .gd file */
      gd2xFlag = 1;
      /* 2.0.12: 65534 signals a truecolor .gd file. 
         There is a slight redundancy here but we can
         live with it. */
      if (*sx == 65534)
	{
	  trueColorFlag = 1;
	}
      if (!gdGetWord (sx, in))
	{
	  goto fail1;
	}
    }
  if (!gdGetWord (sy, in))
    {
      goto fail1;
    }

  GD2_DBG (printf ("Image is %dx%d\n", *sx, *sy));
  if (trueColorFlag)
    {
      im = gdImageCreateTrueColor (*sx, *sy);
    }
  else
    {
      im = gdImageCreate (*sx, *sy);
    }
  if (!_gdGetColors (in, im, gd2xFlag))
    {
      goto fail2;
    }

  return im;
fail2:
  gdImageDestroy (im);
fail1:
  return 0;
}

BGD_DECLARE(gdImagePtr) gdImageCreateFromGd (FILE * inFile)
{
  gdImagePtr im;
  gdIOCtx *in;

  in = gdNewFileCtx (inFile);
  im = gdImageCreateFromGdCtx (in);

  in->gd_free (in);

  return im;
}

BGD_DECLARE(gdImagePtr) gdImageCreateFromGdPtr (int size, void *data)
{
  gdImagePtr im;
  gdIOCtx *in = gdNewDynamicCtxEx (size, data, 0);
  im = gdImageCreateFromGdCtx (in);
  in->gd_free (in);
  return im;
}

BGD_DECLARE(gdImagePtr) gdImageCreateFromGdCtx (gdIOCtxPtr in)
{
  int sx, sy;
  int x, y;
  gdImagePtr im;

  /* Read the header */
  im = _gdCreateFromFile (in, &sx, &sy);

  if (im == NULL)
    {
      goto fail1;
    };

  /* Then the data... */
  /* 2.0.12: support truecolor properly in .gd as well as in .gd2.
     Problem reported by Andreas Pfaller. */
  if (im->trueColor)
    {
      for (y = 0; (y < sy); y++)
	{
	  for (x = 0; (x < sx); x++)
	    {
	      int pix;
	      if (!gdGetInt (&pix, in))
		{
		  goto fail2;
		}
	      im->tpixels[y][x] = pix;
	    }
	}
    }
  else
    {
      for (y = 0; (y < sy); y++)
	{
	  for (x = 0; (x < sx); x++)
	    {
	      int ch;
	      ch = gdGetC (in);
	      if (ch == EOF)
		{
		  goto fail2;
		}
	      /* ROW-MAJOR IN GD 1.3 */
	      im->pixels[y][x] = ch;
	    }
	}
    }
  return im;

fail2:
  gdImageDestroy (im);
fail1:
  return 0;
}

void
_gdPutColors (gdImagePtr im, gdIOCtx * out)
{
  int i;

  gdPutC (im->trueColor, out);
  if (!im->trueColor)
    {
      gdPutWord (im->colorsTotal, out);
    }
  gdPutInt (im->transparent, out);
  if (!im->trueColor)
    {
      for (i = 0; (i < gdMaxColors); i++)
	{
	  gdPutC ((unsigned char) im->red[i], out);
	  gdPutC ((unsigned char) im->green[i], out);
	  gdPutC ((unsigned char) im->blue[i], out);
	  gdPutC ((unsigned char) im->alpha[i], out);
	}
    }
}

static void
_gdPutHeader (gdImagePtr im, gdIOCtx * out)
{
  /* 65535 indicates this is a gd 2.x .gd file. 
     2.0.12: 65534 indicates truecolor. */
  if (im->trueColor)
    {
      gdPutWord (65534, out);
    }
  else
    {
      gdPutWord (65535, out);
    }
  gdPutWord (im->sx, out);
  gdPutWord (im->sy, out);

  _gdPutColors (im, out);

}

static void
_gdImageGd (gdImagePtr im, gdIOCtx * out)
{
  int x, y;

  _gdPutHeader (im, out);

  for (y = 0; (y < im->sy); y++)
    {
      for (x = 0; (x < im->sx); x++)
	{
	  /* ROW-MAJOR IN GD 1.3 */
	  if (im->trueColor)
	    {
	      gdPutInt (im->tpixels[y][x], out);
	    }
	  else
	    {
	      gdPutC ((unsigned char) im->pixels[y][x], out);
	    }
	}
    }
}

BGD_DECLARE(void) gdImageGd (gdImagePtr im, FILE * outFile)
{
  gdIOCtx *out = gdNewFileCtx (outFile);
  _gdImageGd (im, out);
  out->gd_free (out);
}

BGD_DECLARE(void *) gdImageGdPtr (gdImagePtr im, int *size)
{
  void *rv;
  gdIOCtx *out = gdNewDynamicCtx (2048, NULL);
  _gdImageGd (im, out);
  rv = gdDPExtractData (out, size);
  out->gd_free (out);
  return rv;
}
22959       118088      89124       1193070200  200         0           100640      8   gd_gd2.c`
/*
   * gd_gd2.c
   *
   * Implements the I/O and support for the GD2 format.
   *
   * Changing the definition of GD2_DBG (below) will cause copious messages
   * to be displayed while it processes requests.
   *
   * Designed, Written & Copyright 1999, Philip Warner.
   *
 */

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include <stdio.h>
/* 2.0.29: no more errno.h, makes windows happy */
#include <math.h>
#include <string.h>
#include <stdlib.h>
#include "gd.h"
#include "gdhelpers.h"

/* 2.03: gd2 is no longer mandatory */
/* JCE - test after including gd.h so that HAVE_LIBZ can be set in
 * a config.h file included by gd.h */
#ifdef HAVE_LIBZ
#include <zlib.h>

#define TRUE 1
#define FALSE 0

/* 2.11: not part of the API, as the save routine can figure it out
	from im->trueColor, and the load routine doesn't need to tell
	the end user the saved format. NOTE: adding 2 is assumed
	to result in the correct format value for truecolor! */
#define GD2_FMT_TRUECOLOR_RAW 3
#define GD2_FMT_TRUECOLOR_COMPRESSED 4

#define gd2_compressed(fmt) (((fmt) == GD2_FMT_COMPRESSED) || \
	((fmt) == GD2_FMT_TRUECOLOR_COMPRESSED))

#define gd2_truecolor(fmt) (((fmt) == GD2_FMT_TRUECOLOR_RAW) || \
	((fmt) == GD2_FMT_TRUECOLOR_COMPRESSED))

/* Use this for commenting out debug-print statements. */
/* Just use the first '#define' to allow all the prints... */
/*#define GD2_DBG(s) (s) */
#define GD2_DBG(s)

typedef struct
{
  int offset;
  int size;
}
t_chunk_info;

extern int _gdGetColors (gdIOCtx * in, gdImagePtr im, int gd2xFlag);
extern void _gdPutColors (gdImagePtr im, gdIOCtx * out);

/* */
/* Read the extra info in the gd2 header. */
/* */
static int
_gd2GetHeader (gdIOCtxPtr in, int *sx, int *sy,
	       int *cs, int *vers, int *fmt, int *ncx, int *ncy,
	       t_chunk_info ** chunkIdx)
{
  int i;
  int ch;
  char id[5];
  t_chunk_info *cidx;
  int sidx;
  int nc;

  GD2_DBG (printf ("Reading gd2 header info\n"));

  for (i = 0; i < 4; i++)
    {
      ch = gdGetC (in);
      if (ch == EOF)
	{
	  goto fail1;
	};
      id[i] = ch;
    };
  id[4] = 0;

  GD2_DBG (printf ("Got file code: %s\n", id));

  /* Equiv. of 'magick'.  */
  if (strcmp (id, GD2_ID) != 0)
    {
      GD2_DBG (printf ("Not a valid gd2 file\n"));
      goto fail1;
    };

  /* Version */
  if (gdGetWord (vers, in) != 1)
    {
      goto fail1;
    };
  GD2_DBG (printf ("Version: %d\n", *vers));

  if ((*vers != 1) && (*vers != 2))
    {
      GD2_DBG (printf ("Bad version: %d\n", *vers));
      goto fail1;
    };

  /* Image Size */
  if (!gdGetWord (sx, in))
    {
      GD2_DBG (printf ("Could not get x-size\n"));
      goto fail1;
    }
  if (!gdGetWord (sy, in))
    {
      GD2_DBG (printf ("Could not get y-size\n"));
      goto fail1;
    }
  GD2_DBG (printf ("Image is %dx%d\n", *sx, *sy));

  /* Chunk Size (pixels, not bytes!) */
  if (gdGetWord (cs, in) != 1)
    {
      goto fail1;
    };
  GD2_DBG (printf ("ChunkSize: %d\n", *cs));

  if ((*cs < GD2_CHUNKSIZE_MIN) || (*cs > GD2_CHUNKSIZE_MAX))
    {
      GD2_DBG (printf ("Bad chunk size: %d\n", *cs));
      goto fail1;
    };

  /* Data Format */
  if (gdGetWord (fmt, in) != 1)
    {
      goto fail1;
    };
  GD2_DBG (printf ("Format: %d\n", *fmt));

  if ((*fmt != GD2_FMT_RAW) && (*fmt != GD2_FMT_COMPRESSED) &&
      (*fmt != GD2_FMT_TRUECOLOR_RAW) &&
      (*fmt != GD2_FMT_TRUECOLOR_COMPRESSED))
    {
      GD2_DBG (printf ("Bad data format: %d\n", *fmt));
      goto fail1;
    };


  /* # of chunks wide */
  if (gdGetWord (ncx, in) != 1)
    {
      goto fail1;
    };
  GD2_DBG (printf ("%d Chunks Wide\n", *ncx));

  /* # of chunks high */
  if (gdGetWord (ncy, in) != 1)
    {
      goto fail1;
    };
  GD2_DBG (printf ("%d Chunks vertically\n", *ncy));

  if (gd2_compressed (*fmt))
    {
      nc = (*ncx) * (*ncy);
      GD2_DBG (printf ("Reading %d chunk index entries\n", nc));
      sidx = sizeof (t_chunk_info) * nc;
      cidx = gdCalloc (sidx, 1);
			if (!cidx) {
				goto fail1;
			}
      for (i = 0; i < nc; i++)
	{
	  if (gdGetInt (&cidx[i].offset, in) != 1)
	    {
	      goto fail1;
	    };
	  if (gdGetInt (&cidx[i].size, in) != 1)
	    {
	      goto fail1;
	    };
	};
      *chunkIdx = cidx;
    };

  GD2_DBG (printf ("gd2 header complete\n"));

  return 1;

fail1:
  return 0;
}

static gdImagePtr
_gd2CreateFromFile (gdIOCtxPtr in, int *sx, int *sy,
		    int *cs, int *vers, int *fmt,
		    int *ncx, int *ncy, t_chunk_info ** cidx)
{
  gdImagePtr im;

  if (_gd2GetHeader (in, sx, sy, cs, vers, fmt, ncx, ncy, cidx) != 1)
    {
      GD2_DBG (printf ("Bad GD2 header\n"));
      goto fail1;
    }
  if (gd2_truecolor (*fmt))
    {
      im = gdImageCreateTrueColor (*sx, *sy);
    }
  else
    {
      im = gdImageCreate (*sx, *sy);
    }
  if (im == NULL)
    {
      GD2_DBG (printf ("Could not create gdImage\n"));
      goto fail1;
    };

  if (!_gdGetColors (in, im, (*vers) == 2))
    {
      GD2_DBG (printf ("Could not read color palette\n"));
      goto fail2;
    }
  GD2_DBG (printf ("Image palette completed: %d colours\n", im->colorsTotal));

  return im;

fail2:
  gdImageDestroy (im);
  return 0;

fail1:
  return 0;

}

static int
_gd2ReadChunk (int offset, char *compBuf, int compSize, char *chunkBuf,
	       uLongf * chunkLen, gdIOCtx * in)
{
  int zerr;

  if (gdTell (in) != offset)
    {
      GD2_DBG (printf ("Positioning in file to %d\n", offset));
      gdSeek (in, offset);
    }
  else
    {
      GD2_DBG (printf ("Already Positioned in file to %d\n", offset));
    };

  /* Read and uncompress an entire chunk. */
  GD2_DBG (printf ("Reading file\n"));
  if (gdGetBuf (compBuf, compSize, in) != compSize)
    {
      return FALSE;
    };
  GD2_DBG (printf
	   ("Got %d bytes. Uncompressing into buffer of %d bytes\n", compSize,
	    *chunkLen));
  zerr =
    uncompress ((unsigned char *) chunkBuf, chunkLen,
		(unsigned char *) compBuf, compSize);
  if (zerr != Z_OK)
    {
      GD2_DBG (printf ("Error %d from uncompress\n", zerr));
      return FALSE;
    };
  GD2_DBG (printf ("Got chunk\n"));
  return TRUE;
}

BGD_DECLARE(gdImagePtr) gdImageCreateFromGd2 (FILE * inFile)
{
  gdIOCtx *in = gdNewFileCtx (inFile);
  gdImagePtr im;

  im = gdImageCreateFromGd2Ctx (in);

  in->gd_free (in);

  return im;
}

BGD_DECLARE(gdImagePtr) gdImageCreateFromGd2Ptr (int size, void *data)
{
  gdImagePtr im;
  gdIOCtx *in = gdNewDynamicCtxEx (size, data, 0);
  im = gdImageCreateFromGd2Ctx (in);
  in->gd_free (in);
  return im;
}

BGD_DECLARE(gdImagePtr) gdImageCreateFromGd2Ctx (gdIOCtxPtr in)
{
  int sx, sy;
  int i;
  int ncx, ncy, nc, cs, cx, cy;
  int x, y, ylo, yhi, xlo, xhi;
  int vers, fmt;
  t_chunk_info *chunkIdx = NULL;	/* So we can gdFree it with impunity. */
  unsigned char *chunkBuf = NULL;	/* So we can gdFree it with impunity. */
  int chunkNum = 0;
  int chunkMax = 0;
  uLongf chunkLen;
  int chunkPos = 0;
  int compMax = 0;
  int bytesPerPixel;
  char *compBuf = NULL;		/* So we can gdFree it with impunity. */

  gdImagePtr im;

  /* Get the header */
  im =
    _gd2CreateFromFile (in, &sx, &sy, &cs, &vers, &fmt, &ncx, &ncy,
			&chunkIdx);

  if (im == NULL)
    {
      return 0;
    }

  bytesPerPixel = im->trueColor ? 4 : 1;
  nc = ncx * ncy;

  if (gd2_compressed (fmt))
    {
      /* Find the maximum compressed chunk size. */
      compMax = 0;
      for (i = 0; (i < nc); i++)
	{
	  if (chunkIdx[i].size > compMax)
	    {
	      compMax = chunkIdx[i].size;
	    };
	};
      compMax++;

      /* Allocate buffers */
      chunkMax = cs * bytesPerPixel * cs;
      chunkBuf = gdCalloc (chunkMax, 1);
			if (!chunkBuf) {
				goto fail2;
			}
      compBuf = gdCalloc (compMax, 1);
			if (!compBuf) {
				goto fail2;
			}

      GD2_DBG (printf ("Largest compressed chunk is %d bytes\n", compMax));
    };

/*      if ( (ncx != sx / cs) || (ncy != sy / cs)) { */
/*              goto fail2; */
/*      }; */

  /* Read the data... */
  for (cy = 0; (cy < ncy); cy++)
    {
      for (cx = 0; (cx < ncx); cx++)
	{

	  ylo = cy * cs;
	  yhi = ylo + cs;
	  if (yhi > im->sy)
	    {
	      yhi = im->sy;
	    };

	  GD2_DBG (printf
		   ("Processing Chunk %d (%d, %d), y from %d to %d\n",
		    chunkNum, cx, cy, ylo, yhi));

	  if (gd2_compressed (fmt))
	    {

	      chunkLen = chunkMax;

	      if (!_gd2ReadChunk (chunkIdx[chunkNum].offset,
				  compBuf,
				  chunkIdx[chunkNum].size,
				  (char *) chunkBuf, &chunkLen, in))
		{
		  GD2_DBG (printf ("Error reading comproessed chunk\n"));
		  goto fail2;
		};

	      chunkPos = 0;
	    };

	  for (y = ylo; (y < yhi); y++)
	    {

	      xlo = cx * cs;
	      xhi = xlo + cs;
	      if (xhi > im->sx)
		{
		  xhi = im->sx;
		};
	      /*GD2_DBG(printf("y=%d: ",y)); */
	      if (!gd2_compressed (fmt))
		{
		  for (x = xlo; x < xhi; x++)
		    {

		      if (im->trueColor)
			{
			  if (!gdGetInt (&im->tpixels[y][x], in))
			    {
			      /*printf("EOF while reading\n"); */
			      /*gdImageDestroy(im); */
			      /*return 0; */
			      im->tpixels[y][x] = 0;
			    }
			}
		      else
			{
			  int ch;
			  if (!gdGetByte (&ch, in))
			    {
			      /*printf("EOF while reading\n"); */
			      /*gdImageDestroy(im); */
			      /*return 0; */
			      ch = 0;
			    }
			  im->pixels[y][x] = ch;
			}
		    }
		}
	      else
		{
		  for (x = xlo; x < xhi; x++)
		    {
		      if (im->trueColor)
			{
			  /* 2.0.1: work around a gcc bug by being verbose.
			     TBB */
			  int a = chunkBuf[chunkPos++] << 24;
			  int r = chunkBuf[chunkPos++] << 16;
			  int g = chunkBuf[chunkPos++] << 8;
			  int b = chunkBuf[chunkPos++];
			  /* 2.0.11: tpixels */
			  im->tpixels[y][x] = a + r + g + b;
			}
		      else
			{
			  im->pixels[y][x] = chunkBuf[chunkPos++];
			}
		    };
		};
	      /*GD2_DBG(printf("\n")); */
	    };
	  chunkNum++;
	};
    };

  GD2_DBG (printf ("Freeing memory\n"));

  gdFree (chunkBuf);
  gdFree (compBuf);
  gdFree (chunkIdx);

  GD2_DBG (printf ("Done\n"));

  return im;

fail2:
  gdImageDestroy (im);
fail1:
	if (chunkBuf) {
		gdFree (chunkBuf);
	}
	if (compBuf) {
		gdFree (compBuf);
	} 
	if (chunkIdx) {
		gdFree (chunkIdx);
	}
  return 0;
}

BGD_DECLARE(gdImagePtr) gdImageCreateFromGd2Part (FILE * inFile, int srcx, int srcy, int w, int h)
{
  gdImagePtr im;
  gdIOCtx *in = gdNewFileCtx (inFile);

  im = gdImageCreateFromGd2PartCtx (in, srcx, srcy, w, h);

  in->gd_free (in);

  return im;
}

BGD_DECLARE(gdImagePtr) gdImageCreateFromGd2PartPtr (int size, void *data, int srcx, int srcy, int w,
			     int h)
{
  gdImagePtr im;
  gdIOCtx *in = gdNewDynamicCtxEx (size, data, 0);
  im = gdImageCreateFromGd2PartCtx (in, srcx, srcy, w, h);
  in->gd_free (in);
  return im;
}

BGD_DECLARE(gdImagePtr) gdImageCreateFromGd2PartCtx (gdIOCtx * in, int srcx, int srcy, int w, int h)
{
  int scx, scy, ecx, ecy, fsx, fsy;
  int nc, ncx, ncy, cs, cx, cy;
  int x, y, ylo, yhi, xlo, xhi;
  int dstart, dpos;
  int i;
  /* 2.0.12: unsigned is correct; fixes problems with color munging.
     Thanks to Steven Brown. */
  unsigned int ch;
  int vers, fmt;
  t_chunk_info *chunkIdx = NULL;
  unsigned char *chunkBuf = NULL;
  int chunkNum;
  int chunkMax = 0;
  uLongf chunkLen;
  int chunkPos = 0;
  int compMax;
  char *compBuf = NULL;

  gdImagePtr im;

  /* */
  /* The next few lines are basically copied from gd2CreateFromFile */
  /* - we change the file size, so don't want to use the code directly. */
  /*   but we do need to know the file size. */
  /* */
  if (_gd2GetHeader (in, &fsx, &fsy, &cs, &vers, &fmt, &ncx, &ncy, &chunkIdx)
      != 1)
    {
      goto fail1;
    }

  GD2_DBG (printf ("File size is %dx%d\n", fsx, fsy));

  /* This is the difference - make a file based on size of chunks. */
  if (gd2_truecolor (fmt))
    {
      im = gdImageCreateTrueColor (w, h);
    }
  else
    {
      im = gdImageCreate (w, h);
    }
  if (im == NULL)
    {
      goto fail1;
    };

  if (!_gdGetColors (in, im, vers == 2))
    {
      goto fail2;
    }
  GD2_DBG (printf ("Image palette completed: %d colours\n", im->colorsTotal));

  /* Process the header info */
  nc = ncx * ncy;

  if (gd2_compressed (fmt))
    {
      /* Find the maximum compressed chunk size. */
      compMax = 0;
      for (i = 0; (i < nc); i++)
	{
	  if (chunkIdx[i].size > compMax)
	    {
	      compMax = chunkIdx[i].size;
	    };
	};
      compMax++;

      if (im->trueColor)
	{
	  chunkMax = cs * cs * 4;
	}
      else
	{
	  chunkMax = cs * cs;
	}
      chunkBuf = gdCalloc (chunkMax, 1);
			if (!chunkBuf) {
				goto fail2;
			}
      compBuf = gdCalloc (compMax, 1);
			if (!compBuf) {
				goto fail2;
			}

    };

/*      Don't bother with this... */
/*      if ( (ncx != sx / cs) || (ncy != sy / cs)) { */
/*              goto fail2; */
/*      }; */


  /* Work out start/end chunks */
  scx = srcx / cs;
  scy = srcy / cs;
  if (scx < 0)
    {
      scx = 0;
    };
  if (scy < 0)
    {
      scy = 0;
    };

  ecx = (srcx + w) / cs;
  ecy = (srcy + h) / cs;
  if (ecx >= ncx)
    {
      ecx = ncx - 1;
    };
  if (ecy >= ncy)
    {
      ecy = ncy - 1;
    };

  /* Remember file position of image data. */
  dstart = gdTell (in);
  GD2_DBG (printf ("Data starts at %d\n", dstart));

  /* Loop through the chunks. */
  for (cy = scy; (cy <= ecy); cy++)
    {

      ylo = cy * cs;
      yhi = ylo + cs;
      if (yhi > fsy)
	{
	  yhi = fsy;
	};

      for (cx = scx; (cx <= ecx); cx++)
	{

	  xlo = cx * cs;
	  xhi = xlo + cs;
	  if (xhi > fsx)
	    {
	      xhi = fsx;
	    };

	  GD2_DBG (printf
		   ("Processing Chunk (%d, %d), from %d to %d\n", cx, cy, ylo,
		    yhi));

	  if (!gd2_compressed (fmt))
	    {
	      GD2_DBG (printf ("Using raw format data\n"));
	      if (im->trueColor)
		{
		  dpos =
		    (cy * (cs * fsx) * 4 + cx * cs * (yhi - ylo) * 4) +
		    dstart;
		}
	      else
		{
		  dpos = cy * (cs * fsx) + cx * cs * (yhi - ylo) + dstart;
		}
	      /* gd 2.0.11: gdSeek returns TRUE on success, not 0.
	         Longstanding bug. 01/16/03 */
	      if (!gdSeek (in, dpos))
		{
		  fprintf (stderr, "Seek error\n");
		  goto fail2;
		};
	      GD2_DBG (printf
		       ("Reading (%d, %d) from position %d\n", cx, cy,
			dpos - dstart));
	    }
	  else
	    {
	      chunkNum = cx + cy * ncx;

	      chunkLen = chunkMax;
	      if (!_gd2ReadChunk (chunkIdx[chunkNum].offset,
				  compBuf,
				  chunkIdx[chunkNum].size,
				  (char *) chunkBuf, &chunkLen, in))
		{
		  printf ("Error reading comproessed chunk\n");
		  goto fail2;
		};
	      chunkPos = 0;
	      GD2_DBG (printf
		       ("Reading (%d, %d) from chunk %d\n", cx, cy,
			chunkNum));
	    };

	  GD2_DBG (printf
		   ("   into (%d, %d) - (%d, %d)\n", xlo, ylo, xhi, yhi));
	  for (y = ylo; (y < yhi); y++)
	    {

	      for (x = xlo; x < xhi; x++)
		{
		  if (!gd2_compressed (fmt))
		    {
		      if (im->trueColor)
			{
			  if (!gdGetInt ((int *) &ch, in))
			    {
			      ch = 0;
			      /*printf("EOF while reading file\n"); */
			      /*goto fail2; */
			    }
			}
		      else
			{
			  ch = gdGetC (in);
			  if ((int) ch == EOF)
			    {
			      ch = 0;
			      /*printf("EOF while reading file\n"); */
			      /*goto fail2; */
			    }
			}
		    }
		  else
		    {
		      if (im->trueColor)
			{
			  ch = chunkBuf[chunkPos++];
			  ch = (ch << 8) + chunkBuf[chunkPos++];
			  ch = (ch << 8) + chunkBuf[chunkPos++];
			  ch = (ch << 8) + chunkBuf[chunkPos++];
			}
		      else
			{
			  ch = chunkBuf[chunkPos++];
			}
		    };

		  /* Only use a point that is in the image. */
		  if ((x >= srcx) && (x < (srcx + w)) && (x < fsx) && (x >= 0)
		      && (y >= srcy) && (y < (srcy + h)) && (y < fsy)
		      && (y >= 0))
		    {
		      /* 2.0.11: tpixels */
		      if (im->trueColor)
			{
			  im->tpixels[y - srcy][x - srcx] = ch;
			}
		      else
			{
			  im->pixels[y - srcy][x - srcx] = ch;
			}
		    }
		};
	    };
	};
    };

  gdFree (chunkBuf);
  gdFree (compBuf);
  gdFree (chunkIdx);

  return im;

fail2:
  gdImageDestroy (im);
fail1:
	if (chunkBuf) {
	  gdFree (chunkBuf);
	}
	if (compBuf) {
	  gdFree (compBuf);
	}
	if (chunkIdx) {
  	gdFree (chunkIdx);
	}
  return 0;

}

static void
_gd2PutHeader (gdImagePtr im, gdIOCtx * out, int cs, int fmt, int cx, int cy)
{
  int i;

  /* Send the gd2 id, to verify file format. */
  for (i = 0; i < 4; i++)
    {
      gdPutC ((unsigned char) (GD2_ID[i]), out);
    };

  /* */
  /* We put the version info first, so future versions can easily change header info. */
  /* */
  gdPutWord (GD2_VERS, out);
  gdPutWord (im->sx, out);
  gdPutWord (im->sy, out);
  gdPutWord (cs, out);
  gdPutWord (fmt, out);
  gdPutWord (cx, out);
  gdPutWord (cy, out);

}

static void
_gdImageGd2 (gdImagePtr im, gdIOCtx * out, int cs, int fmt)
{
  int ncx, ncy, cx, cy;
  int x, y, ylo, yhi, xlo, xhi;
  int chunkLen;
  int chunkNum = 0;
  char *chunkData = NULL;	/* So we can gdFree it with impunity. */
  char *compData = NULL;	/* So we can gdFree it with impunity. */
  uLongf compLen;
  int idxPos = 0;
  int idxSize;
  t_chunk_info *chunkIdx = NULL;
  int posSave;
  int bytesPerPixel = im->trueColor ? 4 : 1;
  int compMax = 0;

  /*printf("Trying to write GD2 file\n"); */

  /* */
  /* Force fmt to a valid value since we don't return anything. */
  /* */
  if ((fmt != GD2_FMT_RAW) && (fmt != GD2_FMT_COMPRESSED))
    {
      fmt = im->trueColor ? GD2_FMT_TRUECOLOR_COMPRESSED : GD2_FMT_COMPRESSED;
    };
  if (im->trueColor)
    {
      fmt += 2;
    }
  /* */
  /* Make sure chunk size is valid. These are arbitrary values; 64 because it seems */
  /* a little silly to expect performance improvements on a 64x64 bit scale, and  */
  /* 4096 because we buffer one chunk, and a 16MB buffer seems a little large - it may be */
  /* OK for one user, but for another to read it, they require the buffer. */
  /* */
  if (cs == 0)
    {
      cs = GD2_CHUNKSIZE;
    }
  else if (cs < GD2_CHUNKSIZE_MIN)
    {
      cs = GD2_CHUNKSIZE_MIN;
    }
  else if (cs > GD2_CHUNKSIZE_MAX)
    {
      cs = GD2_CHUNKSIZE_MAX;
    };

  /* Work out number of chunks. */
  ncx = im->sx / cs + 1;
  ncy = im->sy / cs + 1;

  /* Write the standard header. */
  _gd2PutHeader (im, out, cs, fmt, ncx, ncy);

  if (gd2_compressed (fmt))
    {
      /* */
      /* Work out size of buffer for compressed data, If CHUNKSIZE is large, */
      /* then these will be large! */
      /* */
      /* The zlib notes say output buffer size should be (input size) * 1.01 * 12 */
      /* - we'll use 1.02 to be paranoid. */
      /* */
      compMax = cs * bytesPerPixel * cs * 1.02 + 12;

      /* */
      /* Allocate the buffers.  */
      /* */
      chunkData = gdCalloc (cs * bytesPerPixel * cs, 1);
			if (!chunkData) {
				goto fail;
			}
      compData = gdCalloc (compMax, 1);
			if (!compData) {
				goto fail;
			}

      /* */
      /* Save the file position of chunk index, and allocate enough space for */
      /* each chunk_info block . */
      /* */
      idxPos = gdTell (out);
      idxSize = ncx * ncy * sizeof (t_chunk_info);
      GD2_DBG (printf ("Index size is %d\n", idxSize));
      gdSeek (out, idxPos + idxSize);

      chunkIdx = gdCalloc (idxSize * sizeof (t_chunk_info), 1);
      if (!chunkIdx) {
        goto fail;
      }
    };

  _gdPutColors (im, out);

  GD2_DBG (printf ("Size: %dx%d\n", im->sx, im->sy));
  GD2_DBG (printf ("Chunks: %dx%d\n", ncx, ncy));

  for (cy = 0; (cy < ncy); cy++)
    {
      for (cx = 0; (cx < ncx); cx++)
	{

	  ylo = cy * cs;
	  yhi = ylo + cs;
	  if (yhi > im->sy)
	    {
	      yhi = im->sy;
	    };

	  GD2_DBG (printf
		   ("Processing Chunk (%dx%d), y from %d to %d\n", cx, cy,
		    ylo, yhi));
	  chunkLen = 0;
	  for (y = ylo; (y < yhi); y++)
	    {

	      /*GD2_DBG(printf("y=%d: ",y)); */

	      xlo = cx * cs;
	      xhi = xlo + cs;
	      if (xhi > im->sx)
		{
		  xhi = im->sx;
		};

	      if (gd2_compressed (fmt))
		{
		  for (x = xlo; x < xhi; x++)
		    {
		      /* 2.0.11: use truecolor pixel array. TBB */
		      /*GD2_DBG(printf("%d...",x)); */
		      if (im->trueColor)
			{
			  int p = im->tpixels[y][x];
			  chunkData[chunkLen++] = gdTrueColorGetAlpha (p);
			  chunkData[chunkLen++] = gdTrueColorGetRed (p);
			  chunkData[chunkLen++] = gdTrueColorGetGreen (p);
			  chunkData[chunkLen++] = gdTrueColorGetBlue (p);
			}
		      else
			{
			  int p = im->pixels[y][x];
			  chunkData[chunkLen++] = p;
			}
		    };
		}
	      else
		{
		  for (x = xlo; x < xhi; x++)
		    {
		      /*GD2_DBG(printf("%d, ",x)); */

		      if (im->trueColor)
			{
			  gdPutInt (im->tpixels[y][x], out);
			}
		      else
			{
			  gdPutC ((unsigned char) im->pixels[y][x], out);
			}
		    };
		};
	      /*GD2_DBG(printf("y=%d done.\n",y)); */
	    };
	  if (gd2_compressed (fmt))
	    {
	      compLen = compMax;
	      if (compress ((unsigned char *)
			    &compData[0], &compLen,
			    (unsigned char *) &chunkData[0],
			    chunkLen) != Z_OK)
		{
		  printf ("Error from compressing\n");
		}
	      else
		{
		  chunkIdx[chunkNum].offset = gdTell (out);
		  chunkIdx[chunkNum++].size = compLen;
		  GD2_DBG (printf
			   ("Chunk %d size %d offset %d\n", chunkNum,
			    chunkIdx[chunkNum - 1].size,
			    chunkIdx[chunkNum - 1].offset));

		  if (gdPutBuf (compData, compLen, out) <= 0)
		    {
			fprintf(stderr, "gd write error\n");
		    };
		};
	    };
	};
    };
  if (gd2_compressed (fmt))
    {
      /* Save the position, write the index, restore position (paranoia). */
      GD2_DBG (printf ("Seeking %d to write index\n", idxPos));
      posSave = gdTell (out);
      gdSeek (out, idxPos);
      GD2_DBG (printf ("Writing index\n"));
      for (x = 0; x < chunkNum; x++)
	{
	  GD2_DBG (printf
		   ("Chunk %d size %d offset %d\n", x, chunkIdx[x].size,
		    chunkIdx[x].offset));
	  gdPutInt (chunkIdx[x].offset, out);
	  gdPutInt (chunkIdx[x].size, out);
	};
      /* We don't use fwrite for *endian reasons. */
      /*fwrite(chunkIdx, sizeof(int)*2, chunkNum, out); */
      gdSeek (out, posSave);
    };

  /*printf("Memory block size is %d\n",gdTell(out)); */
fail:
  GD2_DBG (printf ("Freeing memory\n"));

	if (chunkData) {
		gdFree (chunkData);
	}
	if (compData) {
		gdFree (compData);
	} 
	if (chunkIdx) {
		gdFree (chunkIdx);
	}
  GD2_DBG (printf ("Done\n"));

}

BGD_DECLARE(void) gdImageGd2 (gdImagePtr im, FILE * outFile, int cs, int fmt)
{
  gdIOCtx *out = gdNewFileCtx (outFile);
  _gdImageGd2 (im, out, cs, fmt);
  out->gd_free (out);
}

BGD_DECLARE(void *) gdImageGd2Ptr (gdImagePtr im, int cs, int fmt, int *size)
{
  void *rv;
  gdIOCtx *out = gdNewDynamicCtx (2048, NULL);
  _gdImageGd2 (im, out, cs, fmt);
  rv = gdDPExtractData (out, size);
  out->gd_free (out);
  return rv;
}

#else /* no HAVE_LIBZ */
BGD_DECLARE(gdImagePtr) gdImageCreateFromGd2 (FILE * inFile)
{
  fprintf (stderr, "GD2 support is not available - no libz\n");
  return NULL;
}

BGD_DECLARE(gdImagePtr) gdImageCreateFromGd2Ctx (gdIOCtxPtr in)
{
  fprintf (stderr, "GD2 support is not available - no libz\n");
  return NULL;
}
#endif /* HAVE_LIBZ */
 18278       136468      95030       1193070200  200         0           100640      11  gd_gif_in.c `
#include <stdio.h>
#include <math.h>
#include <string.h>
#include <stdlib.h>
#include "gd.h"

/* Used only when debugging GIF compression code */
/* #define DEBUGGING_ENVARS */

#ifdef DEBUGGING_ENVARS

static int verbose_set = 0;
static int verbose;
#define VERBOSE (verbose_set?verbose:set_verbose())

static int set_verbose(void)
{
 verbose = !!getenv("GIF_VERBOSE");
 verbose_set = 1;
 return(verbose);
}

#else

#define VERBOSE 0

#endif


#define        MAXCOLORMAPSIZE         256

#define        TRUE    1
#define        FALSE   0

#define CM_RED         0
#define CM_GREEN       1
#define CM_BLUE                2

#define        MAX_LWZ_BITS            12

#define INTERLACE              0x40
#define LOCALCOLORMAP  0x80
#define BitSet(byte, bit)      (((byte) & (bit)) == (bit))

#define        ReadOK(file,buffer,len) (gdGetBuf(buffer, len, file) > 0)

#define LM_to_uint(a,b)                        (((b)<<8)|(a))

/* We may eventually want to use this information, but def it out for now */
#if 0
static struct {
       unsigned int    Width;
       unsigned int    Height;
       unsigned char   ColorMap[3][MAXCOLORMAPSIZE];
       unsigned int    BitPixel;
       unsigned int    ColorResolution;
       unsigned int    Background;
       unsigned int    AspectRatio;
} GifScreen;
#endif

#if 0
static struct {
       int     transparent;
       int     delayTime;
       int     inputFlag;
       int     disposal;
} Gif89 = { -1, -1, -1, 0 };
#endif

#define STACK_SIZE ((1<<(MAX_LWZ_BITS))*2)

typedef struct {
	unsigned char    buf[280];
	int              curbit, lastbit, done, last_byte;
} CODE_STATIC_DATA;

typedef struct {
	int fresh;
	int code_size, set_code_size;
	int max_code, max_code_size;
	int firstcode, oldcode;
	int clear_code, end_code;
	int table[2][(1<< MAX_LWZ_BITS)];
	int stack[STACK_SIZE], *sp;
	CODE_STATIC_DATA scd;
} LZW_STATIC_DATA;

static int ReadColorMap (gdIOCtx *fd, int number, unsigned char (*buffer)[256]);
static int DoExtension (gdIOCtx *fd, int label, int *Transparent, int *ZeroDataBlockP);
static int GetDataBlock (gdIOCtx *fd, unsigned char *buf, int *ZeroDataBlockP);
static int GetCode (gdIOCtx *fd, CODE_STATIC_DATA *scd, int code_size, int flag, int *ZeroDataBlockP);
static int LWZReadByte (gdIOCtx *fd, LZW_STATIC_DATA *sd, char flag, int input_code_size, int *ZeroDataBlockP);

static void ReadImage (gdImagePtr im, gdIOCtx *fd, int len, int height, unsigned char (*cmap)[256], int interlace, int *ZeroDataBlockP); /*1.4//, int ignore); */

BGD_DECLARE(gdImagePtr) gdImageCreateFromGif(FILE *fdFile)
{
        gdIOCtx		*fd = gdNewFileCtx(fdFile);
        gdImagePtr    	im = 0;

        im = gdImageCreateFromGifCtx(fd);

        fd->gd_free(fd);

        return im;
}

BGD_DECLARE(gdImagePtr) gdImageCreateFromGifPtr (int size, void *data)
{
  gdImagePtr im;
  gdIOCtx *in = gdNewDynamicCtxEx (size, data, 0);
  im = gdImageCreateFromGifCtx (in);
  in->gd_free (in);
  return im;
}

BGD_DECLARE(gdImagePtr) gdImageCreateFromGifCtx(gdIOCtxPtr fd)
{
       int BitPixel;
#if 0
       int ColorResolution;
       int Background;
       int AspectRatio;
#endif
       int Transparent = (-1);
       unsigned char   buf[16];
       unsigned char   c;
       unsigned char   ColorMap[3][MAXCOLORMAPSIZE];
       unsigned char   localColorMap[3][MAXCOLORMAPSIZE];
       int             imw, imh, screen_width, screen_height;
       int             gif87a, useGlobalColormap;
       int             bitPixel;
       int	       i;
       /*1.4//int             imageCount = 0; */
       /* 2.0.28: threadsafe storage */
       int ZeroDataBlock = FALSE;
       int haveGlobalColormap;

       gdImagePtr im = 0;
       if (! ReadOK(fd,buf,6)) {
		return 0;
	}
       if (strncmp((char *)buf,"GIF",3) != 0) {
		return 0;
	}
		if (memcmp((char *)buf+3, "87a", 3) == 0) {
			gif87a = 1;
		} else if (memcmp((char *)buf+3, "89a", 3) == 0) {
			gif87a = 0;
		} else {
			return 0;
		}

			 if (! ReadOK(fd,buf,7)) {
				 return 0;
			 }

       BitPixel        = 2<<(buf[4]&0x07);
#if 0
       ColorResolution = (int) (((buf[4]&0x70)>>3)+1);
       Background      = buf[5];
       AspectRatio     = buf[6];
#endif
			screen_width = imw = LM_to_uint(buf[0],buf[1]);
			screen_height = imh = LM_to_uint(buf[2],buf[3]);

			haveGlobalColormap = BitSet(buf[4], LOCALCOLORMAP);    /* Global Colormap */
			if (haveGlobalColormap) {
				if (ReadColorMap(fd, BitPixel, ColorMap)) {
					return 0;
				}
			}
       for (;;) {
							int top, left;
							int width, height;

               if (! ReadOK(fd,&c,1)) {
                       return 0;
               }
               if (c == ';') {         /* GIF terminator */
								goto terminated;
				       }

               if (c == '!') {         /* Extension */
                       if (! ReadOK(fd,&c,1)) {
                               return 0;
                       }
                       DoExtension(fd, c, &Transparent, &ZeroDataBlock);
                       continue;
               }

               if (c != ',') {         /* Not a valid start character */
                       continue;
               }

               /*1.4//++imageCount; */

               if (! ReadOK(fd,buf,9)) {
	               return 0;
               }

               useGlobalColormap = ! BitSet(buf[8], LOCALCOLORMAP);

							bitPixel = 1<<((buf[8]&0x07)+1);
							left = LM_to_uint(buf[0], buf[1]);
							top = LM_to_uint(buf[2], buf[3]);
							width = LM_to_uint(buf[4], buf[5]);
							height = LM_to_uint(buf[6], buf[7]);

							if (left + width > screen_width || top + height > screen_height) {
						 		if (VERBOSE) {
									printf("Frame is not confined to screen dimension.\n");
								}
								return 0;
							}

			   if (!(im = gdImageCreate(width, height))) {
				   return 0;
			   }
			   im->interlace = BitSet(buf[8], INTERLACE);
               if (!useGlobalColormap) {
                       if (ReadColorMap(fd, bitPixel, localColorMap)) { 
													gdImageDestroy(im);
													return 0;
                       }
                       ReadImage(im, fd, width, height, localColorMap, 
                                 BitSet(buf[8], INTERLACE), &ZeroDataBlock); 
               } else {
							 				if (!haveGlobalColormap) {
												gdImageDestroy(im);
												return 0;
											}
                       ReadImage(im, fd, width, height,
                                 ColorMap, 
                                 BitSet(buf[8], INTERLACE), &ZeroDataBlock);
               }
               if (Transparent != (-1)) {
                       gdImageColorTransparent(im, Transparent);
               }	   
	       goto terminated;
       }

terminated:
       /* Terminator before any image was declared! */
       if (!im) {
		return 0;
       }
	   if (!im->colorsTotal) {
		   gdImageDestroy(im);
		   return 0;
	   }
       /* Check for open colors at the end, so
          we can reduce colorsTotal and ultimately
          BitsPerPixel */
       for (i=((im->colorsTotal-1)); (i>=0); i--) {
		if (im->open[i]) {
                	im->colorsTotal--;
                } else {
                	break;
                }
       } 
       return im;
}

static int
ReadColorMap(gdIOCtx *fd, int number, unsigned char (*buffer)[256])
{
       int             i;
       unsigned char   rgb[3];


       for (i = 0; i < number; ++i) {
               if (! ReadOK(fd, rgb, sizeof(rgb))) {
                       return TRUE;
               }
               buffer[CM_RED][i] = rgb[0] ;
               buffer[CM_GREEN][i] = rgb[1] ;
               buffer[CM_BLUE][i] = rgb[2] ;
       }


       return FALSE;
}

static int
DoExtension(gdIOCtx *fd, int label, int *Transparent, int *ZeroDataBlockP)
{
       unsigned char     buf[256];

       switch (label) {
       case 0xf9:              /* Graphic Control Extension */
		memset(buf, 0, 4); /* initialize a few bytes in the case the next function fails */
               (void) GetDataBlock(fd, (unsigned char*) buf, ZeroDataBlockP);
#if 0
               Gif89.disposal    = (buf[0] >> 2) & 0x7;
               Gif89.inputFlag   = (buf[0] >> 1) & 0x1;
               Gif89.delayTime   = LM_to_uint(buf[1],buf[2]);
#endif
               if ((buf[0] & 0x1) != 0)
                       *Transparent = buf[3];

               while (GetDataBlock(fd, (unsigned char*) buf, ZeroDataBlockP) > 0);
               return FALSE;
       default:
               break;
       }
       while (GetDataBlock(fd, (unsigned char*) buf, ZeroDataBlockP) > 0)
               ;

       return FALSE;
}

static int
GetDataBlock_(gdIOCtx *fd, unsigned char *buf, int *ZeroDataBlockP)
{
       unsigned char   count;

       if (! ReadOK(fd,&count,1)) {
               return -1;
       }

       *ZeroDataBlockP = count == 0;

       if ((count != 0) && (! ReadOK(fd, buf, count))) {
               return -1;
       }

       return count;
}

static int
GetDataBlock(gdIOCtx *fd, unsigned char *buf, int *ZeroDataBlockP)
{
 int rv;
 int i;

 rv = GetDataBlock_(fd,buf, ZeroDataBlockP);
 if (VERBOSE)
  { printf("[GetDataBlock returning %d",rv);
    if (rv > 0)
     { printf(":");
       for (i=0;i<rv;i++) printf(" %02x",buf[i]);
     }
    printf("]\n");
  }
 return(rv);
}

static int
GetCode_(gdIOCtx *fd, CODE_STATIC_DATA *scd, int code_size, int flag, int *ZeroDataBlockP)
{
       int           i, j, ret;
       unsigned char count;

       if (flag) {
               scd->curbit = 0;
               scd->lastbit = 0;
               scd->last_byte = 0;
               scd->done = FALSE;
               return 0;
       }

       if ( (scd->curbit + code_size) >= scd->lastbit) {
               if (scd->done) {
                       if (scd->curbit >= scd->lastbit) {
                                /* Oh well */
                       }                        
                       return -1;
               }
               scd->buf[0] = scd->buf[scd->last_byte-2];
               scd->buf[1] = scd->buf[scd->last_byte-1];

               if ((count = GetDataBlock(fd, &scd->buf[2], ZeroDataBlockP)) <= 0)
                       scd->done = TRUE;

               scd->last_byte = 2 + count;
               scd->curbit = (scd->curbit - scd->lastbit) + 16;
               scd->lastbit = (2+count)*8 ;
       }

       ret = 0;
       for (i = scd->curbit, j = 0; j < code_size; ++i, ++j)
               ret |= ((scd->buf[ i / 8 ] & (1 << (i % 8))) != 0) << j;

       scd->curbit += code_size;
       return ret;
}

static int
GetCode(gdIOCtx *fd, CODE_STATIC_DATA *scd, int code_size, int flag, int *ZeroDataBlockP)
{
 int rv;

 rv = GetCode_(fd, scd, code_size,flag, ZeroDataBlockP);
 if (VERBOSE) printf("[GetCode(,%d,%d) returning %d]\n",code_size,flag,rv);
 return(rv);
}

static int
LWZReadByte_(gdIOCtx *fd, LZW_STATIC_DATA *sd, char flag, int input_code_size, int *ZeroDataBlockP)
{
       int code, incode, i;

       if (flag) {
               sd->set_code_size = input_code_size;
               sd->code_size = sd->set_code_size+1;
               sd->clear_code = 1 << sd->set_code_size ;
               sd->end_code = sd->clear_code + 1;
               sd->max_code_size = 2*sd->clear_code;
               sd->max_code = sd->clear_code+2;

               GetCode(fd, &sd->scd, 0, TRUE, ZeroDataBlockP);
               
               sd->fresh = TRUE;

               for (i = 0; i < sd->clear_code; ++i) {
                       sd->table[0][i] = 0;
                       sd->table[1][i] = i;
               }
               for (; i < (1<<MAX_LWZ_BITS); ++i)
                       sd->table[0][i] = sd->table[1][0] = 0;

               sd->sp = sd->stack;

               return 0;
       } else if (sd->fresh) {
               sd->fresh = FALSE;
               do {
                       sd->firstcode = sd->oldcode =
                               GetCode(fd, &sd->scd, sd->code_size, FALSE, ZeroDataBlockP);
               } while (sd->firstcode == sd->clear_code);
               return sd->firstcode;
       }

       if (sd->sp > sd->stack)
               return *--sd->sp;

       while ((code = GetCode(fd, &sd->scd, sd->code_size, FALSE, ZeroDataBlockP)) >= 0) {
               if (code == sd->clear_code) {
                       for (i = 0; i < sd->clear_code; ++i) {
                               sd->table[0][i] = 0;
                               sd->table[1][i] = i;
                       }
                       for (; i < (1<<MAX_LWZ_BITS); ++i)
                               sd->table[0][i] = sd->table[1][i] = 0;
                       sd->code_size = sd->set_code_size+1;
                       sd->max_code_size = 2*sd->clear_code;
                       sd->max_code = sd->clear_code+2;
                       sd->sp = sd->stack;
                       sd->firstcode = sd->oldcode =
                                       GetCode(fd, &sd->scd, sd->code_size, FALSE, ZeroDataBlockP);
                       return sd->firstcode;
               } else if (code == sd->end_code) {
                       int             count;
                       unsigned char   buf[260];

                       if (*ZeroDataBlockP)
                               return -2;

                       while ((count = GetDataBlock(fd, buf, ZeroDataBlockP)) > 0)
                               ;

                       if (count != 0)
                       return -2;
               }

               incode = code;

	       if (sd->sp == (sd->stack + STACK_SIZE)) {
		       /* Bad compressed data stream */
		       return -1;
	       }

               if (code >= sd->max_code) {
                       *sd->sp++ = sd->firstcode;
                       code = sd->oldcode;
               }

               while (code >= sd->clear_code) {
		       if (sd->sp == (sd->stack + STACK_SIZE)) {
			       /* Bad compressed data stream */
			       return -1;
		       }
                       *sd->sp++ = sd->table[1][code];
                       if (code == sd->table[0][code]) {
                               /* Oh well */
                       }
                       code = sd->table[0][code];
               }

               *sd->sp++ = sd->firstcode = sd->table[1][code];

               if ((code = sd->max_code) <(1<<MAX_LWZ_BITS)) {
                       sd->table[0][code] = sd->oldcode;
                       sd->table[1][code] = sd->firstcode;
                       ++sd->max_code;
                       if ((sd->max_code >= sd->max_code_size) &&
                               (sd->max_code_size < (1<<MAX_LWZ_BITS))) {
                               sd->max_code_size *= 2;
                               ++sd->code_size;
                       }
               }

               sd->oldcode = incode;

               if (sd->sp > sd->stack)
                       return *--sd->sp;
       }
       return code;
}

static int
LWZReadByte(gdIOCtx *fd, LZW_STATIC_DATA *sd, char flag, int input_code_size, int *ZeroDataBlockP)
{
 int rv;

 rv = LWZReadByte_(fd, sd, flag, input_code_size, ZeroDataBlockP);
 if (VERBOSE) printf("[LWZReadByte(,%d,%d) returning %d]\n",flag,input_code_size,rv);
 return(rv);
}

static void
ReadImage(gdImagePtr im, gdIOCtx *fd, int len, int height, unsigned char (*cmap)[256], int interlace, int *ZeroDataBlockP) /*1.4//, int ignore) */
{
       unsigned char   c;      
       int             v;
       int             xpos = 0, ypos = 0, pass = 0;
       int i;
       LZW_STATIC_DATA sd;

       /*
       **  Initialize the Compression routines
       */
       if (! ReadOK(fd,&c,1)) {
               return; 
       }

		if (c > MAX_LWZ_BITS) {
			return;	
		}

       /* Stash the color map into the image */
       for (i=0; (i<gdMaxColors); i++) {
               im->red[i] = cmap[CM_RED][i];	
               im->green[i] = cmap[CM_GREEN][i];	
               im->blue[i] = cmap[CM_BLUE][i];	
               im->open[i] = 1;
       }
       /* Many (perhaps most) of these colors will remain marked open. */
       im->colorsTotal = gdMaxColors;
       if (LWZReadByte(fd, &sd, TRUE, c, ZeroDataBlockP) < 0) {
               return;
       }

       /*
       **  If this is an "uninteresting picture" ignore it.
       **  REMOVED For 1.4
       */
       /*if (ignore) { */
       /*        while (LWZReadByte(fd, &sd, FALSE, c) >= 0) */
       /*                ; */
       /*        return; */
       /*} */

       while ((v = LWZReadByte(fd, &sd, FALSE, c, ZeroDataBlockP)) >= 0 ) {
               if (v >= gdMaxColors) {
                       v = 0;
               }

               /* This how we recognize which colors are actually used. */
               if (im->open[v]) {
                       im->open[v] = 0;
               }
               gdImageSetPixel(im, xpos, ypos, v);
               ++xpos;
               if (xpos == len) {
                       xpos = 0;
                       if (interlace) {
                               switch (pass) {
                               case 0:
                               case 1:
                                       ypos += 8; break;
                               case 2:
                                       ypos += 4; break;
                               case 3:
                                       ypos += 2; break;
                               }

                               if (ypos >= height) {
                                       ++pass;
                                       switch (pass) {
                                       case 1:
                                               ypos = 4; break;
                                       case 2:
                                               ypos = 2; break;
                                       case 3:
                                               ypos = 1; break;
                                       default:
                                               goto fini;
                                       }
                               }
                       } else {
                               ++ypos;
                       }
               }
               if (ypos >= height)
                       break;
       }

fini:
       if (LWZReadByte(fd, &sd, FALSE, c, ZeroDataBlockP) >=0) {
               /* Ignore extra */
       }
}


31573       168144      118088      1193070200  200         0           100640      12  gd_gif_out.c`
#include <stdio.h>
#include <math.h>
#include <string.h>
#include <stdlib.h>
#include "gd.h"
#include "gdhelpers.h"

/* Code drawn from ppmtogif.c, from the pbmplus package
**
** Based on GIFENCOD by David Rowley <mgardi@watdscu.waterloo.edu>. A
** Lempel-Zim compression based on "compress".
**
** Modified by Marcel Wijkstra <wijkstra@fwi.uva.nl>
**
** Copyright (C) 1989 by Jef Poskanzer.
**
** Permission to use, copy, modify, and distribute this software and its
** documentation for any purpose and without fee is hereby granted, provided
** that the above copyright notice appear in all copies and that both that
** copyright notice and this permission notice appear in supporting
** documentation.  This software is provided "as is" without express or
** implied warranty.
**
** The Graphics Interchange Format(c) is the Copyright property of
** CompuServe Incorporated.  GIF(sm) is a Service Mark property of
** CompuServe Incorporated.
*/

/*
 * a code_int must be able to hold 2**GIFBITS values of type int, and also -1
 */
typedef int             code_int;

#ifdef SIGNED_COMPARE_SLOW
typedef unsigned long int count_int;
typedef unsigned short int count_short;
#else /*SIGNED_COMPARE_SLOW*/
typedef long int          count_int;
#endif /*SIGNED_COMPARE_SLOW*/

/* 2.0.28: threadsafe */

#define maxbits GIFBITS

/* should NEVER generate this code */
#define maxmaxcode ((code_int)1 << GIFBITS)

#define HSIZE  5003            /* 80% occupancy */
#define hsize HSIZE            /* Apparently invariant, left over from 
					compress */

typedef struct {
	int Width, Height;
	int curx, cury;
	long CountDown;
	int Pass;
	int Interlace;
        int n_bits;                        /* number of bits/code */
        code_int maxcode;                  /* maximum code, given n_bits */
        count_int htab [HSIZE];
        unsigned short codetab [HSIZE];
	code_int free_ent;                  /* first unused entry */
	/*
	 * block compression parameters -- after all codes are used up,
	 * and compression rate changes, start over.
	 */
	int clear_flg;
	int offset;
	long int in_count;            /* length of input */
	long int out_count;           /* # of codes output (for debugging) */

	int g_init_bits;
	gdIOCtx * g_outfile;

	int ClearCode;
	int EOFCode;
	unsigned long cur_accum;
	int cur_bits;
        /*
         * Number of characters so far in this 'packet'
         */
        int a_count;
        /*
         * Define the storage for the packet accumulator
         */
        char accum[ 256 ];
} GifCtx;

static int gifPutWord(int w, gdIOCtx *out);
static int colorstobpp(int colors);
static void BumpPixel (GifCtx *ctx);
static int GIFNextPixel (gdImagePtr im, GifCtx *ctx);
static void GIFEncode (gdIOCtxPtr fp, int GWidth, int GHeight, int GInterlace, int Background, int Transparent, int BitsPerPixel, int *Red, int *Green, int *Blue, gdImagePtr im);
static void GIFAnimEncode (gdIOCtxPtr fp, int IWidth, int IHeight, int LeftOfs, int TopOfs, int GInterlace, int Transparent, int Delay, int Disposal, int BitsPerPixel, int *Red, int *Green, int *Blue, gdImagePtr im);
static void compress (int init_bits, gdIOCtx *outfile, gdImagePtr im, GifCtx *ctx);
static void output (code_int code, GifCtx *ctx);
static void cl_block (GifCtx *ctx);
static void cl_hash (register count_int chsize, GifCtx *ctx);
static void char_init (GifCtx *ctx);
static void char_out (int c, GifCtx *ctx);
static void flush_char (GifCtx *ctx);
BGD_DECLARE(void *) gdImageGifPtr (gdImagePtr im, int *size)
{
  void *rv;
  gdIOCtx *out = gdNewDynamicCtx (2048, NULL);
  gdImageGifCtx (im, out);
  rv = gdDPExtractData (out, size);
  out->gd_free (out);
  return rv;
}

BGD_DECLARE(void) gdImageGif (gdImagePtr im, FILE * outFile)
{
  gdIOCtx *out = gdNewFileCtx (outFile);
  gdImageGifCtx (im, out);
  out->gd_free (out);
}

BGD_DECLARE(void) gdImageGifCtx(gdImagePtr im, gdIOCtxPtr out)
{
	gdImagePtr pim = 0, tim = im;
	int interlace, transparent, BitsPerPixel;
	interlace = im->interlace;
	transparent = im->transparent;
	if (im->trueColor) {
		/* Expensive, but the only way that produces an
			acceptable result: mix down to a palette
			based temporary image. */
		pim = gdImageCreatePaletteFromTrueColor(im, 1, 256);
		if (!pim) {
			return;
		}
		tim = pim; 
	}
	BitsPerPixel = colorstobpp(tim->colorsTotal);
	/* All set, let's do it. */
	GIFEncode(
		out, tim->sx, tim->sy, interlace, 0, tim->transparent, BitsPerPixel,
		tim->red, tim->green, tim->blue, tim);
	if (pim) {
		/* Destroy palette based temporary image. */
		gdImageDestroy(	pim);
	}
}

BGD_DECLARE(void *) gdImageGifAnimBeginPtr (gdImagePtr im, int *size, int GlobalCM, int Loops)
{
  void *rv;
  gdIOCtx *out = gdNewDynamicCtx (2048, NULL);
  gdImageGifAnimBeginCtx(im, out, GlobalCM, Loops);
  rv = gdDPExtractData (out, size);
  out->gd_free (out);
  return rv;
}

BGD_DECLARE(void) gdImageGifAnimBegin (gdImagePtr im, FILE *outFile, int GlobalCM, int Loops)
{
  gdIOCtx *out = gdNewFileCtx (outFile);
  gdImageGifAnimBeginCtx (im, out, GlobalCM, Loops);
  out->gd_free (out);
}

BGD_DECLARE(void) gdImageGifAnimBeginCtx(gdImagePtr im, gdIOCtxPtr out, int GlobalCM, int Loops)
{
	int B;
	int RWidth, RHeight;
	int Resolution;
	int ColorMapSize;
	int BitsPerPixel;
	int Background = 0;
	int i;

	/* Default is to use global color map */
	if (GlobalCM < 0) GlobalCM = 1;

	BitsPerPixel = colorstobpp(im->colorsTotal);
        ColorMapSize = 1 << BitsPerPixel;

        RWidth = im->sx;
        RHeight = im->sy;

        Resolution = BitsPerPixel;

        /*
         * Write the Magic header
         */
        gdPutBuf("GIF89a", 6, out );

        /*
         * Write out the screen width and height
         */
        gifPutWord( RWidth, out );
        gifPutWord( RHeight, out );

        /*
         * Indicate that there is a global colour map
         */
        B = GlobalCM ? 0x80 : 0;

        /*
         * OR in the resolution
         */
        B |= (Resolution - 1) << 5;

        /*
         * OR in the Bits per Pixel
         */
        B |= (BitsPerPixel - 1);

        /*
         * Write it out
         */
        gdPutC( B, out );

        /*
         * Write out the Background colour
         */
        gdPutC( Background, out );

        /*
         * Byte of 0's (future expansion)
         */
        gdPutC( 0, out );

        /*
         * Write out the Global Colour Map
         */
	if (GlobalCM)
		for( i=0; i<ColorMapSize; ++i ) {
			gdPutC( im->red[i], out );
			gdPutC( im->green[i], out );
			gdPutC( im->blue[i], out );
		}

	if (Loops >= 0) {
		gdPutBuf( "!\377\13NETSCAPE2.0\3\1", 16, out );
		gifPutWord( Loops, out );
		gdPutC( 0, out );
	}
}

BGD_DECLARE(void *) gdImageGifAnimAddPtr (gdImagePtr im, int *size, int LocalCM, int LeftOfs, int TopOfs, int Delay, int Disposal, gdImagePtr previm)
{
  void *rv;
  gdIOCtx *out = gdNewDynamicCtx (2048, NULL);
  gdImageGifAnimAddCtx(im, out, LocalCM, LeftOfs, TopOfs, Delay, Disposal, previm);
  rv = gdDPExtractData (out, size);
  out->gd_free (out);
  return rv;
}

BGD_DECLARE(void) gdImageGifAnimAdd (gdImagePtr im, FILE * outFile, int LocalCM, int LeftOfs, int TopOfs, int Delay, int Disposal, gdImagePtr previm)
{
  gdIOCtx *out = gdNewFileCtx (outFile);
  gdImageGifAnimAddCtx (im, out, LocalCM, LeftOfs, TopOfs, Delay, Disposal, previm);
  out->gd_free (out);
}

static int
comparewithmap (gdImagePtr im1, gdImagePtr im2, int c1, int c2, int *colorMap)
{
	if (!colorMap)
		return c1 == c2;
	if (-2 != colorMap[c1])
		return colorMap[c1] == c2;
	return (colorMap[c1] = gdImageColorExactAlpha (im2, im1->red[c1], im1->green[c1], im1->blue[c1], im1->alpha[c1]))
	       == c2;
}

BGD_DECLARE(void) gdImageGifAnimAddCtx(gdImagePtr im, gdIOCtxPtr out, int LocalCM, int LeftOfs, int TopOfs, int Delay, int Disposal, gdImagePtr previm)
{
	gdImagePtr pim = 0, tim = im;
	int interlace, transparent, BitsPerPixel;
	interlace = im->interlace;
	transparent = im->transparent;

	/* Default is no local color map */
	if (LocalCM < 0) LocalCM = 0;
	if (im->trueColor) {
		/* Expensive, but the only way that produces an
			acceptable result: mix down to a palette
			based temporary image. */
		pim = gdImageCreatePaletteFromTrueColor(im, 1, 256);
		if (!pim) {
			return;
		}
		tim = pim; 
	}
	if (previm) {
		/* create optimized animation.  Compare this image to
		   the previous image and crop the temporary copy of
		   current image to include only changed rectangular
		   area.  Also replace unchanged pixels inside this
		   area with transparent color.  Transparent color
		   needs to be already allocated!
		   Preconditions:
		   TopOfs, LeftOfs are assumed 0

		   Images should be of same size.  If not, a temporary
		   copy is made with the same size as previous image.
		   
		*/
		gdImagePtr prev_pim = 0, prev_tim = previm;
		int x, y;
		int min_x = 0;
		int min_y = tim->sy;
		int max_x = 0;
		int max_y = 0;
		int colorMap[256];

		if (previm->trueColor) {
			prev_pim = gdImageCreatePaletteFromTrueColor(previm, 1, 256);
			if (!prev_pim) {
				return;
			}
			prev_tim = prev_pim; 
		}
		for (x = 0; x < 256; ++x)
			colorMap[x] = -2;

		/* First find bounding box of changed areas. */
		/* first find the top changed row */
		for (y = 0; y < tim->sy; ++y)
			for (x = 0; x < tim->sx; ++x)
				if (!comparewithmap(prev_tim, tim,
						    prev_tim->pixels[y][x],
						    tim->pixels[y][x],
						    colorMap)) {
					min_y = max_y = y;
					min_x = max_x = x;
					goto break_top;
				}
	break_top:
		if (tim->sy == min_y) {
			/* No changes in this frame!! Encode empty image. */
			transparent = 0;
			min_x = min_y = 1;
			max_x = max_y = 0;
		} else {
			/* Then the bottom row */
			for (y = tim->sy - 1; y > min_y; --y)
				for (x = 0; x < tim->sx; ++x)
					if (!comparewithmap
					    (prev_tim, tim,
					     prev_tim->pixels[y][x],
					     tim->pixels[y][x],
					     colorMap)) {
						max_y = y;
						if (x < min_x) min_x = x;
						if (x > max_x) max_x = x;
						goto break_bot;
					}
		break_bot:
			/* left side */
			for (x = 0; x < min_x; ++x)
				for (y = min_y; y <= max_y; ++y)
					if (!comparewithmap
					    (prev_tim, tim,
					     prev_tim->pixels[y][x],
					     tim->pixels[y][x],
					     colorMap)) {
						min_x = x;
						goto break_left;
					}
		break_left:
			/* right side */
			for (x = tim->sx-1; x > max_x; --x)
				for (y = min_y; y <= max_y; ++y)
					if (!comparewithmap
					    (prev_tim, tim,
					     prev_tim->pixels[y][x],
					     tim->pixels[y][x],
					     colorMap)) {
						max_x = x;
						goto break_right;
					}
		break_right:
			;
		}

		LeftOfs = min_x;
		TopOfs = min_y;
		Disposal = 1;

		/* Make a copy of the image with the new offsets.
		   But only if necessary. */
		if (min_x != 0 || max_x != tim->sx-1
		    || min_y != 0 || max_y != tim->sy-1
		    || transparent >= 0) {
			gdImagePtr pim2
				= gdImageCreate(max_x-min_x+1, max_y-min_y+1);
			if (!pim2) {
				if (prev_pim)
					gdImageDestroy (prev_pim);
				goto fail_end;
			}
			gdImagePaletteCopy (pim2, LocalCM ? tim : prev_tim);
			gdImageCopy (pim2, tim, 0, 0, min_x, min_y,
				     max_x-min_x+1, max_y-min_y+1);
			if (pim)
				gdImageDestroy (pim);
			tim = pim = pim2;
		}

		/* now let's compare pixels for transparent
		   optimization.  But only if transparent is set. */
		if (transparent >= 0) {
			for (y = 0; y < tim->sy; ++y)
				for (x = 0; x < tim->sx; ++x)
					if (comparewithmap
					    (prev_tim, tim,
					     prev_tim->pixels[min_y+y][min_x+x],
					     tim->pixels[y][x], 0)) {
						gdImageSetPixel (tim, x, y,
								 transparent);
						break;
					}
		}
		if (prev_pim)
			gdImageDestroy (prev_pim);
	}
	BitsPerPixel = colorstobpp(tim->colorsTotal);
	/* All set, let's do it. */
	GIFAnimEncode(
		out, tim->sx, tim->sy, LeftOfs, TopOfs, interlace, transparent,
		Delay, Disposal, BitsPerPixel,
		LocalCM ? tim->red : 0, tim->green, tim->blue, tim);
 fail_end:
	if (pim) {
		/* Destroy palette based temporary image. */
		gdImageDestroy(	pim);
	}
}

BGD_DECLARE(void) gdImageGifAnimEnd(FILE *outFile)
{
#if 1
  putc (';', outFile);
#else
  gdIOCtx *out = gdNewFileCtx (outFile);
  gdImageGifAnimEndCtx (out);
  out->gd_free (out);
#endif
}

BGD_DECLARE(void *) gdImageGifAnimEndPtr (int *size)
{
  char *rv = (char *) gdMalloc (1);
  if (!rv) {
    return 0;
  }
  *rv = ';';
  *size = 1;
  return (void *)rv;
}

BGD_DECLARE(void) gdImageGifAnimEndCtx(gdIOCtx *out)
{
	/*
	 * Write the GIF file terminator
	 */
	gdPutC( ';', out );
}

static int
colorstobpp(int colors)
{
    int bpp = 0;

    if ( colors <= 2 )
        bpp = 1;
    else if ( colors <= 4 )
        bpp = 2;
    else if ( colors <= 8 )
        bpp = 3;
    else if ( colors <= 16 )
        bpp = 4;
    else if ( colors <= 32 )
        bpp = 5;
    else if ( colors <= 64 )
        bpp = 6;
    else if ( colors <= 128 )
        bpp = 7;
    else if ( colors <= 256 )
        bpp = 8;
    return bpp;
    }

/*****************************************************************************
 *
 * GIFENCODE.C    - GIF Image compression interface
 *
 * GIFEncode( FName, GHeight, GWidth, GInterlace, Background, Transparent,
 *            BitsPerPixel, Red, Green, Blue, gdImagePtr )
 *
 *****************************************************************************/

#define TRUE 1
#define FALSE 0
/*
 * Bump the 'curx' and 'cury' to point to the next pixel
 */
static void
BumpPixel(GifCtx *ctx)
{
        /*
         * Bump the current X position
         */
        ++(ctx->curx);

        /*
         * If we are at the end of a scan line, set curx back to the beginning
         * If we are interlaced, bump the cury to the appropriate spot,
         * otherwise, just increment it.
         */
        if( ctx->curx == ctx->Width ) {
                ctx->curx = 0;

                if( !ctx->Interlace )
                        ++(ctx->cury);
                else {
                     switch( ctx->Pass ) {

                       case 0:
                          ctx->cury += 8;
                          if( ctx->cury >= ctx->Height ) {
                                ++(ctx->Pass);
                                ctx->cury = 4;
                          }
                          break;

                       case 1:
                          ctx->cury += 8;
                          if( ctx->cury >= ctx->Height ) {
                                ++(ctx->Pass);
                                ctx->cury = 2;
                          }
                          break;

                       case 2:
                          ctx->cury += 4;
                          if( ctx->cury >= ctx->Height ) {
                             ++(ctx->Pass);
                             ctx->cury = 1;
                          }
                          break;

                       case 3:
                          ctx->cury += 2;
                          break;
                        }
                }
        }
}

/*
 * Return the next pixel from the image
 */
static int
GIFNextPixel(gdImagePtr im, GifCtx *ctx)
{
        int r;

        if( ctx->CountDown == 0 )
                return EOF;

        --(ctx->CountDown);

        r = gdImageGetPixel(im, ctx->curx, ctx->cury);

        BumpPixel(ctx);

        return r;
}

/* public */

static void
GIFEncode(gdIOCtxPtr fp, int GWidth, int GHeight, int GInterlace, int Background, int Transparent, int BitsPerPixel, int *Red, int *Green, int *Blue, gdImagePtr im)
{
        int B;
        int RWidth, RHeight;
        int LeftOfs, TopOfs;
        int Resolution;
        int ColorMapSize;
        int InitCodeSize;
        int i;
	GifCtx ctx;
        ctx.Interlace = GInterlace;
	ctx.in_count = 1;
	memset(&ctx, 0, sizeof(ctx));
        ColorMapSize = 1 << BitsPerPixel;

        RWidth = ctx.Width = GWidth;
        RHeight = ctx.Height = GHeight;
        LeftOfs = TopOfs = 0;

        Resolution = BitsPerPixel;

        /*
         * Calculate number of bits we are expecting
         */
        ctx.CountDown = (long)ctx.Width * (long)ctx.Height;

        /*
         * Indicate which pass we are on (if interlace)
         */
        ctx.Pass = 0;

        /*
         * The initial code size
         */
        if( BitsPerPixel <= 1 )
                InitCodeSize = 2;
        else
                InitCodeSize = BitsPerPixel;

        /*
         * Set up the current x and y position
         */
        ctx.curx = ctx.cury = 0;

        /*
         * Write the Magic header
         */
        gdPutBuf(Transparent < 0 ? "GIF87a" : "GIF89a", 6, fp );

        /*
         * Write out the screen width and height
         */
        gifPutWord( RWidth, fp );
        gifPutWord( RHeight, fp );

        /*
         * Indicate that there is a global colour map
         */
        B = 0x80;       /* Yes, there is a color map */

        /*
         * OR in the resolution
         */
        B |= (Resolution - 1) << 5;

        /*
         * OR in the Bits per Pixel
         */
        B |= (BitsPerPixel - 1);

        /*
         * Write it out
         */
        gdPutC( B, fp );

        /*
         * Write out the Background colour
         */
        gdPutC( Background, fp );

        /*
         * Byte of 0's (future expansion)
         */
        gdPutC( 0, fp );

        /*
         * Write out the Global Colour Map
         */
        for( i=0; i<ColorMapSize; ++i ) {
                gdPutC( Red[i], fp );
                gdPutC( Green[i], fp );
                gdPutC( Blue[i], fp );
        }

	/*
	 * Write out extension for transparent colour index, if necessary.
	 */
	if ( Transparent >= 0 ) {
	    gdPutC( '!', fp );
	    gdPutC( 0xf9, fp );
	    gdPutC( 4, fp );
	    gdPutC( 1, fp );
	    gdPutC( 0, fp );
	    gdPutC( 0, fp );
	    gdPutC( (unsigned char) Transparent, fp );
	    gdPutC( 0, fp );
	}

        /*
         * Write an Image separator
         */
        gdPutC( ',', fp );

        /*
         * Write the Image header
         */

        gifPutWord( LeftOfs, fp );
        gifPutWord( TopOfs, fp );
        gifPutWord( ctx.Width, fp );
        gifPutWord( ctx.Height, fp );

        /*
         * Write out whether or not the image is interlaced
         */
        if( ctx.Interlace )
                gdPutC( 0x40, fp );
        else
                gdPutC( 0x00, fp );

        /*
         * Write out the initial code size
         */
        gdPutC( InitCodeSize, fp );

        /*
         * Go and actually compress the data
         */
        compress( InitCodeSize+1, fp, im, &ctx );

        /*
         * Write out a Zero-length packet (to end the series)
         */
        gdPutC( 0, fp );

        /*
         * Write the GIF file terminator
         */
        gdPutC( ';', fp );
}

static void
GIFAnimEncode(gdIOCtxPtr fp, int IWidth, int IHeight, int LeftOfs, int TopOfs, int GInterlace, int Transparent, int Delay, int Disposal, int BitsPerPixel, int *Red, int *Green, int *Blue, gdImagePtr im)
{
	int B;
        int ColorMapSize;
        int InitCodeSize;
        int i;
	GifCtx ctx;
        ctx.Interlace = GInterlace;
	ctx.in_count = 1;
	memset(&ctx, 0, sizeof(ctx));
        ColorMapSize = 1 << BitsPerPixel;

	if (LeftOfs < 0) LeftOfs = 0;
	if (TopOfs < 0) TopOfs = 0;
	if (Delay < 0) Delay = 100;
	if (Disposal < 0) Disposal = 1;

	ctx.Width = IWidth;
        ctx.Height = IHeight;

        /*
         * Calculate number of bits we are expecting
         */
        ctx.CountDown = (long)ctx.Width * (long)ctx.Height;

        /*
         * Indicate which pass we are on (if interlace)
         */
        ctx.Pass = 0;

        /*
         * The initial code size
         */
        if( BitsPerPixel <= 1 )
                InitCodeSize = 2;
        else
                InitCodeSize = BitsPerPixel;

        /*
         * Set up the current x and y position
         */
        ctx.curx = ctx.cury = 0;

	/*
	 * Write out extension for image animation and looping
	 */
	gdPutC( '!', fp );
	gdPutC( 0xf9, fp );
	gdPutC( 4, fp );
	gdPutC( (Transparent >= 0 ? 1 : 0)
		| (Disposal << 2), fp );
	gdPutC( (unsigned char)(Delay & 255), fp );
	gdPutC( (unsigned char)((Delay >> 8) & 255), fp );
	gdPutC( (unsigned char) Transparent, fp );
	gdPutC( 0, fp );

	/*
	 * Write an Image separator
	 */
	gdPutC( ',', fp );

        /*
         * Write out the Image header
         */
        gifPutWord( LeftOfs, fp );
        gifPutWord( TopOfs, fp );
        gifPutWord( ctx.Width, fp );
        gifPutWord( ctx.Height, fp );

        /*
         * Indicate that there is a local colour map
         */
        B = (Red && Green && Blue) ? 0x80 : 0;

        /*
         * OR in the interlacing
         */
        B |= ctx.Interlace ? 0x40 : 0;

        /*
         * OR in the Bits per Pixel
         */
        B |= (Red && Green && Blue) ? (BitsPerPixel - 1) : 0;

        /*
         * Write it out
         */
        gdPutC( B, fp );

	/*
	 * Write out the Local Colour Map
	 */
	if (Red && Green && Blue)
		for( i=0; i<ColorMapSize; ++i ) {
			gdPutC( Red[i], fp );
			gdPutC( Green[i], fp );
			gdPutC( Blue[i], fp );
		}

        /*
         * Write out the initial code size
         */
        gdPutC( InitCodeSize, fp );

        /*
         * Go and actually compress the data
         */
        compress( InitCodeSize+1, fp, im, &ctx );

        /*
         * Write out a Zero-length packet (to end the series)
         */
        gdPutC( 0, fp );
}

/***************************************************************************
 *
 *  GIFCOMPR.C       - GIF Image compression routines
 *
 *  Lempel-Ziv compression based on 'compress'.  GIF modifications by
 *  David Rowley (mgardi@watdcsu.waterloo.edu)
 *
 ***************************************************************************/

/*
 * General DEFINEs
 */

#define GIFBITS    12

#ifdef NO_UCHAR
 typedef char   char_type;
#else /*NO_UCHAR*/
 typedef        unsigned char   char_type;
#endif /*NO_UCHAR*/

/*
 *
 * GIF Image compression - modified 'compress'
 *
 * Based on: compress.c - File compression ala IEEE Computer, June 1984.
 *
 * By Authors:  Spencer W. Thomas       (decvax!harpo!utah-cs!utah-gr!thomas)
 *              Jim McKie               (decvax!mcvax!jim)
 *              Steve Davies            (decvax!vax135!petsd!peora!srd)
 *              Ken Turkowski           (decvax!decwrl!turtlevax!ken)
 *              James A. Woods          (decvax!ihnp4!ames!jaw)
 *              Joe Orost               (decvax!vax135!petsd!joe)
 *
 */
#include <ctype.h>

#define ARGVAL() (*++(*argv) || (--argc && *++argv))

#ifdef COMPATIBLE               /* But wrong! */
# define MAXCODE(n_bits)        ((code_int) 1 << (n_bits) - 1)
#else /*COMPATIBLE*/
# define MAXCODE(n_bits)        (((code_int) 1 << (n_bits)) - 1)
#endif /*COMPATIBLE*/

#define HashTabOf(i)       ctx->htab[i]
#define CodeTabOf(i)    ctx->codetab[i]


/*
 * To save much memory, we overlay the table used by compress() with those
 * used by decompress().  The tab_prefix table is the same size and type
 * as the codetab.  The tab_suffix table needs 2**GIFBITS characters.  We
 * get this from the beginning of htab.  The output stack uses the rest
 * of htab, and contains characters.  There is plenty of room for any
 * possible stack (stack used to be 8000 characters).
 */

#define tab_prefixof(i) CodeTabOf(i)
#define tab_suffixof(i)        ((char_type*)(htab))[i]
#define de_stack               ((char_type*)&tab_suffixof((code_int)1<<GIFBITS))

/*
 * compress stdin to stdout
 *
 * Algorithm:  use open addressing double hashing (no chaining) on the
 * prefix code / next character combination.  We do a variant of Knuth's
 * algorithm D (vol. 3, sec. 6.4) along with G. Knott's relatively-prime
 * secondary probe.  Here, the modular division first probe is gives way
 * to a faster exclusive-or manipulation.  Also do block compression with
 * an adaptive reset, whereby the code table is cleared when the compression
 * ratio decreases, but after the table fills.  The variable-length output
 * codes are re-sized at this point, and a special CLEAR code is generated
 * for the decompressor.  Late addition:  construct the table according to
 * file size for noticeable speed improvement on small files.  Please direct
 * questions about this implementation to ames!jaw.
 */

static void
output(code_int code, GifCtx *ctx);

static void
compress(int init_bits, gdIOCtxPtr outfile, gdImagePtr im, GifCtx *ctx)
{
    register long fcode;
    register code_int i /* = 0 */;
    register int c;
    register code_int ent;
    register code_int disp;
    register code_int hsize_reg;
    register int hshift;

    /*
     * Set up the globals:  g_init_bits - initial number of bits
     *                      g_outfile   - pointer to output file
     */
    ctx->g_init_bits = init_bits;
    ctx->g_outfile = outfile;

    /*
     * Set up the necessary values
     */
    ctx->offset = 0;
    ctx->out_count = 0;
    ctx->clear_flg = 0;
    ctx->in_count = 1;
    ctx->maxcode = MAXCODE(ctx->n_bits = ctx->g_init_bits);

    ctx->ClearCode = (1 << (init_bits - 1));
    ctx->EOFCode = ctx->ClearCode + 1;
    ctx->free_ent = ctx->ClearCode + 2;

    char_init(ctx);

    ent = GIFNextPixel( im, ctx );

    hshift = 0;
    for ( fcode = (long) hsize;  fcode < 65536L; fcode *= 2L )
        ++hshift;
    hshift = 8 - hshift;                /* set hash code range bound */

    hsize_reg = hsize;
    cl_hash( (count_int) hsize_reg, ctx );            /* clear hash table */

    output( (code_int)ctx->ClearCode, ctx );

#ifdef SIGNED_COMPARE_SLOW
    while ( (c = GIFNextPixel( im )) != (unsigned) EOF ) {
#else /*SIGNED_COMPARE_SLOW*/
    while ( (c = GIFNextPixel( im, ctx )) != EOF ) {  /* } */
#endif /*SIGNED_COMPARE_SLOW*/

        ++(ctx->in_count);

        fcode = (long) (((long) c << maxbits) + ent);
        i = (((code_int)c << hshift) ^ ent);    /* xor hashing */

        if ( HashTabOf (i) == fcode ) {
            ent = CodeTabOf (i);
            continue;
        } else if ( (long)HashTabOf (i) < 0 )      /* empty slot */
            goto nomatch;
        disp = hsize_reg - i;           /* secondary hash (after G. Knott) */
        if ( i == 0 )
            disp = 1;
probe:
        if ( (i -= disp) < 0 )
            i += hsize_reg;

        if ( HashTabOf (i) == fcode ) {
            ent = CodeTabOf (i);
            continue;
        }
        if ( (long)HashTabOf (i) > 0 )
            goto probe;
nomatch:
        output ( (code_int) ent, ctx );
        ++(ctx->out_count);
        ent = c;
#ifdef SIGNED_COMPARE_SLOW
        if ( (unsigned) ctx->free_ent < (unsigned) maxmaxcode) {
#else /*SIGNED_COMPARE_SLOW*/
        if ( ctx->free_ent < maxmaxcode ) {  /* } */
#endif /*SIGNED_COMPARE_SLOW*/
            CodeTabOf (i) = ctx->free_ent++; /* code -> hashtable */
            HashTabOf (i) = fcode;
        } else
                cl_block(ctx);
    }
    /*
     * Put out the final code.
     */
    output( (code_int)ent, ctx );
    ++(ctx->out_count);
    output( (code_int) ctx->EOFCode, ctx );
}

/*****************************************************************
 * TAG( output )
 *
 * Output the given code.
 * Inputs:
 *      code:   A n_bits-bit integer.  If == -1, then EOF.  This assumes
 *              that n_bits =< (long)wordsize - 1.
 * Outputs:
 *      Outputs code to the file.
 * Assumptions:
 *      Chars are 8 bits long.
 * Algorithm:
 *      Maintain a GIFBITS character long buffer (so that 8 codes will
 * fit in it exactly).  Use the VAX insv instruction to insert each
 * code in turn.  When the buffer fills up empty it and start over.
 */

static unsigned long masks[] = { 0x0000, 0x0001, 0x0003, 0x0007, 0x000F,
                                  0x001F, 0x003F, 0x007F, 0x00FF,
                                  0x01FF, 0x03FF, 0x07FF, 0x0FFF,
                                  0x1FFF, 0x3FFF, 0x7FFF, 0xFFFF };

static void
output(code_int code, GifCtx *ctx)
{
    ctx->cur_accum &= masks[ ctx->cur_bits ];

    if( ctx->cur_bits > 0 )
        ctx->cur_accum |= ((long)code << ctx->cur_bits);
    else
        ctx->cur_accum = code;

    ctx->cur_bits += ctx->n_bits;

    while( ctx->cur_bits >= 8 ) {
        char_out( (unsigned int)(ctx->cur_accum & 0xff), ctx );
        ctx->cur_accum >>= 8;
        ctx->cur_bits -= 8;
    }

    /*
     * If the next entry is going to be too big for the code size,
     * then increase it, if possible.
     */
   if ( ctx->free_ent > ctx->maxcode || ctx->clear_flg ) {

            if( ctx->clear_flg ) {

                ctx->maxcode = MAXCODE (ctx->n_bits = ctx->g_init_bits);
                ctx->clear_flg = 0;

            } else {

                ++(ctx->n_bits);
                if ( ctx->n_bits == maxbits )
                    ctx->maxcode = maxmaxcode;
                else
                    ctx->maxcode = MAXCODE(ctx->n_bits);
            }
        }

    if( code == ctx->EOFCode ) {
        /*
         * At EOF, write the rest of the buffer.
         */
        while( ctx->cur_bits > 0 ) {
                char_out( (unsigned int)(ctx->cur_accum & 0xff), ctx);
                ctx->cur_accum >>= 8;
                ctx->cur_bits -= 8;
        }

        flush_char(ctx);

    }
}

/*
 * Clear out the hash table
 */
static void
cl_block (GifCtx *ctx)             /* table clear for block compress */
{

        cl_hash ( (count_int) hsize, ctx );
        ctx->free_ent = ctx->ClearCode + 2;
        ctx->clear_flg = 1;

        output( (code_int)ctx->ClearCode, ctx);
}

static void
cl_hash(register count_int chsize, GifCtx *ctx)          /* reset code table */
                         
{

        register count_int *htab_p = ctx->htab+chsize;

        register long i;
        register long m1 = -1;

        i = chsize - 16;
        do {                            /* might use Sys V memset(3) here */
                *(htab_p-16) = m1;
                *(htab_p-15) = m1;
                *(htab_p-14) = m1;
                *(htab_p-13) = m1;
                *(htab_p-12) = m1;
                *(htab_p-11) = m1;
                *(htab_p-10) = m1;
                *(htab_p-9) = m1;
                *(htab_p-8) = m1;
                *(htab_p-7) = m1;
                *(htab_p-6) = m1;
                *(htab_p-5) = m1;
                *(htab_p-4) = m1;
                *(htab_p-3) = m1;
                *(htab_p-2) = m1;
                *(htab_p-1) = m1;
                htab_p -= 16;
        } while ((i -= 16) >= 0);

        for ( i += 16; i > 0; --i )
                *--htab_p = m1;
}

/******************************************************************************
 *
 * GIF Specific routines
 *
 ******************************************************************************/

/*
 * Set up the 'byte output' routine
 */
static void
char_init(GifCtx *ctx)
{
        ctx->a_count = 0;
}

/*
 * Add a character to the end of the current packet, and if it is 254
 * characters, flush the packet to disk.
 */
static void
char_out(int c, GifCtx *ctx)
{
        ctx->accum[ ctx->a_count++ ] = c;
        if( ctx->a_count >= 254 )
                flush_char(ctx);
}

/*
 * Flush the packet to disk, and reset the accumulator
 */
static void
flush_char(GifCtx *ctx)
{
        if( ctx->a_count > 0 ) {
                gdPutC( ctx->a_count, ctx->g_outfile );
                gdPutBuf( ctx->accum, ctx->a_count, ctx->g_outfile );
                ctx->a_count = 0;
        }
}

static int gifPutWord(int w, gdIOCtx *out)
{
	/* Byte order is little-endian */
	gdPutC(w & 0xFF, out);
	gdPutC((w >> 8) & 0xFF, out);
	return 0;
}


 2913        171156      136468      1193070200  200         0           100640      7   gd_io.c `


/*
   * io.c
   *
   * Implements the simple I/O 'helper' routines.
   *
   * Not really essential, but these routines were used extensively in GD,
   * so they were moved here. They also make IOCtx calls look better...
   *
   * Written (or, at least, moved) 1999, Philip Warner.
   *
 */

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include <math.h>
#include <string.h>
#include <stdlib.h>
#include "gd.h"

/* Use this for commenting out debug-print statements. */
/* Just use the first '#define' to allow all the prints... */
/*#define IO_DBG(s) (s) */
#define IO_DBG(s)


/*
 * Write out a word to the I/O context pointer
 */
void
Putword (int w, gdIOCtx * ctx)
{
  unsigned char buf[2];
  buf[0] = w & 0xff;
  buf[1] = (w / 256) & 0xff;
  (ctx->putBuf) (ctx, (char *) buf, 2);
}

void
Putchar (int c, gdIOCtx * ctx)
{
  (ctx->putC) (ctx, c & 0xff);
}

void
gdPutC (const unsigned char c, gdIOCtx * ctx)
{
  (ctx->putC) (ctx, c);
}

void
gdPutWord (int w, gdIOCtx * ctx)
{
  IO_DBG (printf ("Putting word...\n"));
  (ctx->putC) (ctx, (unsigned char) (w >> 8));
  (ctx->putC) (ctx, (unsigned char) (w & 0xFF));
  IO_DBG (printf ("put.\n"));
}

void
gdPutInt (int w, gdIOCtx * ctx)
{
  IO_DBG (printf ("Putting int...\n"));
  (ctx->putC) (ctx, (unsigned char) (w >> 24));
  (ctx->putC) (ctx, (unsigned char) ((w >> 16) & 0xFF));
  (ctx->putC) (ctx, (unsigned char) ((w >> 8) & 0xFF));
  (ctx->putC) (ctx, (unsigned char) (w & 0xFF));
  IO_DBG (printf ("put.\n"));
}

int
gdGetC (gdIOCtx * ctx)
{
  return ((ctx->getC) (ctx));
}



int
gdGetByte (int *result, gdIOCtx * ctx)
{
  int r;
  r = (ctx->getC) (ctx);
  if (r == EOF)
    {
      return 0;
    }
  *result = r;
  return 1;
}

int
gdGetWord (int *result, gdIOCtx * ctx)
{
  int r;
  r = (ctx->getC) (ctx);
  if (r == EOF)
    {
      return 0;
    }
  *result = r << 8;
  r = (ctx->getC) (ctx);
  if (r == EOF)
    {
      return 0;
    }
  *result += r;
  return 1;
}


int
gdGetInt (int *result, gdIOCtx * ctx)
{
  int r;
  r = (ctx->getC) (ctx);
  if (r == EOF)
    {
      return 0;
    }
  *result = r << 24;

  r = (ctx->getC) (ctx);
  if (r == EOF)
    {
      return 0;
    }
  *result += r << 16;

  r = (ctx->getC) (ctx);
  if (r == EOF)
    {
      return 0;
    }
  *result += r << 8;

  r = (ctx->getC) (ctx);
  if (r == EOF)
    {
      return 0;
    }
  *result += r;

  return 1;
}

int
gdPutBuf (const void *buf, int size, gdIOCtx * ctx)
{
  IO_DBG (printf ("Putting buf...\n"));
  return (ctx->putBuf) (ctx, buf, size);
  IO_DBG (printf ("put.\n"));
}

int
gdGetBuf (void *buf, int size, gdIOCtx * ctx)
{
  return (ctx->getBuf) (ctx, buf, size);
}


int
gdSeek (gdIOCtx * ctx, const int pos)
{
  IO_DBG (printf ("Seeking...\n"));
  return ((ctx->seek) (ctx, pos));
  IO_DBG (printf ("Done.\n"));
}

long
gdTell (gdIOCtx * ctx)
{
  IO_DBG (printf ("Telling...\n"));
  return ((ctx->tell) (ctx));
  IO_DBG (printf ("told.\n"));
}
 8655        179912      168144      1193070200  200         0           100640      10  gd_io_dp.c`
/*
   * io_dp.c
   *
   * Implements the dynamic pointer interface.
   *
   * Based on GD.pm code by Lincoln Stein for interfacing to libgd.
   * Added support for reading as well as support for 'tell' and 'seek'.
   *
   * As will all I/O modules, most functions are for local use only (called
   * via function pointers in the I/O context).
   *
   * gdDPExtractData is the exception to this: it will return the pointer to
   * the internal data, and reset the internal storage.
   *
   * Written/Modified 1999, Philip Warner.
   *
 */

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include <math.h>
#include <string.h>
#include <stdlib.h>
#include "gd.h"
#include "gdhelpers.h"

#define TRUE 1
#define FALSE 0

/* this is used for creating images in main memory */
typedef struct dpStruct
{
  void *data;
  int logicalSize;
  int realSize;
  int dataGood;
  int pos;
  int freeOK;
}
dynamicPtr;

typedef struct dpIOCtx
{
  gdIOCtx ctx;
  dynamicPtr *dp;
}
dpIOCtx;

typedef struct dpIOCtx *dpIOCtxPtr;


/* these functions operate on in-memory dynamic pointers */
static int allocDynamic (dynamicPtr * dp, int initialSize, void *data);
static int appendDynamic (dynamicPtr * dp, const void *src, int size);
static int gdReallocDynamic (dynamicPtr * dp, int required);
static int trimDynamic (dynamicPtr * dp);
static void gdFreeDynamicCtx (struct gdIOCtx *ctx);
static dynamicPtr *newDynamic (int initialSize, void *data, int freeOKFlag);

static int dynamicPutbuf (struct gdIOCtx *, const void *, int);
static void dynamicPutchar (struct gdIOCtx *, int a);

static int dynamicGetbuf (gdIOCtxPtr ctx, void *buf, int len);
static int dynamicGetchar (gdIOCtxPtr ctx);

static int dynamicSeek (struct gdIOCtx *, const int);
static long dynamicTell (struct gdIOCtx *);

/* return data as a dynamic pointer */
BGD_DECLARE(gdIOCtx *) gdNewDynamicCtx (int initialSize, void *data)
{
  /* 2.0.23: Phil Moore: 'return' keyword was missing! */
  return gdNewDynamicCtxEx (initialSize, data, 1);
}

BGD_DECLARE(gdIOCtx *) gdNewDynamicCtxEx (int initialSize, void *data, int freeOKFlag)
{
  dpIOCtx *ctx;
  dynamicPtr *dp;

  ctx = (dpIOCtx *) gdMalloc (sizeof (dpIOCtx));
  if (ctx == NULL)
    {
      return NULL;
    }

  dp = newDynamic (initialSize, data, freeOKFlag);
  if (!dp)
    {
      gdFree (ctx);
      return NULL;
    };

  ctx->dp = dp;

  ctx->ctx.getC = dynamicGetchar;
  ctx->ctx.putC = dynamicPutchar;

  ctx->ctx.getBuf = dynamicGetbuf;
  ctx->ctx.putBuf = dynamicPutbuf;

  ctx->ctx.seek = dynamicSeek;
  ctx->ctx.tell = dynamicTell;

  ctx->ctx.gd_free = gdFreeDynamicCtx;

  return (gdIOCtx *) ctx;
}

BGD_DECLARE(void *) gdDPExtractData (struct gdIOCtx *ctx, int *size)
{
  dynamicPtr *dp;
  dpIOCtx *dctx;
  void *data;

  dctx = (dpIOCtx *) ctx;
  dp = dctx->dp;

  /* clean up the data block and return it */
  if (dp->dataGood)
    {
      trimDynamic (dp);
      *size = dp->logicalSize;
      data = dp->data;
    }
  else
    {
      *size = 0;
      data = NULL;
      /* 2.0.21: never free memory we don't own */
      if ((dp->data != NULL) && (dp->freeOK))
	{
	  gdFree (dp->data);
	}
    }

  dp->data = NULL;
  dp->realSize = 0;
  dp->logicalSize = 0;

  return data;
}

static void
gdFreeDynamicCtx (struct gdIOCtx *ctx)
{
  dynamicPtr *dp;
  dpIOCtx *dctx;

  dctx = (dpIOCtx *) ctx;
  dp = dctx->dp;

  gdFree (ctx);

  /* clean up the data block and return it */
  /* 2.0.21: never free memory we don't own */
  if ((dp->data != NULL) && (dp->freeOK))
    {
      gdFree (dp->data);
      dp->data = NULL;
    }

  dp->realSize = 0;
  dp->logicalSize = 0;

  gdFree (dp);

}

static long
dynamicTell (struct gdIOCtx *ctx)
{
  dpIOCtx *dctx;

  dctx = (dpIOCtx *) ctx;
  return (dctx->dp->pos);
}

static int
dynamicSeek (struct gdIOCtx *ctx, const int pos)
{
  int bytesNeeded;
  dynamicPtr *dp;
  dpIOCtx *dctx;

  dctx = (dpIOCtx *) ctx;
  dp = dctx->dp;

  if (!dp->dataGood)
    return FALSE;

  bytesNeeded = pos;
  if (bytesNeeded > dp->realSize)
    {
      /* 2.0.21 */
      if (!dp->freeOK)
	{
	  return FALSE;
	}
      if (overflow2(dp->realSize, 2)) {
        return FALSE;
      }
      if (!gdReallocDynamic (dp, dp->realSize * 2))
	{
	  dp->dataGood = FALSE;
	  return FALSE;
	}
    }

  /* if we get here, we can be sure that we have enough bytes
     to copy safely */

  /* Extend the logical size if we seek beyond EOF. */
  if (pos > dp->logicalSize)
    {
      dp->logicalSize = pos;
    };

  dp->pos = pos;

  return TRUE;
}

/* return data as a dynamic pointer */
static dynamicPtr *
newDynamic (int initialSize, void *data, int freeOKFlag)
{
  dynamicPtr *dp;
  dp = (dynamicPtr *) gdMalloc (sizeof (dynamicPtr));
  if (dp == NULL)
    {
      return NULL;
    }

  if (!allocDynamic (dp, initialSize, data))
    return NULL;

  dp->pos = 0;
  dp->freeOK = freeOKFlag;
  return dp;
}

static int
dynamicPutbuf (struct gdIOCtx *ctx, const void *buf, int size)
{
  dpIOCtx *dctx;
  dctx = (dpIOCtx *) ctx;

  appendDynamic (dctx->dp, buf, size);

  if (dctx->dp->dataGood)
    {
      return size;
    }
  else
    {
      return -1;
    };

}

static void
dynamicPutchar (struct gdIOCtx *ctx, int a)
{
  unsigned char b;
  dpIOCtxPtr dctx;

  b = a;
  dctx = (dpIOCtxPtr) ctx;

  appendDynamic (dctx->dp, &b, 1);
}

static int
dynamicGetbuf (gdIOCtxPtr ctx, void *buf, int len)
{
  int rlen, remain;
  dpIOCtxPtr dctx;
  dynamicPtr *dp;

  dctx = (dpIOCtxPtr) ctx;
  dp = dctx->dp;

  remain = dp->logicalSize - dp->pos;
  if (remain >= len)
    {
      rlen = len;
    }
  else
    {
      if (remain == 0)
	{
	/* 2.0.34: EOF is incorrect. We use 0 for
		 errors and EOF, just like fileGetbuf,
		 which is a simple fread() wrapper. 
		 TBB. Original bug report: Daniel Cowgill. */
     return 0; /* NOT EOF */
	}
      rlen = remain;
    }

  memcpy (buf, (void *) ((char *) dp->data + dp->pos), rlen);
  dp->pos += rlen;

  return rlen;
}

static int
dynamicGetchar (gdIOCtxPtr ctx)
{
  unsigned char b;
  int rv;

  rv = dynamicGetbuf (ctx, &b, 1);

  if (rv != 1)
    {
      return EOF;
    }
  else
    {
      return b;			/* (b & 0xff); */
    }
}

/* *********************************************************************

 * InitDynamic - Return a dynamically resizable void*
 *
 * *********************************************************************
 */
static int
allocDynamic (dynamicPtr * dp, int initialSize, void *data)
{

  if (data == NULL)
    {
      dp->logicalSize = 0;
      dp->dataGood = FALSE;
      dp->data = gdMalloc (initialSize);
    }
  else
    {
      dp->logicalSize = initialSize;
      dp->dataGood = TRUE;
      dp->data = data;
    }

  if (dp->data != NULL)
    {
      dp->realSize = initialSize;
      dp->dataGood = TRUE;
      dp->pos = 0;
      return TRUE;
    }
  else
    {
      dp->realSize = 0;
      return FALSE;
    }
}

/* append bytes to the end of a dynamic pointer */
static int
appendDynamic (dynamicPtr * dp, const void *src, int size)
{
  int bytesNeeded;
  char *tmp;

  if (!dp->dataGood)
    return FALSE;

/*  bytesNeeded = dp->logicalSize + size; */
  bytesNeeded = dp->pos + size;

  if (bytesNeeded > dp->realSize)
    {
      /* 2.0.21 */
      if (!dp->freeOK)
	{
	  return FALSE;
	}
      if (overflow2(dp->realSize, 2)) {
        return FALSE;
      }
      if (!gdReallocDynamic (dp, bytesNeeded * 2))
	{
	  dp->dataGood = FALSE;
	  return FALSE;
	}
    }

  /* if we get here, we can be sure that we have enough bytes
     to copy safely */
  /*printf("Mem OK Size: %d, Pos: %d\n", dp->realSize, dp->pos); */

  tmp = (char *) dp->data;
  memcpy ((void *) (tmp + (dp->pos)), src, size);
  dp->pos += size;

  if (dp->pos > dp->logicalSize)
    {
      dp->logicalSize = dp->pos;
    };

  return TRUE;
}

/* grow (or shrink) dynamic pointer */
static int
gdReallocDynamic (dynamicPtr * dp, int required)
{
  void *newPtr;

  /* First try gdRealloc().  If that doesn't work, make a new
     memory block and copy. */
  if ((newPtr = gdRealloc (dp->data, required)))
    {
      dp->realSize = required;
      dp->data = newPtr;
      return TRUE;
    }

  /* create a new pointer */
  newPtr = gdMalloc (required);
  if (!newPtr)
    {
      dp->dataGood = FALSE;
      return FALSE;
    }

  /* copy the old data into it */
  memcpy (newPtr, dp->data, dp->logicalSize);
  gdFree (dp->data);
  dp->data = newPtr;

  dp->realSize = required;
  return TRUE;
}

/* trim pointer so that its real and logical sizes match */
static int
trimDynamic (dynamicPtr * dp)
{
  /* 2.0.21: we don't reallocate memory we don't own */
  if (!dp->freeOK)
    {
      return TRUE;
    }
  return gdReallocDynamic (dp, dp->logicalSize);
}
 2520        182534      171156      1193070200  200         0           100640      12  gd_io_file.c`

/*
   * io_file.c
   *
   * Implements the file interface.
   *
   * As will all I/O modules, most functions are for local use only (called
   * via function pointers in the I/O context).
   *
   * Most functions are just 'wrappers' for standard file functions.
   *
   * Written/Modified 1999, Philip Warner.
   *
 */

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

/* For platforms with incomplete ANSI defines. Fortunately,
   SEEK_SET is defined to be zero by the standard. */

#ifndef SEEK_SET
#define SEEK_SET 0
#endif /* SEEK_SET */

#include <math.h>
#include <string.h>
#include <stdlib.h>
#include "gd.h"
#include "gdhelpers.h"

/* this is used for creating images in main memory */

typedef struct fileIOCtx
{
  gdIOCtx ctx;
  FILE *f;
}
fileIOCtx;

gdIOCtx *newFileCtx (FILE * f);

static int fileGetbuf (gdIOCtx *, void *, int);
static int filePutbuf (gdIOCtx *, const void *, int);
static void filePutchar (gdIOCtx *, int);
static int fileGetchar (gdIOCtx * ctx);

static int fileSeek (struct gdIOCtx *, const int);
static long fileTell (struct gdIOCtx *);
static void gdFreeFileCtx (gdIOCtx * ctx);

/* return data as a dynamic pointer */
BGD_DECLARE(gdIOCtx *) gdNewFileCtx (FILE * f)
{
  fileIOCtx *ctx;

  ctx = (fileIOCtx *) gdMalloc (sizeof (fileIOCtx));
  if (ctx == NULL)
    {
      return NULL;
    }

  ctx->f = f;

  ctx->ctx.getC = fileGetchar;
  ctx->ctx.putC = filePutchar;

  ctx->ctx.getBuf = fileGetbuf;
  ctx->ctx.putBuf = filePutbuf;

  ctx->ctx.tell = fileTell;
  ctx->ctx.seek = fileSeek;

  ctx->ctx.gd_free = gdFreeFileCtx;

  return (gdIOCtx *) ctx;
}

static void
gdFreeFileCtx (gdIOCtx * ctx)
{
  gdFree (ctx);
}


static int
filePutbuf (gdIOCtx * ctx, const void *buf, int size)
{
  fileIOCtx *fctx;
  fctx = (fileIOCtx *) ctx;

  return fwrite (buf, 1, size, fctx->f);

}

static int
fileGetbuf (gdIOCtx * ctx, void *buf, int size)
{
  fileIOCtx *fctx;
  fctx = (fileIOCtx *) ctx;

  return (fread (buf, 1, size, fctx->f));

}

static void
filePutchar (gdIOCtx * ctx, int a)
{
  unsigned char b;
  fileIOCtx *fctx;
  fctx = (fileIOCtx *) ctx;

  b = a;

  putc (b, fctx->f);
}

static int
fileGetchar (gdIOCtx * ctx)
{
  fileIOCtx *fctx;
  fctx = (fileIOCtx *) ctx;

  return getc (fctx->f);
}


static int
fileSeek (struct gdIOCtx *ctx, const int pos)
{
  fileIOCtx *fctx;
  fctx = (fileIOCtx *) ctx;
  return (fseek (fctx->f, pos, SEEK_SET) == 0);
}

static long
fileTell (struct gdIOCtx *ctx)
{
  fileIOCtx *fctx;
  fctx = (fileIOCtx *) ctx;

  return ftell (fctx->f);
}
2907        185542      179912      1193070200  200         0           100640      10  gd_io_ss.c`

/*
   * io_ss.c
   *
   * Implements the Source/Sink interface.
   *
   * As will all I/O modules, most functions are for local use only (called
   * via function pointers in the I/O context).
   *
   * The Source/Sink model is the primary 'user' interface for alternate data
   * sources; the IOCtx interface is intended (at least in version 1.5) to be
   * used internally until it settles down a bit.
   *
   * This module just layers the Source/Sink interface on top of the IOCtx; no
   * support is provided for tell/seek, so GD2 writing is not possible, and 
   * retrieving parts of GD2 files is also not possible.
   *
   * A new SS context does not need to be created with both a Source and a Sink.
   *
   * Written/Modified 1999, Philip Warner.
   *
 */

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include <math.h>
#include <string.h>
#include <stdlib.h>
#include "gd.h"
#include "gdhelpers.h"

/* this is used for creating images in main memory */

typedef struct ssIOCtx
{
  gdIOCtx ctx;
  gdSourcePtr src;
  gdSinkPtr snk;
}
ssIOCtx;

typedef struct ssIOCtx *ssIOCtxPtr;

static int sourceGetbuf (gdIOCtx *, void *, int);
static int sourceGetchar (gdIOCtx * ctx);
static int sinkPutbuf (gdIOCtx * ctx, const void *buf, int size);
static void sinkPutchar (gdIOCtx * ctx, int a);
static void gdFreeSsCtx (gdIOCtx * ctx);

/* return data as a dynamic pointer */
BGD_DECLARE(gdIOCtx *) gdNewSSCtx (gdSourcePtr src, gdSinkPtr snk)
{
  ssIOCtxPtr ctx;

  ctx = (ssIOCtxPtr) gdMalloc (sizeof (ssIOCtx));
  if (ctx == NULL)
    {
      return NULL;
    }

  ctx->src = src;
  ctx->snk = snk;

  ctx->ctx.getC = sourceGetchar;
  ctx->ctx.getBuf = sourceGetbuf;

  ctx->ctx.putC = sinkPutchar;
  ctx->ctx.putBuf = sinkPutbuf;

  ctx->ctx.tell = NULL;
  ctx->ctx.seek = NULL;

  ctx->ctx.gd_free = gdFreeSsCtx;

  return (gdIOCtx *) ctx;
}

static void
gdFreeSsCtx (gdIOCtx * ctx)
{
  gdFree (ctx);
}


static int
sourceGetbuf (gdIOCtx * ctx, void *buf, int size)
{
  ssIOCtx *lctx;
  int res;

  lctx = (ssIOCtx *) ctx;

  res = ((lctx->src->source) (lctx->src->context, buf, size));

/*
   ** Translate the return values from the Source object: 
   ** 0 is EOF, -1 is error
 */

  if (res == 0)
    {
      return 0;
    }
  else if (res < 0)
    {
      return 0;
    }
  else
    {
      return res;
    };

}

static int
sourceGetchar (gdIOCtx * ctx)
{
  int res;
  unsigned char buf;

  res = sourceGetbuf (ctx, &buf, 1);

  if (res == 1)
    {
      return buf;
    }
  else
    {
      return EOF;
    };

}

static int
sinkPutbuf (gdIOCtx * ctx, const void *buf, int size)
{
  ssIOCtxPtr lctx;
  int res;

  lctx = (ssIOCtx *) ctx;

  res = (lctx->snk->sink) (lctx->snk->context, buf, size);

  if (res <= 0)
    {
      return 0;
    }
  else
    {
      return res;
    };

}

static void
sinkPutchar (gdIOCtx * ctx, int a)
{
  unsigned char b;

  b = a;
  sinkPutbuf (ctx, &b, 1);

}
 29121       214764      182534      1193070200  200         0           100640      9   gd_jpeg.c `
/*
 * gd_jpeg.c: Read and write JPEG (JFIF) format image files using the
 * gd graphics library (http://www.libgd.org).
 * 
 * This software is based in part on the work of the Independent JPEG
 * Group.  For more information on the IJG JPEG software (and JPEG
 * documentation, etc.), see ftp://ftp.uu.net/graphics/jpeg/.
 *
 * NOTE: IJG 12-bit JSAMPLE (BITS_IN_JSAMPLE == 12) mode is not
 * supported at all on read in gd 2.0, and is not supported on write
 * except for palette images, which is sort of pointless (TBB). Even that
 * has never been tested according to DB.
 *
 * Copyright 2000 Doug Becker, mailto:thebeckers@home.com
 *
 * Modification 4/18/00 TBB: JPEG_DEBUG rather than just DEBUG,
 * so VC++ builds don't spew to standard output, causing
 * major CGI brain damage
 *
 * 2.0.10: more efficient gdImageCreateFromJpegCtx, thanks to
 * Christian Aberger 
 */

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include <stdio.h>
#include <stdlib.h>
#include <setjmp.h>
#include <limits.h>
#include <string.h>

#include "gd.h"
/* TBB: move this up so include files are not brought in */
/* JCE: arrange HAVE_LIBJPEG so that it can be set in gd.h */
#ifdef HAVE_LIBJPEG
#include "gdhelpers.h"

/* JCE undef two symbols that we don't need anymore but which are
   may be defined in config.h from ./configure but which are
   redefined incompatibly in jpeglib.h */
#undef HAVE_STDDEF_H
#undef HAVE_STDLIB_H

/* 1.8.1: remove dependency on jinclude.h */
#include "jpeglib.h"
#include "jerror.h"

static const char *const GD_JPEG_VERSION = "1.0";

typedef struct _jmpbuf_wrapper
{
  jmp_buf jmpbuf;
}
jmpbuf_wrapper;

/* Called by the IJG JPEG library upon encountering a fatal error */
static void
fatal_jpeg_error (j_common_ptr cinfo)
{
  jmpbuf_wrapper *jmpbufw;

  fprintf (stderr, "gd-jpeg: JPEG library reports unrecoverable error: ");
  (*cinfo->err->output_message) (cinfo);
  fflush (stderr);

  jmpbufw = (jmpbuf_wrapper *) cinfo->client_data;
  jpeg_destroy (cinfo);

  if (jmpbufw != 0)
    {
      longjmp (jmpbufw->jmpbuf, 1);
      fprintf (stderr, "gd-jpeg: EXTREMELY fatal error: longjmp"
	       " returned control; terminating\n");
    }
  else
    {
      fprintf (stderr, "gd-jpeg: EXTREMELY fatal error: jmpbuf"
	       " unrecoverable; terminating\n");
    }

  fflush (stderr);
  exit (99);
}

/*
 * Write IM to OUTFILE as a JFIF-formatted JPEG image, using quality
 * QUALITY.  If QUALITY is in the range 0-100, increasing values
 * represent higher quality but also larger image size.  If QUALITY is
 * negative, the IJG JPEG library's default quality is used (which
 * should be near optimal for many applications).  See the IJG JPEG
 * library documentation for more details.  */

BGD_DECLARE(void) gdImageJpeg (gdImagePtr im, FILE * outFile, int quality)
{
  gdIOCtx *out = gdNewFileCtx (outFile);
  gdImageJpegCtx (im, out, quality);
  out->gd_free (out);
}

BGD_DECLARE(void *) gdImageJpegPtr (gdImagePtr im, int *size, int quality)
{
  void *rv;
  gdIOCtx *out = gdNewDynamicCtx (2048, NULL);
  gdImageJpegCtx (im, out, quality);
  rv = gdDPExtractData (out, size);
  out->gd_free (out);
  return rv;
}

void jpeg_gdIOCtx_dest (j_compress_ptr cinfo, gdIOCtx * outfile);

BGD_DECLARE(void) gdImageJpegCtx (gdImagePtr im, gdIOCtx * outfile, int quality)
{
  struct jpeg_compress_struct cinfo;
  struct jpeg_error_mgr jerr;
  int i, j, jidx;
  /* volatile so we can gdFree it on return from longjmp */
  volatile JSAMPROW row = 0;
  JSAMPROW rowptr[1];
  jmpbuf_wrapper jmpbufw;
  JDIMENSION nlines;
  char comment[255];

#ifdef JPEG_DEBUG
  printf ("gd-jpeg: gd JPEG version %s\n", GD_JPEG_VERSION);
  printf ("gd-jpeg: JPEG library version %d, %d-bit sample values\n",
	  JPEG_LIB_VERSION, BITS_IN_JSAMPLE);
  if (!im->trueColor)
    {
      for (i = 0; i < im->colorsTotal; i++)
	{
	  if (!im->open[i])
	    printf ("gd-jpeg: gd colormap index %d: (%d, %d, %d)\n", i,
		    im->red[i], im->green[i], im->blue[i]);
	}
    }
#endif /* JPEG_DEBUG */

  memset (&cinfo, 0, sizeof (cinfo));
  memset (&jerr, 0, sizeof (jerr));

  cinfo.err = jpeg_std_error (&jerr);
  cinfo.client_data = &jmpbufw;
  if (setjmp (jmpbufw.jmpbuf) != 0)
    {
      /* we're here courtesy of longjmp */
      if (row)
	gdFree (row);
      return;
    }

  cinfo.err->error_exit = fatal_jpeg_error;

  jpeg_create_compress (&cinfo);

  cinfo.image_width = im->sx;
  cinfo.image_height = im->sy;
  cinfo.input_components = 3;	/* # of color components per pixel */
  cinfo.in_color_space = JCS_RGB;	/* colorspace of input image */
  jpeg_set_defaults (&cinfo);
  if (quality >= 0)
    jpeg_set_quality (&cinfo, quality, TRUE);

  /* If user requests interlace, translate that to progressive JPEG */
  if (gdImageGetInterlaced (im))
    {
#ifdef JPEG_DEBUG
      printf ("gd-jpeg: interlace set, outputting progressive"
	      " JPEG image\n");
#endif
      jpeg_simple_progression (&cinfo);
    }

  jpeg_gdIOCtx_dest (&cinfo, outfile);

  row = (JSAMPROW) gdCalloc (1, cinfo.image_width * cinfo.input_components
			     * sizeof (JSAMPLE));
  if (row == 0)
    {
      fprintf (stderr, "gd-jpeg: error: unable to allocate JPEG row "
	       "structure: gdCalloc returns NULL\n");
      jpeg_destroy_compress (&cinfo);
      return;
    }

  rowptr[0] = row;

  jpeg_start_compress (&cinfo, TRUE);

  sprintf (comment, "CREATOR: gd-jpeg v%s (using IJG JPEG v%d),",
	   GD_JPEG_VERSION, JPEG_LIB_VERSION);
  if (quality >= 0)
    sprintf (comment + strlen (comment), " quality = %d\n", quality);
  else
    strcat (comment + strlen (comment), " default quality\n");
  jpeg_write_marker (&cinfo, JPEG_COM, (unsigned char *) comment,
		     (unsigned int) strlen (comment));
  if (im->trueColor)
    {
#if BITS_IN_JSAMPLE == 12
      fprintf (stderr,
	       "gd-jpeg: error: jpeg library was compiled for 12-bit\n"
	       "precision. This is mostly useless, because JPEGs on the web are\n"
	       "8-bit and such versions of the jpeg library won't read or write\n"
	       "them. GD doesn't support these unusual images. Edit your\n"
	       "jmorecfg.h file to specify the correct precision and completely\n"
	       "'make clean' and 'make install' libjpeg again. Sorry.\n");
      goto error;
#endif /* BITS_IN_JSAMPLE == 12 */
      for (i = 0; i < im->sy; i++)
	{
	  for (jidx = 0, j = 0; j < im->sx; j++)
	    {
	      int val = im->tpixels[i][j];
	      row[jidx++] = gdTrueColorGetRed (val);
	      row[jidx++] = gdTrueColorGetGreen (val);
	      row[jidx++] = gdTrueColorGetBlue (val);
	    }

	  nlines = jpeg_write_scanlines (&cinfo, rowptr, 1);
	  if (nlines != 1)
	    fprintf (stderr, "gd_jpeg: warning: jpeg_write_scanlines"
		     " returns %u -- expected 1\n", nlines);
	}
    }
  else
    {
      for (i = 0; i < im->sy; i++)
	{
	  for (jidx = 0, j = 0; j < im->sx; j++)
	    {
	      int idx = im->pixels[i][j];

	      /*
	       * NB: Although gd RGB values are ints, their max value is
	       * 255 (see the documentation for gdImageColorAllocate())
	       * -- perfect for 8-bit JPEG encoding (which is the norm)
	       */
#if BITS_IN_JSAMPLE == 8
	      row[jidx++] = im->red[idx];
	      row[jidx++] = im->green[idx];
	      row[jidx++] = im->blue[idx];
#elif BITS_IN_JSAMPLE == 12
	      row[jidx++] = im->red[idx] << 4;
	      row[jidx++] = im->green[idx] << 4;
	      row[jidx++] = im->blue[idx] << 4;
#else
#error IJG JPEG library BITS_IN_JSAMPLE value must be 8 or 12
#endif
	    }

	  nlines = jpeg_write_scanlines (&cinfo, rowptr, 1);
	  if (nlines != 1)
	    fprintf (stderr, "gd_jpeg: warning: jpeg_write_scanlines"
		     " returns %u -- expected 1\n", nlines);
	}
    }
  jpeg_finish_compress (&cinfo);
  jpeg_destroy_compress (&cinfo);
  gdFree (row);
}

BGD_DECLARE(gdImagePtr) gdImageCreateFromJpeg (FILE * inFile)
{
  gdImagePtr im;
  gdIOCtx *in = gdNewFileCtx (inFile);
  im = gdImageCreateFromJpegCtx (in);
  in->gd_free (in);
  return im;
}

BGD_DECLARE(gdImagePtr) gdImageCreateFromJpegPtr (int size, void *data)
{
  gdImagePtr im;
  gdIOCtx *in = gdNewDynamicCtxEx (size, data, 0);
  im = gdImageCreateFromJpegCtx (in);
  in->gd_free (in);
  return im;
}

void jpeg_gdIOCtx_src (j_decompress_ptr cinfo, gdIOCtx * infile);

static int CMYKToRGB (int c, int m, int y, int k, int inverted);

/* 
 * Create a gd-format image from the JPEG-format INFILE.  Returns the
 * image, or NULL upon error.
 */
BGD_DECLARE(gdImagePtr) gdImageCreateFromJpegCtx (gdIOCtx * infile)
{
  struct jpeg_decompress_struct cinfo;
  struct jpeg_error_mgr jerr;
  jmpbuf_wrapper jmpbufw;
  /* volatile so we can gdFree them after longjmp */
  volatile JSAMPROW row = 0;
  volatile gdImagePtr im = 0;
  JSAMPROW rowptr[1];
  int i, j, retval;
  JDIMENSION nrows;
  int channels = 3;
  int inverted = 0;
#ifdef JPEG_DEBUG
  printf ("gd-jpeg: gd JPEG version %s\n", GD_JPEG_VERSION);
  printf ("gd-jpeg: JPEG library version %d, %d-bit sample values\n",
	  JPEG_LIB_VERSION, BITS_IN_JSAMPLE);
#endif

  memset (&cinfo, 0, sizeof (cinfo));
  memset (&jerr, 0, sizeof (jerr));

  cinfo.err = jpeg_std_error (&jerr);
  cinfo.client_data = &jmpbufw;
  if (setjmp (jmpbufw.jmpbuf) != 0)
    {
      /* we're here courtesy of longjmp */
      if (row)
	gdFree (row);
      if (im)
	gdImageDestroy (im);
      return 0;
    }

  cinfo.err->error_exit = fatal_jpeg_error;

  jpeg_create_decompress (&cinfo);

  jpeg_gdIOCtx_src (&cinfo, infile);

  /* 2.0.22: save the APP14 marker to check for Adobe Photoshop CMYK
     files with inverted components. */
  jpeg_save_markers (&cinfo, JPEG_APP0 + 14, 256);

  retval = jpeg_read_header (&cinfo, TRUE);
  if (retval != JPEG_HEADER_OK)
    fprintf (stderr, "gd-jpeg: warning: jpeg_read_header returns"
	     " %d, expected %d\n", retval, JPEG_HEADER_OK);

  if (cinfo.image_height > INT_MAX)
    fprintf (stderr, "gd-jpeg: warning: JPEG image height (%u) is"
	     " greater than INT_MAX (%d) (and thus greater than"
	     " gd can handle)", cinfo.image_height, INT_MAX);

  if (cinfo.image_width > INT_MAX)
    fprintf (stderr, "gd-jpeg: warning: JPEG image width (%u) is"
	     " greater than INT_MAX (%d) (and thus greater than"
	     " gd can handle)\n", cinfo.image_width, INT_MAX);

  im = gdImageCreateTrueColor ((int) cinfo.image_width,
			       (int) cinfo.image_height);
  if (im == 0)
    {
      fprintf (stderr, "gd-jpeg error: cannot allocate gdImage" " struct\n");
      goto error;
    }
  /* 2.0.22: very basic support for reading CMYK colorspace files. Nice for
     thumbnails but there's no support for fussy adjustment of the
     assumed properties of inks and paper. */
  if ((cinfo.jpeg_color_space == JCS_CMYK) ||
      (cinfo.jpeg_color_space == JCS_YCCK))
    {
      cinfo.out_color_space = JCS_CMYK;
    }
  else
    {
      cinfo.out_color_space = JCS_RGB;
    }

  if (jpeg_start_decompress (&cinfo) != TRUE)
    fprintf (stderr, "gd-jpeg: warning: jpeg_start_decompress"
	     " reports suspended data source\n");

#ifdef JPEG_DEBUG
  printf ("gd-jpeg: JPEG image information:");
  if (cinfo.saw_JFIF_marker)
    printf (" JFIF version %d.%.2d",
	    (int) cinfo.JFIF_major_version, (int) cinfo.JFIF_minor_version);
  else if (cinfo.saw_Adobe_marker)
    printf (" Adobe format");
  else
    printf (" UNKNOWN format");

  printf (" %ux%u (raw) / %ux%u (scaled) %d-bit", cinfo.image_width,
	  cinfo.image_height, cinfo.output_width,
	  cinfo.output_height, cinfo.data_precision);
  printf (" %s", (cinfo.progressive_mode ? "progressive" : "baseline"));
  printf (" image, %d quantized colors, ", cinfo.actual_number_of_colors);

  switch (cinfo.jpeg_color_space)
    {
    case JCS_GRAYSCALE:
      printf ("grayscale");
      break;

    case JCS_RGB:
      printf ("RGB");
      break;

    case JCS_YCbCr:
      printf ("YCbCr (a.k.a. YUV)");
      break;

    case JCS_CMYK:
      printf ("CMYK");
      break;

    case JCS_YCCK:
      printf ("YCbCrK");
      break;

    default:
      printf ("UNKNOWN (value: %d)", (int) cinfo.jpeg_color_space);
      break;
    }
  printf (" colorspace\n");
  fflush (stdout);
#endif /* JPEG_DEBUG */

  /* REMOVED by TBB 2/12/01. This field of the structure is
     documented as private, and sure enough it's gone in the
     latest libjpeg, replaced by something else. Unfortunately
     there is still no right way to find out if the file was
     progressive or not; just declare your intent before you
     write one by calling gdImageInterlace(im, 1) yourself. 
     After all, we're not really supposed to rework JPEGs and
     write them out again anyway. Lossy compression, remember? */
#if 0
  gdImageInterlace (im, cinfo.progressive_mode != 0);
#endif
  if (cinfo.out_color_space == JCS_RGB)
    {
      if (cinfo.output_components != 3)
	{
	  fprintf (stderr, "gd-jpeg: error: JPEG color quantization"
		   " request resulted in output_components == %d"
		   " (expected 3 for RGB)\n", cinfo.output_components);
	  goto error;
	}
      channels = 3;
    }
  else if (cinfo.out_color_space == JCS_CMYK)
    {
      jpeg_saved_marker_ptr marker;
      if (cinfo.output_components != 4)
	{
	  fprintf (stderr, "gd-jpeg: error: JPEG color quantization"
		   " request resulted in output_components == %d"
		   " (expected 4 for CMYK)\n", cinfo.output_components);
	  goto error;
	}
      channels = 4;
      marker = cinfo.marker_list;
      while (marker)
	{
	  if ((marker->marker == (JPEG_APP0 + 14)) &&
	      (marker->data_length >= 12)
	      && (!strncmp ((const char *) marker->data, "Adobe", 5)))
	    {
	      inverted = 1;
	      break;
	    }
	  marker = marker->next;
	}
    }
  else
    {
      fprintf (stderr, "gd-jpeg: error: unexpected colorspace\n");
      goto error;
    }
#if BITS_IN_JSAMPLE == 12
  fprintf (stderr, "gd-jpeg: error: jpeg library was compiled for 12-bit\n"
	   "precision. This is mostly useless, because JPEGs on the web are\n"
	   "8-bit and such versions of the jpeg library won't read or write\n"
	   "them. GD doesn't support these unusual images. Edit your\n"
	   "jmorecfg.h file to specify the correct precision and completely\n"
	   "'make clean' and 'make install' libjpeg again. Sorry.\n");
  goto error;
#endif /* BITS_IN_JSAMPLE == 12 */

  row = gdCalloc (cinfo.output_width * channels, sizeof (JSAMPLE));
  if (row == 0)
    {
      fprintf (stderr, "gd-jpeg: error: unable to allocate row for"
	       " JPEG scanline: gdCalloc returns NULL\n");
      goto error;
    }
  rowptr[0] = row;
  if (cinfo.out_color_space == JCS_CMYK)
    {
      for (i = 0; i < cinfo.output_height; i++)
	{
	  register JSAMPROW currow = row;
	  register int *tpix = im->tpixels[i];
	  nrows = jpeg_read_scanlines (&cinfo, rowptr, 1);
	  if (nrows != 1)
	    {
	      fprintf (stderr, "gd-jpeg: error: jpeg_read_scanlines"
		       " returns %u, expected 1\n", nrows);
	      goto error;
	    }
	  for (j = 0; j < cinfo.output_width; j++, currow += 4, tpix++)
	    {
	      *tpix =
		CMYKToRGB (currow[0], currow[1], currow[2], currow[3],
			   inverted);
	    }
	}
    }
  else
    {
      for (i = 0; i < cinfo.output_height; i++)
	{
	  register JSAMPROW currow = row;
	  register int *tpix = im->tpixels[i];
	  nrows = jpeg_read_scanlines (&cinfo, rowptr, 1);
	  if (nrows != 1)
	    {
	      fprintf (stderr, "gd-jpeg: error: jpeg_read_scanlines"
		       " returns %u, expected 1\n", nrows);
	      goto error;
	    }
	  for (j = 0; j < cinfo.output_width; j++, currow += 3, tpix++)
	    {
	      *tpix = gdTrueColor (currow[0], currow[1], currow[2]);
	    }
	}
    }
  if (jpeg_finish_decompress (&cinfo) != TRUE)
    fprintf (stderr, "gd-jpeg: warning: jpeg_finish_decompress"
	     " reports suspended data source\n");
  /* TBB 2.0.29: we should do our best to read whatever we can read, and a 
    warning is a warning. A fatal error on warnings doesn't make sense. */
#if 0
  /* This was originally added by Truxton Fulton */
  if (cinfo.err->num_warnings > 0)
    goto error;
#endif

  jpeg_destroy_decompress (&cinfo);
  gdFree (row);
  return im;

error:
  jpeg_destroy_decompress (&cinfo);
  if (row)
    gdFree (row);
  if (im)
    gdImageDestroy (im);
  return 0;
}

/* A very basic conversion approach, TBB */

static int
CMYKToRGB (int c, int m, int y, int k, int inverted)
{
  if (inverted)
    {
      c = 255 - c;
      m = 255 - m;
      y = 255 - y;
      k = 255 - k;
    }
  return gdTrueColor ((255 - c) * (255 - k) / 255,
		      (255 - m) * (255 - k) / 255,
		      (255 - y) * (255 - k) / 255);
#if 0
  if (inverted)
    {
      c = 255 - c;
      m = 255 - m;
      y = 255 - y;
      k = 255 - k;
    }
  c = c * (255 - k) / 255 + k;
  if (c > 255)
    {
      c = 255;
    }
  if (c < 0)
    {
      c = 0;
    }
  m = m * (255 - k) / 255 + k;
  if (m > 255)
    {
      m = 255;
    }
  if (m < 0)
    {
      m = 0;
    }
  y = y * (255 - k) / 255 + k;
  if (y > 255)
    {
      y = 255;
    }
  if (y < 0)
    {
      y = 0;
    }
  c = 255 - c;
  m = 255 - m;
  y = 255 - y;
  return gdTrueColor (c, m, y);
#endif
}

/*

 * gdIOCtx JPEG data sources and sinks, T. Boutell
 * almost a simple global replace from T. Lane's stdio versions.
 *
 */

/* Different versions of libjpeg use either 'jboolean' or 'boolean', and
   some platforms define 'boolean', and so forth. Deal with this
   madness by typedeffing 'safeboolean' to 'boolean' if HAVE_BOOLEAN
   is already set, because this is the test that libjpeg uses.
   Otherwise, typedef it to int, because that's what libjpeg does
   if HAVE_BOOLEAN is not defined. -TBB */

#ifdef HAVE_BOOLEAN
typedef boolean safeboolean;
#else
typedef int safeboolean;
#endif /* HAVE_BOOLEAN */

/* Expanded data source object for gdIOCtx input */

typedef struct
{
  struct jpeg_source_mgr pub;	/* public fields */

  gdIOCtx *infile;		/* source stream */
  unsigned char *buffer;	/* start of buffer */
  safeboolean start_of_file;	/* have we gotten any data yet? */

}
my_source_mgr;

typedef my_source_mgr *my_src_ptr;

#define INPUT_BUF_SIZE  4096	/* choose an efficiently fread'able size */

/*
 * Initialize source --- called by jpeg_read_header
 * before any data is actually read.
 */

void
init_source (j_decompress_ptr cinfo)
{
  my_src_ptr src = (my_src_ptr) cinfo->src;

  /* We reset the empty-input-file flag for each image,
   * but we don't clear the input buffer.
   * This is correct behavior for reading a series of images from one source.
   */
  src->start_of_file = TRUE;
}


/*
 * Fill the input buffer --- called whenever buffer is emptied.
 *
 * In typical applications, this should read fresh data into the buffer
 * (ignoring the current state of next_input_byte & bytes_in_buffer),
 * reset the pointer & count to the start of the buffer, and return TRUE
 * indicating that the buffer has been reloaded.  It is not necessary to
 * fill the buffer entirely, only to obtain at least one more byte.
 *
 * There is no such thing as an EOF return.  If the end of the file has been
 * reached, the routine has a choice of ERREXIT() or inserting fake data into
 * the buffer.  In most cases, generating a warning message and inserting a
 * fake EOI marker is the best course of action --- this will allow the
 * decompressor to output however much of the image is there.  However,
 * the resulting error message is misleading if the real problem is an empty
 * input file, so we handle that case specially.
 *
 * In applications that need to be able to suspend compression due to input
 * not being available yet, a FALSE return indicates that no more data can be
 * obtained right now, but more may be forthcoming later.  In this situation,
 * the decompressor will return to its caller (with an indication of the
 * number of scanlines it has read, if any).  The application should resume
 * decompression after it has loaded more data into the input buffer.  Note
 * that there are substantial restrictions on the use of suspension --- see
 * the documentation.
 *
 * When suspending, the decompressor will back up to a convenient restart point
 * (typically the start of the current MCU). next_input_byte & bytes_in_buffer
 * indicate where the restart point will be if the current call returns FALSE.
 * Data beyond this point must be rescanned after resumption, so move it to
 * the front of the buffer rather than discarding it.
 */

#define END_JPEG_SEQUENCE "\r\n[*]--:END JPEG:--[*]\r\n"
safeboolean
fill_input_buffer (j_decompress_ptr cinfo)
{
  my_src_ptr src = (my_src_ptr) cinfo->src;
  /* 2.0.12: signed size. Thanks to Geert Jansen */
  /* 2.0.14: some platforms (mingw-msys) don't have ssize_t. Call 
     an int an int. */
  int nbytes = 0;
  memset (src->buffer, 0, INPUT_BUF_SIZE);

  while (nbytes < INPUT_BUF_SIZE)
    {

      int got = gdGetBuf (src->buffer + nbytes,
			  INPUT_BUF_SIZE - nbytes,
			  src->infile);

      if ((got == EOF) || (got == 0))
	{

	  /* EOF or error. If we got any data, don't worry about it.
	     If we didn't, then this is unexpected. */
	  if (!nbytes)
	    {

	      nbytes = -1;

	    }

	  break;

	}

      nbytes += got;

    }

  if (nbytes <= 0)
    {
      if (src->start_of_file)	/* Treat empty input file as fatal error */
	ERREXIT (cinfo, JERR_INPUT_EMPTY);
      WARNMS (cinfo, JWRN_JPEG_EOF);
      /* Insert a fake EOI marker */
      src->buffer[0] = (unsigned char) 0xFF;
      src->buffer[1] = (unsigned char) JPEG_EOI;
      nbytes = 2;
    }

  src->pub.next_input_byte = src->buffer;
  src->pub.bytes_in_buffer = nbytes;
  src->start_of_file = FALSE;

  return TRUE;
}


/*
 * Skip data --- used to skip over a potentially large amount of
 * uninteresting data (such as an APPn marker).
 *
 * Writers of suspendable-input applications must note that skip_input_data
 * is not granted the right to give a suspension return.  If the skip extends
 * beyond the data currently in the buffer, the buffer can be marked empty so
 * that the next read will cause a fill_input_buffer call that can suspend.
 * Arranging for additional bytes to be discarded before reloading the input
 * buffer is the application writer's problem.
 */

void
skip_input_data (j_decompress_ptr cinfo, long num_bytes)
{
  my_src_ptr src = (my_src_ptr) cinfo->src;

  /* Just a dumb implementation for now. Not clear that being smart is worth
   * any trouble anyway --- large skips are infrequent.
   */
  if (num_bytes > 0)
    {
      while (num_bytes > (long) src->pub.bytes_in_buffer)
	{
	  num_bytes -= (long) src->pub.bytes_in_buffer;
	  (void) fill_input_buffer (cinfo);
	  /* note we assume that fill_input_buffer will never return FALSE,
	   * so suspension need not be handled.
	   */
	}
      src->pub.next_input_byte += (size_t) num_bytes;
      src->pub.bytes_in_buffer -= (size_t) num_bytes;
    }
}


/*
 * An additional method that can be provided by data source modules is the
 * resync_to_restart method for error recovery in the presence of RST markers.
 * For the moment, this source module just uses the default resync method
 * provided by the JPEG library.  That method assumes that no backtracking
 * is possible.
 */


/*
 * Terminate source --- called by jpeg_finish_decompress
 * after all data has been read.  Often a no-op.
 *
 * NB: *not* called by jpeg_abort or jpeg_destroy; surrounding
 * application must deal with any cleanup that should happen even
 * for error exit.
 */

void
term_source (j_decompress_ptr cinfo)
{

#if 0
/* never used */
  my_src_ptr src = (my_src_ptr) cinfo->src;

#endif
}


/*
 * Prepare for input from a gdIOCtx stream.
 * The caller must have already opened the stream, and is responsible
 * for closing it after finishing decompression.
 */

void
jpeg_gdIOCtx_src (j_decompress_ptr cinfo, gdIOCtx * infile)
{
  my_src_ptr src;

  /* The source object and input buffer are made permanent so that a series
   * of JPEG images can be read from the same file by calling jpeg_gdIOCtx_src
   * only before the first one.  (If we discarded the buffer at the end of
   * one image, we'd likely lose the start of the next one.)
   * This makes it unsafe to use this manager and a different source
   * manager serially with the same JPEG object.  Caveat programmer.
   */
  if (cinfo->src == NULL)
    {				/* first time for this JPEG object? */
      cinfo->src = (struct jpeg_source_mgr *)
	(*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_PERMANENT,
				    sizeof (my_source_mgr));
      src = (my_src_ptr) cinfo->src;
      src->buffer = (unsigned char *)
	(*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_PERMANENT,
				    INPUT_BUF_SIZE * sizeof (unsigned char));

    }

  src = (my_src_ptr) cinfo->src;
  src->pub.init_source = init_source;
  src->pub.fill_input_buffer = fill_input_buffer;
  src->pub.skip_input_data = skip_input_data;
  src->pub.resync_to_restart = jpeg_resync_to_restart;	/* use default method */
  src->pub.term_source = term_source;
  src->infile = infile;
  src->pub.bytes_in_buffer = 0;	/* forces fill_input_buffer on first read */
  src->pub.next_input_byte = NULL;	/* until buffer loaded */
}

/* Expanded data destination object for stdio output */

typedef struct
{
  struct jpeg_destination_mgr pub;	/* public fields */
  gdIOCtx *outfile;		/* target stream */
  unsigned char *buffer;	/* start of buffer */
}
my_destination_mgr;

typedef my_destination_mgr *my_dest_ptr;

#define OUTPUT_BUF_SIZE  4096	/* choose an efficiently fwrite'able size */

/*
 * Initialize destination --- called by jpeg_start_compress
 * before any data is actually written.
 */

void
init_destination (j_compress_ptr cinfo)
{
  my_dest_ptr dest = (my_dest_ptr) cinfo->dest;

  /* Allocate the output buffer --- it will be released when done with image */
  dest->buffer = (unsigned char *)
    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
				OUTPUT_BUF_SIZE * sizeof (unsigned char));

  dest->pub.next_output_byte = dest->buffer;
  dest->pub.free_in_buffer = OUTPUT_BUF_SIZE;
}


/*
 * Empty the output buffer --- called whenever buffer fills up.
 *
 * In typical applications, this should write the entire output buffer
 * (ignoring the current state of next_output_byte & free_in_buffer),
 * reset the pointer & count to the start of the buffer, and return TRUE
 * indicating that the buffer has been dumped.
 *
 * In applications that need to be able to suspend compression due to output
 * overrun, a FALSE return indicates that the buffer cannot be emptied now.
 * In this situation, the compressor will return to its caller (possibly with
 * an indication that it has not accepted all the supplied scanlines).  The
 * application should resume compression after it has made more room in the
 * output buffer.  Note that there are substantial restrictions on the use of
 * suspension --- see the documentation.
 *
 * When suspending, the compressor will back up to a convenient restart point
 * (typically the start of the current MCU). next_output_byte & free_in_buffer
 * indicate where the restart point will be if the current call returns FALSE.
 * Data beyond this point will be regenerated after resumption, so do not
 * write it out when emptying the buffer externally.
 */

safeboolean
empty_output_buffer (j_compress_ptr cinfo)
{
  my_dest_ptr dest = (my_dest_ptr) cinfo->dest;

  if (gdPutBuf (dest->buffer, OUTPUT_BUF_SIZE, dest->outfile) !=
      (size_t) OUTPUT_BUF_SIZE)
    ERREXIT (cinfo, JERR_FILE_WRITE);

  dest->pub.next_output_byte = dest->buffer;
  dest->pub.free_in_buffer = OUTPUT_BUF_SIZE;

  return TRUE;
}


/*
 * Terminate destination --- called by jpeg_finish_compress
 * after all data has been written.  Usually needs to flush buffer.
 *
 * NB: *not* called by jpeg_abort or jpeg_destroy; surrounding
 * application must deal with any cleanup that should happen even
 * for error exit.
 */

void
term_destination (j_compress_ptr cinfo)
{
  my_dest_ptr dest = (my_dest_ptr) cinfo->dest;
  size_t datacount = OUTPUT_BUF_SIZE - dest->pub.free_in_buffer;

  /* Write any data remaining in the buffer */
  if (datacount > 0)
    {
      if (gdPutBuf (dest->buffer, datacount, dest->outfile) != datacount)
	ERREXIT (cinfo, JERR_FILE_WRITE);
    }
}


/*
 * Prepare for output to a stdio stream.
 * The caller must have already opened the stream, and is responsible
 * for closing it after finishing compression.
 */

void
jpeg_gdIOCtx_dest (j_compress_ptr cinfo, gdIOCtx * outfile)
{
  my_dest_ptr dest;

  /* The destination object is made permanent so that multiple JPEG images
   * can be written to the same file without re-executing jpeg_stdio_dest.
   * This makes it dangerous to use this manager and a different destination
   * manager serially with the same JPEG object, because their private object
   * sizes may be different.  Caveat programmer.
   */
  if (cinfo->dest == NULL)
    {				/* first time for this JPEG object? */
      cinfo->dest = (struct jpeg_destination_mgr *)
	(*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_PERMANENT,
				    sizeof (my_destination_mgr));
    }

  dest = (my_dest_ptr) cinfo->dest;
  dest->pub.init_destination = init_destination;
  dest->pub.empty_output_buffer = empty_output_buffer;
  dest->pub.term_destination = term_destination;
  dest->outfile = outfile;
}

#endif /* HAVE_LIBJPEG */
 25181       240044      185542      1193070200  200         0           100640      8   gd_png.c`
/* $Id: gd_png.c,v 1.21.2.2 2007/05/17 14:38:24 pajoye Exp $ */
#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include <stdio.h>
#include <math.h>
#include <string.h>
#include <stdlib.h>
#include "gd.h"

/* JCE: Arrange HAVE_LIBPNG so that it can be set in gd.h */
#ifdef HAVE_LIBPNG

#include "gdhelpers.h"
#include "png.h"		/* includes zlib.h and setjmp.h */

#define TRUE 1
#define FALSE 0

/*---------------------------------------------------------------------------

    gd_png.c                 Copyright 1999 Greg Roelofs and Thomas Boutell

    The routines in this file, gdImagePng*() and gdImageCreateFromPng*(),
    are drop-in replacements for gdImageGif*() and gdImageCreateFromGif*(),
    except that these functions are noisier in the case of errors (comment
    out all fprintf() statements to disable that).

    GD 2.0 supports RGBA truecolor and will read and write truecolor PNGs.
    GD 2.0 supports 8 bits of color resolution per channel and 
    7 bits of alpha channel resolution. Images with more than 8 bits
    per channel are reduced to 8 bits. Images with an alpha channel are
    only able to resolve down to '1/128th opaque' instead of '1/256th',
    and this conversion is also automatic. I very much doubt you can see it.
    Both tRNS and true alpha are supported.

    Gamma is ignored, and there is no support for text annotations.

    Last updated:  9 February 2001

  ---------------------------------------------------------------------------*/

#ifndef PNG_SETJMP_NOT_SUPPORTED
typedef struct _jmpbuf_wrapper
{
  jmp_buf jmpbuf;
}
jmpbuf_wrapper;

static jmpbuf_wrapper gdPngJmpbufStruct;

static void
gdPngErrorHandler (png_structp png_ptr, png_const_charp msg)
{
  jmpbuf_wrapper *jmpbuf_ptr;

  /* This function, aside from the extra step of retrieving the "error
   * pointer" (below) and the fact that it exists within the application
   * rather than within libpng, is essentially identical to libpng's
   * default error handler.  The second point is critical:  since both
   * setjmp() and longjmp() are called from the same code, they are
   * guaranteed to have compatible notions of how big a jmp_buf is,
   * regardless of whether _BSD_SOURCE or anything else has (or has not)
   * been defined. */

  fprintf (stderr, "gd-png:  fatal libpng error: %s\n", msg);
  fflush (stderr);

  jmpbuf_ptr = png_get_error_ptr (png_ptr);
  if (jmpbuf_ptr == NULL) {				/* we are completely hosed now */
      fprintf (stderr, "gd-png:  EXTREMELY fatal error: jmpbuf unrecoverable; terminating.\n");
      fflush (stderr);
      exit (99);
    }

  longjmp (jmpbuf_ptr->jmpbuf, 1);
}
#endif

static void
gdPngReadData (png_structp png_ptr, png_bytep data, png_size_t length)
{
  int check;
  check = gdGetBuf (data, length, (gdIOCtx *) png_get_io_ptr (png_ptr));
  if (check != length) {
    png_error(png_ptr, "Read Error: truncated data");
  }
}

static void
gdPngWriteData (png_structp png_ptr, png_bytep data, png_size_t length)
{
  gdPutBuf (data, length, (gdIOCtx *) png_get_io_ptr (png_ptr));
}

static void
gdPngFlushData (png_structp png_ptr)
{
}

BGD_DECLARE(gdImagePtr) gdImageCreateFromPng (FILE * inFile)
{
  gdImagePtr im;
  gdIOCtx *in = gdNewFileCtx (inFile);
  im = gdImageCreateFromPngCtx (in);
  in->gd_free (in);
  return im;
}

BGD_DECLARE(gdImagePtr) gdImageCreateFromPngPtr (int size, void *data)
{
  gdImagePtr im;
  gdIOCtx *in = gdNewDynamicCtxEx (size, data, 0);
  im = gdImageCreateFromPngCtx (in);
  in->gd_free (in);
  return im;
}

/* This routine is based in part on the Chapter 13 demo code in "PNG: The
 *  Definitive Guide" (http://www.cdrom.com/pub/png/pngbook.html).
 */
BGD_DECLARE(gdImagePtr) gdImageCreateFromPngCtx (gdIOCtx * infile)
{
  png_byte sig[8];
  png_structp png_ptr;
  png_infop info_ptr;
	png_uint_32 width, height, rowbytes, w, h;
  int bit_depth, color_type, interlace_type;
  int num_palette, num_trans;
  png_colorp palette;
  png_color_16p trans_gray_rgb;
  png_color_16p trans_color_rgb;
  png_bytep trans;
  png_bytep image_data = NULL;
  png_bytepp row_pointers = NULL;
  gdImagePtr im = NULL;
  int i, j, *open = NULL;
  volatile int transparent = -1;
  volatile int palette_allocated = FALSE;

  /* Make sure the signature can't match by dumb luck -- TBB */
  /* GRR: isn't sizeof(infile) equal to the size of the pointer? */
	memset (sig, 0, sizeof (sig));

  /* first do a quick check that the file really is a PNG image; could
   * have used slightly more general png_sig_cmp() function instead */
  if (gdGetBuf (sig, 8, infile) < 8) {
	return NULL;
  }

	if (!png_check_sig (sig, 8)) { /* bad signature */
    	return NULL;		/* bad signature */
	}

#ifndef PNG_SETJMP_NOT_SUPPORTED
  png_ptr = png_create_read_struct (PNG_LIBPNG_VER_STRING, &gdPngJmpbufStruct, gdPngErrorHandler, NULL);
#else
  png_ptr = png_create_read_struct (PNG_LIBPNG_VER_STRING, NULL, NULL, NULL);
#endif
  if (png_ptr == NULL) {
      fprintf (stderr, "gd-png error: cannot allocate libpng main struct\n");
      return NULL;
    }

  info_ptr = png_create_info_struct (png_ptr);
  if (info_ptr == NULL) {
      fprintf (stderr, "gd-png error: cannot allocate libpng info struct\n");
      png_destroy_read_struct (&png_ptr, NULL, NULL);

      return NULL;
    }

  /* we could create a second info struct here (end_info), but it's only
   * useful if we want to keep pre- and post-IDAT chunk info separated
   * (mainly for PNG-aware image editors and converters) 
	*/

  /* setjmp() must be called in every non-callback function that calls a
   * PNG-reading libpng function */
#ifndef PNG_SETJMP_NOT_SUPPORTED
  if (setjmp (gdPngJmpbufStruct.jmpbuf)) {
      fprintf (stderr, "gd-png error: setjmp returns error condition 1\n");
      png_destroy_read_struct (&png_ptr, &info_ptr, NULL);

      return NULL;
    }
#endif

  png_set_sig_bytes (png_ptr, 8);	/* we already read the 8 signature bytes */

  png_set_read_fn (png_ptr, (void *) infile, gdPngReadData);
  png_read_info (png_ptr, info_ptr);	/* read all PNG info up to image data */

  png_get_IHDR (png_ptr, info_ptr, &width, &height, &bit_depth, &color_type, &interlace_type, NULL, NULL);
  if ((color_type == PNG_COLOR_TYPE_RGB) || (color_type == PNG_COLOR_TYPE_RGB_ALPHA)) {
      im = gdImageCreateTrueColor ((int) width, (int) height);
    } else {
      im = gdImageCreate ((int) width, (int) height);
    }
  if (im == NULL) {
      fprintf (stderr, "gd-png error: cannot allocate gdImage struct\n");
      png_destroy_read_struct (&png_ptr, &info_ptr, NULL);
      gdFree (image_data);
      gdFree (row_pointers);

      return NULL;
    }

  if (bit_depth == 16) {
    png_set_strip_16 (png_ptr);
  } else if (bit_depth < 8) {
    png_set_packing (png_ptr);	/* expand to 1 byte per pixel */
	}

	/* setjmp() must be called in every non-callback function that calls a
	 * PNG-reading libpng function
	 */
#ifndef PNG_SETJMP_NOT_SUPPORTED
	if (setjmp(gdPngJmpbufStruct.jmpbuf)) {
		fprintf(stderr, "gd-png error: setjmp returns error condition 2");
		png_destroy_read_struct(&png_ptr, &info_ptr, NULL);
		gdFree(image_data);
		gdFree(row_pointers);
		if (im) {
			gdImageDestroy(im);
		}
		return NULL;
	}
#endif

  switch (color_type) {
    case PNG_COLOR_TYPE_PALETTE:
      png_get_PLTE (png_ptr, info_ptr, &palette, &num_palette);
#ifdef DEBUG
      fprintf (stderr, "gd-png color_type is palette, colors: %d\n", num_palette);
#endif /* DEBUG */
      if (png_get_valid (png_ptr, info_ptr, PNG_INFO_tRNS)) {
				/* gd 2.0: we support this rather thoroughly now. Grab the
				 * first fully transparent entry, if any, as the value of
				 * the simple-transparency index, mostly for backwards
				 * binary compatibility. The alpha channel is where it's
				 * really at these days.
				 */
	  int firstZero = 1;
	  png_get_tRNS (png_ptr, info_ptr, &trans, &num_trans, NULL);
	  for (i = 0; i < num_trans; ++i) {
	      im->alpha[i] = gdAlphaMax - (trans[i] >> 1);
	      if ((trans[i] == 0) && (firstZero)) {
		  /* 2.0.5: long-forgotten patch from Wez Furlong */
		  transparent = i;
		  firstZero = 0;
		}
	    }
	}
      break;

    case PNG_COLOR_TYPE_GRAY:
    case PNG_COLOR_TYPE_GRAY_ALPHA:
      /* create a fake palette and check for single-shade transparency */
      if ((palette = (png_colorp) gdMalloc (256 * sizeof (png_color))) == NULL) {
	  fprintf (stderr, "gd-png error: cannot allocate gray palette\n");
	  png_destroy_read_struct (&png_ptr, &info_ptr, NULL);
	  return NULL;
	}
      palette_allocated = TRUE;
      if (bit_depth < 8) {
	  num_palette = 1 << bit_depth;
	  for (i = 0; i < 256; ++i) {
	      j = (255 * i) / (num_palette - 1);
	      palette[i].red = palette[i].green = palette[i].blue = j;
	    }
	} else {
	  num_palette = 256;
	  for (i = 0; i < 256; ++i) {
	      palette[i].red = palette[i].green = palette[i].blue = i;
	    }
	}
      if (png_get_valid (png_ptr, info_ptr, PNG_INFO_tRNS)) {
	  png_get_tRNS (png_ptr, info_ptr, NULL, NULL, &trans_gray_rgb);
	  if (bit_depth == 16) {	/* png_set_strip_16() not yet in effect */
	    transparent = trans_gray_rgb->gray >> 8;
	 } else {
	    transparent = trans_gray_rgb->gray;
	}
	  /* Note slight error in 16-bit case:  up to 256 16-bit shades
	   * may get mapped to a single 8-bit shade, and only one of them
	   * is supposed to be transparent.  IOW, both opaque pixels and
	   * transparent pixels will be mapped into the transparent entry.
	   * There is no particularly good way around this in the case
	   * that all 256 8-bit shades are used, but one could write some
	   * custom 16-bit code to handle the case where there are gdFree
	   * palette entries.  This error will be extremely rare in
	   * general, though.  (Quite possibly there is only one such
	   * image in existence.) */
	}
      break;

    case PNG_COLOR_TYPE_RGB:
    case PNG_COLOR_TYPE_RGB_ALPHA:
      /* gd 2.0: we now support truecolor. See the comment above
         for a rare situation in which the transparent pixel may not
         work properly with 16-bit channels. */
      if (png_get_valid (png_ptr, info_ptr, PNG_INFO_tRNS)) {
	  png_get_tRNS (png_ptr, info_ptr, NULL, NULL, &trans_color_rgb);
	  if (bit_depth == 16) {	/* png_set_strip_16() not yet in effect */
	    transparent = gdTrueColor (trans_color_rgb->red >> 8,
				       trans_color_rgb->green >> 8,
				       trans_color_rgb->blue >> 8);
	 } else {
	    transparent = gdTrueColor (trans_color_rgb->red,
				       trans_color_rgb->green,
				       trans_color_rgb->blue);
	}
	}
      break;
    }

  png_read_update_info (png_ptr, info_ptr);

  /* allocate space for the PNG image data */
  rowbytes = png_get_rowbytes (png_ptr, info_ptr);
  if (overflow2(rowbytes, height)) {
    png_destroy_read_struct (&png_ptr, &info_ptr, NULL);
    return NULL;
  }
	image_data = (png_bytep) gdMalloc (rowbytes * height);
  if (!image_data) {
      fprintf (stderr, "gd-png error: cannot allocate image data\n");
      png_destroy_read_struct (&png_ptr, &info_ptr, NULL);
	if (im) {
		gdImageDestroy(im);
	}
      return NULL;
    }
  if (overflow2(height, sizeof (png_bytep))) {
    png_destroy_read_struct (&png_ptr, &info_ptr, NULL);
    gdFree (image_data);
	if (im) {
		gdImageDestroy(im);
	}
    return NULL;
  }

	row_pointers = (png_bytepp) gdMalloc (height * sizeof (png_bytep));    
  if (!row_pointers) {
      fprintf (stderr, "gd-png error: cannot allocate row pointers\n");
      png_destroy_read_struct (&png_ptr, &info_ptr, NULL);
	if (im) {
		gdImageDestroy(im);
	}
      gdFree (image_data);
      return NULL;
    }

  /* set the individual row_pointers to point at the correct offsets */
	for (h = 0; h < height; ++h) {
		row_pointers[h] = image_data + h * rowbytes;
    }

  png_read_image (png_ptr, row_pointers);	/* read whole image... */
  png_read_end (png_ptr, NULL);	/* ...done! */

  if (!im->trueColor) {
      im->colorsTotal = num_palette;
      /* load the palette and mark all entries "open" (unused) for now */
      open = im->open;
      for (i = 0; i < num_palette; ++i) {
	  im->red[i] = palette[i].red;
	  im->green[i] = palette[i].green;
	  im->blue[i] = palette[i].blue;
	  open[i] = 1;
	}
      for (i = num_palette; i < gdMaxColors; ++i) {
	  open[i] = 1;
		}
    }
  /* 2.0.12: Slaven Rezic: palette images are not the only images
     with a simple transparent color setting */
  im->transparent = transparent;
  im->interlace = (interlace_type == PNG_INTERLACE_ADAM7);

  /* can't nuke structs until done with palette */
  png_destroy_read_struct (&png_ptr, &info_ptr, NULL);
  switch (color_type) {
    case PNG_COLOR_TYPE_RGB:
			for (h = 0; h < height; h++) {
	  int boffset = 0;
				for (w = 0; w < width; w++) {
					register png_byte r = row_pointers[h][boffset++];
					register png_byte g = row_pointers[h][boffset++];
					register png_byte b = row_pointers[h][boffset++];
					im->tpixels[h][w] = gdTrueColor (r, g, b);
	    }
	}
      break;
    case PNG_COLOR_TYPE_RGB_ALPHA:
			for (h = 0; h < height; h++) {
	  int boffset = 0;
				for (w = 0; w < width; w++) {
					register png_byte r = row_pointers[h][boffset++];
					register png_byte g = row_pointers[h][boffset++];
					register png_byte b = row_pointers[h][boffset++];

   /* gd has only 7 bits of alpha channel resolution, and
	* 127 is transparent, 0 opaque. A moment of convenience,
	*  a lifetime of compatibility.
	*/

					register png_byte a = gdAlphaMax - (row_pointers[h][boffset++] >> 1);
					im->tpixels[h][w] = gdTrueColorAlpha(r, g, b, a);
	    }
	}
      break;
    default:
      /* Palette image, or something coerced to be one */
			for (h = 0; h < height; ++h) {
				for (w = 0; w < width; ++w) {
					register png_byte idx = row_pointers[h][w];
					im->pixels[h][w] = idx;
	      open[idx] = 0;
	    }
	}
    }
#ifdef DEBUG
  if (!im->trueColor) {
      for (i = num_palette; i < gdMaxColors; ++i) {
	  if (!open[i]) {
	      fprintf (stderr,
		       "gd-png warning: image data references out-of-range"
		       " color index (%d)\n", i);
	    }
	}
    }
#endif

  if (palette_allocated) {
    gdFree (palette);
	}
  gdFree (image_data);
  gdFree (row_pointers);

  return im;
}


BGD_DECLARE(void) gdImagePngEx (gdImagePtr im, FILE * outFile, int level)
{
  gdIOCtx *out = gdNewFileCtx (outFile);
  gdImagePngCtxEx (im, out, level);
  out->gd_free (out);
}

BGD_DECLARE(void) gdImagePng (gdImagePtr im, FILE * outFile)
{
  gdIOCtx *out = gdNewFileCtx (outFile);
  gdImagePngCtxEx (im, out, -1);
  out->gd_free (out);
}

BGD_DECLARE(void *) gdImagePngPtr (gdImagePtr im, int *size)
{
  void *rv;
  gdIOCtx *out = gdNewDynamicCtx (2048, NULL);
  gdImagePngCtxEx (im, out, -1);
  rv = gdDPExtractData (out, size);
  out->gd_free (out);
  return rv;
}

BGD_DECLARE(void *) gdImagePngPtrEx (gdImagePtr im, int *size, int level)
{
  void *rv;
  gdIOCtx *out = gdNewDynamicCtx (2048, NULL);
  gdImagePngCtxEx (im, out, level);
  rv = gdDPExtractData (out, size);
  out->gd_free (out);
  return rv;
}

BGD_DECLARE(void) gdImagePngCtx (gdImagePtr im, gdIOCtx * outfile)
{
  /* 2.0.13: 'return' here was an error, thanks to Kevin Smith */
  gdImagePngCtxEx (im, outfile, -1);
}

/* This routine is based in part on code from Dale Lutz (Safe Software Inc.)
 *  and in part on demo code from Chapter 15 of "PNG: The Definitive Guide"
 *  (http://www.cdrom.com/pub/png/pngbook.html).
 */
BGD_DECLARE(void) gdImagePngCtxEx (gdImagePtr im, gdIOCtx * outfile, int level)
{
  int i, j, bit_depth = 0, interlace_type;
  int width = im->sx;
  int height = im->sy;
  int colors = im->colorsTotal;
  int *open = im->open;
  int mapping[gdMaxColors];	/* mapping[gd_index] == png_index */
  png_byte trans_values[256];
  png_color_16 trans_rgb_value;
  png_color palette[gdMaxColors];
  png_structp png_ptr;
  png_infop info_ptr;
  volatile int transparent = im->transparent;
  volatile int remap = FALSE;

#ifndef PNG_SETJMP_NOT_SUPPORTED
  png_ptr = png_create_write_struct (PNG_LIBPNG_VER_STRING,
				     &gdPngJmpbufStruct, gdPngErrorHandler,
				     NULL);
#else
  png_ptr = png_create_write_struct (PNG_LIBPNG_VER_STRING, NULL, NULL, NULL);
#endif
  if (png_ptr == NULL)
    {
      fprintf (stderr, "gd-png error: cannot allocate libpng main struct\n");
      return;
    }

  info_ptr = png_create_info_struct (png_ptr);
  if (info_ptr == NULL)
    {
      fprintf (stderr, "gd-png error: cannot allocate libpng info struct\n");
      png_destroy_write_struct (&png_ptr, (png_infopp) NULL);
      return;
    }

#ifndef PNG_SETJMP_NOT_SUPPORTED
  if (setjmp (gdPngJmpbufStruct.jmpbuf))
    {
      fprintf (stderr, "gd-png error: setjmp returns error condition\n");
      png_destroy_write_struct (&png_ptr, &info_ptr);
      return;
    }
#endif

  png_set_write_fn (png_ptr, (void *) outfile, gdPngWriteData,
		    gdPngFlushData);

  /* This is best for palette images, and libpng defaults to it for
     palette images anyway, so we don't need to do it explicitly.
     What to ideally do for truecolor images depends, alas, on the image.
     gd is intentionally imperfect and doesn't spend a lot of time
     fussing with such things. */

  /* Faster if this is uncommented, but may produce larger truecolor files.
     Wait for gdImagePngCtxEx. */
#if 0
  png_set_filter (png_ptr, 0, PNG_FILTER_NONE);
#endif

  /* 2.0.12: this is finally a parameter */
  png_set_compression_level (png_ptr, level);

  /* can set this to a smaller value without compromising compression if all
   * image data is 16K or less; will save some decoder memory [min == 8] */
/*  png_set_compression_window_bits(png_ptr, 15);  */

  if (!im->trueColor)
    {
      if (transparent >= im->colorsTotal ||
	  (transparent >= 0 && open[transparent]))
	transparent = -1;
    }
  if (!im->trueColor)
    {
      for (i = 0; i < gdMaxColors; ++i)
	mapping[i] = -1;
    }
  if (!im->trueColor)
    {
      /* count actual number of colors used (colorsTotal == high-water mark) */
      colors = 0;
      for (i = 0; i < im->colorsTotal; ++i)
	{
	  if (!open[i])
	    {
	      mapping[i] = colors;
	      ++colors;
	    }
	}
      if (colors < im->colorsTotal)
	{
	  remap = TRUE;
	}
      if (colors <= 2)
	bit_depth = 1;
      else if (colors <= 4)
	bit_depth = 2;
      else if (colors <= 16)
	bit_depth = 4;
      else
	bit_depth = 8;
    }
  interlace_type = im->interlace ? PNG_INTERLACE_ADAM7 : PNG_INTERLACE_NONE;

  if (im->trueColor)
    {
      if (im->saveAlphaFlag)
	{
	  png_set_IHDR (png_ptr, info_ptr, width, height, 8,
			PNG_COLOR_TYPE_RGB_ALPHA, interlace_type,
			PNG_COMPRESSION_TYPE_DEFAULT,
			PNG_FILTER_TYPE_DEFAULT);
	}
      else
	{
	  png_set_IHDR (png_ptr, info_ptr, width, height, 8,
			PNG_COLOR_TYPE_RGB, interlace_type,
			PNG_COMPRESSION_TYPE_DEFAULT,
			PNG_FILTER_TYPE_DEFAULT);
	}
    }
  else
    {
      png_set_IHDR (png_ptr, info_ptr, width, height, bit_depth,
		    PNG_COLOR_TYPE_PALETTE, interlace_type,
		    PNG_COMPRESSION_TYPE_DEFAULT, PNG_FILTER_TYPE_DEFAULT);
    }
  if (im->trueColor && (!im->saveAlphaFlag) && (transparent >= 0))
    {
      /* 2.0.9: fixed by Thomas Winzig */
      trans_rgb_value.red = gdTrueColorGetRed (im->transparent);
      trans_rgb_value.green = gdTrueColorGetGreen (im->transparent);
      trans_rgb_value.blue = gdTrueColorGetBlue (im->transparent);
      png_set_tRNS (png_ptr, info_ptr, 0, 0, &trans_rgb_value);
    }
  if (!im->trueColor)
    {
      /* Oy veh. Remap the PNG palette to put the 
         entries with interesting alpha channel
         values first. This minimizes the size
         of the tRNS chunk and thus the size
         of the PNG file as a whole. */
      int tc = 0;
      int i;
      int j;
      int k;
      for (i = 0; (i < im->colorsTotal); i++)
	{
	  if ((!im->open[i]) && (im->alpha[i] != gdAlphaOpaque))
	    {
	      tc++;
	    }
	}
      if (tc)
	{
#if 0
	  for (i = 0; (i < im->colorsTotal); i++)
	    {
	      trans_values[i] = 255 -
		((im->alpha[i] << 1) + (im->alpha[i] >> 6));
	    }
	  png_set_tRNS (png_ptr, info_ptr, trans_values, 256, NULL);
#endif
	  if (!remap)
	    {
	      remap = TRUE;
	    }
	  /* (Semi-)transparent indexes come up from the bottom
	     of the list of real colors; opaque
	     indexes come down from the top */
	  j = 0;
	  k = colors - 1;
	  for (i = 0; (i < im->colorsTotal); i++)
	    {
	      if (!im->open[i])
		{
		  if (im->alpha[i] != gdAlphaOpaque)
		    {
		      /* Andrew Hull: >> 6, not >> 7! (gd 2.0.5) */
		      trans_values[j] = 255 -
			((im->alpha[i] << 1) + (im->alpha[i] >> 6));
		      mapping[i] = j++;
		    }
		  else
		    {
		      mapping[i] = k--;
		    }
		}
	    }
	  png_set_tRNS (png_ptr, info_ptr, trans_values, tc, NULL);
	}
    }

  /* convert palette to libpng layout */
  if (!im->trueColor)
    {
      if (remap)
	for (i = 0; i < im->colorsTotal; ++i)
	  {
	    if (mapping[i] < 0)
	      continue;
	    palette[mapping[i]].red = im->red[i];
	    palette[mapping[i]].green = im->green[i];
	    palette[mapping[i]].blue = im->blue[i];
	  }
      else
	for (i = 0; i < colors; ++i)
	  {
	    palette[i].red = im->red[i];
	    palette[i].green = im->green[i];
	    palette[i].blue = im->blue[i];
	  }
      png_set_PLTE (png_ptr, info_ptr, palette, colors);
    }

  /* write out the PNG header info (everything up to first IDAT) */
  png_write_info (png_ptr, info_ptr);

  /* make sure < 8-bit images are packed into pixels as tightly as possible */
  png_set_packing (png_ptr);

  /* This code allocates a set of row buffers and copies the gd image data
   * into them only in the case that remapping is necessary; in gd 1.3 and
   * later, the im->pixels array is laid out identically to libpng's row
   * pointers and can be passed to png_write_image() function directly.
   * The remapping case could be accomplished with less memory for non-
   * interlaced images, but interlacing causes some serious complications. */
  if (im->trueColor)
    {
      /* performance optimizations by Phong Tran */
      int channels = im->saveAlphaFlag ? 4 : 3;
      /* Our little 7-bit alpha channel trick costs us a bit here. */
      png_bytep *row_pointers;
      unsigned char *pOutputRow;
      int **ptpixels = im->tpixels;
      int *pThisRow;
      unsigned char a;
      int thisPixel;
      png_bytep *prow_pointers;
      int saveAlphaFlag = im->saveAlphaFlag;
      if (overflow2(sizeof (png_bytep), height)) {
        return;
      } 
      row_pointers = gdMalloc (sizeof (png_bytep) * height);
      if (row_pointers == NULL)
	{
	  fprintf (stderr, "gd-png error: unable to allocate row_pointers\n");
          /* 2.0.29: return was missing */
          return;
	}
      prow_pointers = row_pointers;
      for (j = 0; j < height; ++j)
	{
          if (overflow2(width, channels) || ((*prow_pointers =
	       (png_bytep) gdMalloc (width * channels)) == NULL))
	    {
	      fprintf (stderr, "gd-png error: unable to allocate rows\n");
	      for (i = 0; i < j; ++i)
		gdFree (row_pointers[i]);
              /* 2.0.29: memory leak TBB */
              gdFree(row_pointers);
	      return;
	    }
	  pOutputRow = *prow_pointers++;
	  pThisRow = *ptpixels++;
	  for (i = 0; i < width; ++i)
	    {
	      thisPixel = *pThisRow++;
	      *pOutputRow++ = gdTrueColorGetRed (thisPixel);
	      *pOutputRow++ = gdTrueColorGetGreen (thisPixel);
	      *pOutputRow++ = gdTrueColorGetBlue (thisPixel);

	      if (saveAlphaFlag)
		{
		  /* convert the 7-bit alpha channel to an 8-bit alpha channel.
		     We do a little bit-flipping magic, repeating the MSB
		     as the LSB, to ensure that 0 maps to 0 and
		     127 maps to 255. We also have to invert to match
		     PNG's convention in which 255 is opaque. */
		  a = gdTrueColorGetAlpha (thisPixel);
		  /* Andrew Hull: >> 6, not >> 7! (gd 2.0.5) */
		  *pOutputRow++ = 255 - ((a << 1) + (a >> 6));
		}
	    }
	}

      png_write_image (png_ptr, row_pointers);
      png_write_end (png_ptr, info_ptr);

      for (j = 0; j < height; ++j)
	gdFree (row_pointers[j]);
      gdFree (row_pointers);
    }
  else
    {
      if (remap)
	{
	  png_bytep *row_pointers;
          if (overflow2(sizeof (png_bytep), height)) {
            return;
          }
	  row_pointers = gdMalloc (sizeof (png_bytep) * height);
	  if (row_pointers == NULL)
	    {
	      fprintf (stderr,
		       "gd-png error: unable to allocate row_pointers\n");
              /* TBB: return missing */
              return;
	    }
	  for (j = 0; j < height; ++j)
	    {
	      if ((row_pointers[j] = (png_bytep) gdMalloc (width)) == NULL)
		{
		  fprintf (stderr, "gd-png error: unable to allocate rows\n");
		  for (i = 0; i < j; ++i)
		    gdFree (row_pointers[i]);
                  /* TBB: memory leak */
		  gdFree (row_pointers);
		  return;
		}
	      for (i = 0; i < width; ++i)
		row_pointers[j][i] = mapping[im->pixels[j][i]];
	    }

	  png_write_image (png_ptr, row_pointers);
	  png_write_end (png_ptr, info_ptr);

	  for (j = 0; j < height; ++j)
	    gdFree (row_pointers[j]);
	  gdFree (row_pointers);
	}
      else
	{
	  png_write_image (png_ptr, im->pixels);
	  png_write_end (png_ptr, info_ptr);
	}
    }
  /* 1.6.3: maybe we should give that memory BACK! TBB */
  png_destroy_write_struct (&png_ptr, &info_ptr);
}


#endif /* HAVE_LIBPNG */
 691         240840      214764      1193070200  200         0           100640      13  gd_security.c `
/*
   * gd_security.c
   *
   * Implements buffer overflow check routines.
   *
   * Written 2004, Phil Knirsch.
   * Based on netpbm fixes by Alan Cox.
   *
 */

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include <stdio.h>
#include <stdlib.h>
#include <limits.h>
#include "gd.h"

int overflow2(int a, int b)
{
	if(a < 0 || b < 0) {
		fprintf(stderr, "gd warning: one parameter to a memory allocation multiplication is negative, failing operation gracefully\n");
		return 1;
	}
	if(b == 0)
		return 0;
	if(a > INT_MAX / b) {
		fprintf(stderr, "gd warning: product of memory allocation multiplication would exceed INT_MAX, failing operation gracefully\n");
		return 1;
	}
	return 0;
}
 1077        242016      240044      1193070200  200         0           100640      7   gd_ss.c `

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include <stdio.h>
#include <math.h>
#include <string.h>
#include <stdlib.h>
#include "gd.h"

#define TRUE 1
#define FALSE 0

/* Use this for commenting out debug-print statements. */
/* Just use the first '#define' to allow all the prints... */
/*#define GD_SS_DBG(s) (s) */
#define GD_SS_DBG(s)

#ifdef HAVE_LIBPNG
BGD_DECLARE(void) gdImagePngToSink (gdImagePtr im, gdSinkPtr outSink)
{
  gdIOCtx *out = gdNewSSCtx (NULL, outSink);
  gdImagePngCtx (im, out);
  out->gd_free (out);
}

BGD_DECLARE(gdImagePtr) gdImageCreateFromPngSource (gdSourcePtr inSource)
{
  gdIOCtx *in = gdNewSSCtx (inSource, NULL);
  gdImagePtr im;

  im = gdImageCreateFromPngCtx (in);

  in->gd_free (in);

  return im;
}
#else /* no HAVE_LIBPNG */
BGD_DECLARE(void) gdImagePngToSink (gdImagePtr im, gdSinkPtr outSink)
{
  fprintf (stderr, "PNG support is not available\n");
}

BGD_DECLARE(gdImagePtr) gdImageCreateFromPngSource (gdSourcePtr inSource)
{
  fprintf (stderr, "PNG support is not available\n");
  return NULL;
}
#endif /* HAVE_LIBPNG */
 64788       306904      240840      1193070201  200         0           100640      10  gd_topal.c`
/* TODO: oim and nim in the lower level functions;
  correct use of stub (sigh). */

/* 2.0.12: a new adaptation from the same original, this time
	by Barend Gehrels. My attempt to incorporate alpha channel
	into the result worked poorly and degraded the quality of
	palette conversion even when the source contained no
	alpha channel data. This version does not attempt to produce
	an output file with transparency in some of the palette
	indexes, which, in practice, doesn't look so hot anyway. TBB */

/*
 * gd_topal, adapted from jquant2.c
 *
 * Copyright (C) 1991-1996, Thomas G. Lane.
 * This file is part of the Independent JPEG Group's software.
 * For conditions of distribution and use, see the accompanying README file.
 *
 * This file contains 2-pass color quantization (color mapping) routines.
 * These routines provide selection of a custom color map for an image,
 * followed by mapping of the image to that color map, with optional
 * Floyd-Steinberg dithering.
 * It is also possible to use just the second pass to map to an arbitrary
 * externally-given color map.
 *
 * Note: ordered dithering is not supported, since there isn't any fast
 * way to compute intercolor distances; it's unclear that ordered dither's
 * fundamental assumptions even hold with an irregularly spaced color map.
 */

#ifdef ORIGINAL_LIB_JPEG

#define JPEG_INTERNALS

#include "jinclude.h"
#include "jpeglib.h"

#else

/*
 * THOMAS BOUTELL & BAREND GEHRELS, february 2003
 * adapted the code to work within gd rather than within libjpeg.
 * If it is not working, it's not Thomas G. Lane's fault.
 */

/* 
  SETTING THIS ONE CAUSES STRIPED IMAGE
  to be done: solve this
  #define ORIGINAL_LIB_JPEG_REVERSE_ODD_ROWS
 */

#include <string.h>
#include "gd.h"
#include "gdhelpers.h"

/* (Re)define some defines known by libjpeg */
#define QUANT_2PASS_SUPPORTED

#define RGB_RED		0
#define RGB_GREEN	1
#define RGB_BLUE	2

#define JSAMPLE unsigned char
#define MAXJSAMPLE (gdMaxColors-1)
#define BITS_IN_JSAMPLE 8

#define JSAMPROW int*
#define JDIMENSION int

#define METHODDEF(type) static type
#define LOCAL(type)	static type


/* We assume that right shift corresponds to signed division by 2 with
 * rounding towards minus infinity.  This is correct for typical "arithmetic
 * shift" instructions that shift in copies of the sign bit.  But some
 * C compilers implement >> with an unsigned shift.  For these machines you
 * must define RIGHT_SHIFT_IS_UNSIGNED.
 * RIGHT_SHIFT provides a proper signed right shift of an INT32 quantity.
 * It is only applied with constant shift counts.  SHIFT_TEMPS must be
 * included in the variables of any routine using RIGHT_SHIFT.
 */

#ifdef RIGHT_SHIFT_IS_UNSIGNED
#define SHIFT_TEMPS	INT32 shift_temp;
#define RIGHT_SHIFT(x,shft)  \
	((shift_temp = (x)) < 0 ? \
	 (shift_temp >> (shft)) | ((~((INT32) 0)) << (32-(shft))) : \
	 (shift_temp >> (shft)))
#else
#define SHIFT_TEMPS
#define RIGHT_SHIFT(x,shft)	((x) >> (shft))
#endif


#define range_limit(x) { if(x<0) x=0; if (x>255) x=255; }


#ifndef INT16
#define INT16  short
#endif

#ifndef UINT16
#define UINT16 unsigned short
#endif

#ifndef INT32
#define INT32 int
#endif

#ifndef FAR
#define FAR
#endif



#ifndef boolean
#define boolean int
#endif

#ifndef TRUE
#define TRUE 1
#endif

#ifndef FALSE
#define FALSE 0
#endif


#define input_buf (oim->tpixels)
#define output_buf (nim->pixels)

#endif

#ifdef QUANT_2PASS_SUPPORTED


/*
 * This module implements the well-known Heckbert paradigm for color
 * quantization.  Most of the ideas used here can be traced back to
 * Heckbert's seminal paper
 *   Heckbert, Paul.  "Color Image Quantization for Frame Buffer Display",
 *   Proc. SIGGRAPH '82, Computer Graphics v.16 #3 (July 1982), pp 297-304.
 *
 * In the first pass over the image, we accumulate a histogram showing the
 * usage count of each possible color.  To keep the histogram to a reasonable
 * size, we reduce the precision of the input; typical practice is to retain
 * 5 or 6 bits per color, so that 8 or 4 different input values are counted
 * in the same histogram cell.
 *
 * Next, the color-selection step begins with a box representing the whole
 * color space, and repeatedly splits the "largest" remaining box until we
 * have as many boxes as desired colors.  Then the mean color in each
 * remaining box becomes one of the possible output colors.
 * 
 * The second pass over the image maps each input pixel to the closest output
 * color (optionally after applying a Floyd-Steinberg dithering correction).
 * This mapping is logically trivial, but making it go fast enough requires
 * considerable care.
 *
 * Heckbert-style quantizers vary a good deal in their policies for choosing
 * the "largest" box and deciding where to cut it.  The particular policies
 * used here have proved out well in experimental comparisons, but better ones
 * may yet be found.
 *
 * In earlier versions of the IJG code, this module quantized in YCbCr color
 * space, processing the raw upsampled data without a color conversion step.
 * This allowed the color conversion math to be done only once per colormap
 * entry, not once per pixel.  However, that optimization precluded other
 * useful optimizations (such as merging color conversion with upsampling)
 * and it also interfered with desired capabilities such as quantizing to an
 * externally-supplied colormap.  We have therefore abandoned that approach.
 * The present code works in the post-conversion color space, typically RGB.
 *
 * To improve the visual quality of the results, we actually work in scaled
 * RGB space, giving G distances more weight than R, and R in turn more than
 * B.  To do everything in integer math, we must use integer scale factors.
 * The 2/3/1 scale factors used here correspond loosely to the relative
 * weights of the colors in the NTSC grayscale equation.
 * If you want to use this code to quantize a non-RGB color space, you'll
 * probably need to change these scale factors.
 */

#define R_SCALE 2		/* scale R distances by this much */
#define G_SCALE 3		/* scale G distances by this much */
#define B_SCALE 1		/* and B by this much */

/* Relabel R/G/B as components 0/1/2, respecting the RGB ordering defined
 * in jmorecfg.h.  As the code stands, it will do the right thing for R,G,B
 * and B,G,R orders.  If you define some other weird order in jmorecfg.h,
 * you'll get compile errors until you extend this logic.  In that case
 * you'll probably want to tweak the histogram sizes too.
 */

#if RGB_RED == 0
#define C0_SCALE R_SCALE
#endif
#if RGB_BLUE == 0
#define C0_SCALE B_SCALE
#endif
#if RGB_GREEN == 1
#define C1_SCALE G_SCALE
#endif
#if RGB_RED == 2
#define C2_SCALE R_SCALE
#endif
#if RGB_BLUE == 2
#define C2_SCALE B_SCALE
#endif


/*
 * First we have the histogram data structure and routines for creating it.
 *
 * The number of bits of precision can be adjusted by changing these symbols.
 * We recommend keeping 6 bits for G and 5 each for R and B.
 * If you have plenty of memory and cycles, 6 bits all around gives marginally
 * better results; if you are short of memory, 5 bits all around will save
 * some space but degrade the results.
 * To maintain a fully accurate histogram, we'd need to allocate a "long"
 * (preferably unsigned long) for each cell.  In practice this is overkill;
 * we can get by with 16 bits per cell.  Few of the cell counts will overflow,
 * and clamping those that do overflow to the maximum value will give close-
 * enough results.  This reduces the recommended histogram size from 256Kb
 * to 128Kb, which is a useful savings on PC-class machines.
 * (In the second pass the histogram space is re-used for pixel mapping data;
 * in that capacity, each cell must be able to store zero to the number of
 * desired colors.  16 bits/cell is plenty for that too.)
 * Since the JPEG code is intended to run in small memory model on 80x86
 * machines, we can't just allocate the histogram in one chunk.  Instead
 * of a true 3-D array, we use a row of pointers to 2-D arrays.  Each
 * pointer corresponds to a C0 value (typically 2^5 = 32 pointers) and
 * each 2-D array has 2^6*2^5 = 2048 or 2^6*2^6 = 4096 entries.  Note that
 * on 80x86 machines, the pointer row is in near memory but the actual
 * arrays are in far memory (same arrangement as we use for image arrays).
 */

#define MAXNUMCOLORS  (MAXJSAMPLE+1)	/* maximum size of colormap */

/* These will do the right thing for either R,G,B or B,G,R color order,
 * but you may not like the results for other color orders.
 */
#define HIST_C0_BITS  5		/* bits of precision in R/B histogram */
#define HIST_C1_BITS  6		/* bits of precision in G histogram */
#define HIST_C2_BITS  5		/* bits of precision in B/R histogram */

/* Number of elements along histogram axes. */
#define HIST_C0_ELEMS  (1<<HIST_C0_BITS)
#define HIST_C1_ELEMS  (1<<HIST_C1_BITS)
#define HIST_C2_ELEMS  (1<<HIST_C2_BITS)

/* These are the amounts to shift an input value to get a histogram index. */
#define C0_SHIFT  (BITS_IN_JSAMPLE-HIST_C0_BITS)
#define C1_SHIFT  (BITS_IN_JSAMPLE-HIST_C1_BITS)
#define C2_SHIFT  (BITS_IN_JSAMPLE-HIST_C2_BITS)


typedef UINT16 histcell;	/* histogram cell; prefer an unsigned type */

typedef histcell FAR *histptr;	/* for pointers to histogram cells */

typedef histcell hist1d[HIST_C2_ELEMS];	/* typedefs for the array */
typedef hist1d FAR *hist2d;	/* type for the 2nd-level pointers */
typedef hist2d *hist3d;		/* type for top-level pointer */


/* Declarations for Floyd-Steinberg dithering.
 *
 * Errors are accumulated into the array fserrors[], at a resolution of
 * 1/16th of a pixel count.  The error at a given pixel is propagated
 * to its not-yet-processed neighbors using the standard F-S fractions,
 *		...	(here)	7/16
 *		3/16	5/16	1/16
 * We work left-to-right on even rows, right-to-left on odd rows.
 *
 * We can get away with a single array (holding one row's worth of errors)
 * by using it to store the current row's errors at pixel columns not yet
 * processed, but the next row's errors at columns already processed.  We
 * need only a few extra variables to hold the errors immediately around the
 * current column.  (If we are lucky, those variables are in registers, but
 * even if not, they're probably cheaper to access than array elements are.)
 *
 * The fserrors[] array has (#columns + 2) entries; the extra entry at
 * each end saves us from special-casing the first and last pixels.
 * Each entry is three values long, one value for each color component.
 *
 * Note: on a wide image, we might not have enough room in a PC's near data
 * segment to hold the error array; so it is allocated with alloc_large.
 */

#if BITS_IN_JSAMPLE == 8
typedef INT16 FSERROR;		/* 16 bits should be enough */
typedef int LOCFSERROR;		/* use 'int' for calculation temps */
#else
typedef INT32 FSERROR;		/* may need more than 16 bits */
typedef INT32 LOCFSERROR;	/* be sure calculation temps are big enough */
#endif

typedef FSERROR FAR *FSERRPTR;	/* pointer to error array (in FAR storage!) */


/* Private subobject */

typedef struct
{
#ifdef ORIGINAL_LIB_JPEG
  struct jpeg_color_quantizer pub;	/* public fields */

  /* Space for the eventually created colormap is stashed here */
  JSAMPARRAY sv_colormap;	/* colormap allocated at init time */
  int desired;			/* desired # of colors = size of colormap */
  boolean needs_zeroed;		/* TRUE if next pass must zero histogram */
#endif

  /* Variables for accumulating image statistics */
  hist3d histogram;		/* pointer to the histogram */


  /* Variables for Floyd-Steinberg dithering */
  FSERRPTR fserrors;		/* accumulated errors */

  boolean on_odd_row;		/* flag to remember which row we are on */
  int *error_limiter;		/* table for clamping the applied error */
#ifndef ORIGINAL_LIB_JPEG
  int *error_limiter_storage;	/* gdMalloc'd storage for the above */
#endif
}
my_cquantizer;

typedef my_cquantizer *my_cquantize_ptr;


/*
 * Prescan some rows of pixels.
 * In this module the prescan simply updates the histogram, which has been
 * initialized to zeroes by start_pass.
 * An output_buf parameter is required by the method signature, but no data
 * is actually output (in fact the buffer controller is probably passing a
 * NULL pointer).
 */

METHODDEF (void)
#ifndef ORIGINAL_LIB_JPEG
prescan_quantize (gdImagePtr oim, gdImagePtr nim, my_cquantize_ptr cquantize)
{
#else
prescan_quantize (j_decompress_ptr cinfo, JSAMPARRAY input_buf,
		  JSAMPARRAY output_buf, int num_rows)
{
  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
#endif
  register JSAMPROW ptr;
  register histptr histp;
  register hist3d histogram = cquantize->histogram;
  int row;
  JDIMENSION col;
#ifdef ORIGINAL_LIB_JPEG
  JDIMENSION width = cinfo->output_width;
#else
  int width = oim->sx;
  int num_rows = oim->sy;
#endif

  for (row = 0; row < num_rows; row++)
    {
      ptr = input_buf[row];
      for (col = width; col > 0; col--)
	{
#ifdef ORIGINAL_LIB_JPEG
	  int r = GETJSAMPLE (ptr[0]) >> C0_SHIFT;
	  int g = GETJSAMPLE (ptr[1]) >> C1_SHIFT;
	  int b = GETJSAMPLE (ptr[2]) >> C2_SHIFT;
#else
	  int r = gdTrueColorGetRed (*ptr) >> C0_SHIFT;
	  int g = gdTrueColorGetGreen (*ptr) >> C1_SHIFT;
	  int b = gdTrueColorGetBlue (*ptr) >> C2_SHIFT;
	  /* 2.0.12: Steven Brown: support a single totally transparent
	     color in the original. */
	  if ((oim->transparent >= 0) && (*ptr == oim->transparent))
	    {
	      ptr++;
	      continue;
	    }
#endif
	  /* get pixel value and index into the histogram */
	  histp = &histogram[r][g][b];
	  /* increment, check for overflow and undo increment if so. */
	  if (++(*histp) == 0)
	    (*histp)--;
#ifdef ORIGINAL_LIB_JPEG
	  ptr += 3;
#else
	  ptr++;
#endif
	}
    }
}


/*
 * Next we have the really interesting routines: selection of a colormap
 * given the completed histogram.
 * These routines work with a list of "boxes", each representing a rectangular
 * subset of the input color space (to histogram precision).
 */

typedef struct
{
  /* The bounds of the box (inclusive); expressed as histogram indexes */
  int c0min, c0max;
  int c1min, c1max;
  int c2min, c2max;
  /* The volume (actually 2-norm) of the box */
  INT32 volume;
  /* The number of nonzero histogram cells within this box */
  long colorcount;
}
box;

typedef box *boxptr;


LOCAL (boxptr) find_biggest_color_pop (boxptr boxlist, int numboxes)
/* Find the splittable box with the largest color population */
/* Returns NULL if no splittable boxes remain */
{
  register boxptr boxp;
  register int i;
  register long maxc = 0;
  boxptr which = NULL;

  for (i = 0, boxp = boxlist; i < numboxes; i++, boxp++)
    {
      if (boxp->colorcount > maxc && boxp->volume > 0)
	{
	  which = boxp;
	  maxc = boxp->colorcount;
	}
    }
  return which;
}


LOCAL (boxptr) find_biggest_volume (boxptr boxlist, int numboxes)
/* Find the splittable box with the largest (scaled) volume */
/* Returns NULL if no splittable boxes remain */
{
  register boxptr boxp;
  register int i;
  register INT32 maxv = 0;
  boxptr which = NULL;

  for (i = 0, boxp = boxlist; i < numboxes; i++, boxp++)
    {
      if (boxp->volume > maxv)
	{
	  which = boxp;
	  maxv = boxp->volume;
	}
    }
  return which;
}


LOCAL (void)
#ifndef ORIGINAL_LIB_JPEG
  update_box (gdImagePtr oim, gdImagePtr nim, my_cquantize_ptr cquantize, boxptr boxp)
{
#else
  update_box (j_decompress_ptr cinfo, boxptr boxp)
/* Shrink the min/max bounds of a box to enclose only nonzero elements, */
/* and recompute its volume and population */
{
  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
#endif
  hist3d histogram = cquantize->histogram;
  histptr histp;
  int c0, c1, c2;
  int c0min, c0max, c1min, c1max, c2min, c2max;
  INT32 dist0, dist1, dist2;
  long ccount;

  c0min = boxp->c0min;
  c0max = boxp->c0max;
  c1min = boxp->c1min;
  c1max = boxp->c1max;
  c2min = boxp->c2min;
  c2max = boxp->c2max;

  if (c0max > c0min)
    for (c0 = c0min; c0 <= c0max; c0++)
      for (c1 = c1min; c1 <= c1max; c1++)
	{
	  histp = &histogram[c0][c1][c2min];
	  for (c2 = c2min; c2 <= c2max; c2++)
	    if (*histp++ != 0)
	      {
		boxp->c0min = c0min = c0;
		goto have_c0min;
	      }
	}
have_c0min:
  if (c0max > c0min)
    for (c0 = c0max; c0 >= c0min; c0--)
      for (c1 = c1min; c1 <= c1max; c1++)
	{
	  histp = &histogram[c0][c1][c2min];
	  for (c2 = c2min; c2 <= c2max; c2++)
	    if (*histp++ != 0)
	      {
		boxp->c0max = c0max = c0;
		goto have_c0max;
	      }
	}
have_c0max:
  if (c1max > c1min)
    for (c1 = c1min; c1 <= c1max; c1++)
      for (c0 = c0min; c0 <= c0max; c0++)
	{
	  histp = &histogram[c0][c1][c2min];
	  for (c2 = c2min; c2 <= c2max; c2++)
	    if (*histp++ != 0)
	      {
		boxp->c1min = c1min = c1;
		goto have_c1min;
	      }
	}
have_c1min:
  if (c1max > c1min)
    for (c1 = c1max; c1 >= c1min; c1--)
      for (c0 = c0min; c0 <= c0max; c0++)
	{
	  histp = &histogram[c0][c1][c2min];
	  for (c2 = c2min; c2 <= c2max; c2++)
	    if (*histp++ != 0)
	      {
		boxp->c1max = c1max = c1;
		goto have_c1max;
	      }
	}
have_c1max:
  if (c2max > c2min)
    for (c2 = c2min; c2 <= c2max; c2++)
      for (c0 = c0min; c0 <= c0max; c0++)
	{
	  histp = &histogram[c0][c1min][c2];
	  for (c1 = c1min; c1 <= c1max; c1++, histp += HIST_C2_ELEMS)
	    if (*histp != 0)
	      {
		boxp->c2min = c2min = c2;
		goto have_c2min;
	      }
	}
have_c2min:
  if (c2max > c2min)
    for (c2 = c2max; c2 >= c2min; c2--)
      for (c0 = c0min; c0 <= c0max; c0++)
	{
	  histp = &histogram[c0][c1min][c2];
	  for (c1 = c1min; c1 <= c1max; c1++, histp += HIST_C2_ELEMS)
	    if (*histp != 0)
	      {
		boxp->c2max = c2max = c2;
		goto have_c2max;
	      }
	}
have_c2max:

  /* Update box volume.
   * We use 2-norm rather than real volume here; this biases the method
   * against making long narrow boxes, and it has the side benefit that
   * a box is splittable iff norm > 0.
   * Since the differences are expressed in histogram-cell units,
   * we have to shift back to JSAMPLE units to get consistent distances;
   * after which, we scale according to the selected distance scale factors.
   */
  dist0 = ((c0max - c0min) << C0_SHIFT) * C0_SCALE;
  dist1 = ((c1max - c1min) << C1_SHIFT) * C1_SCALE;
  dist2 = ((c2max - c2min) << C2_SHIFT) * C2_SCALE;
  boxp->volume = dist0 * dist0 + dist1 * dist1 + dist2 * dist2;

  /* Now scan remaining volume of box and compute population */
  ccount = 0;
  for (c0 = c0min; c0 <= c0max; c0++)
    for (c1 = c1min; c1 <= c1max; c1++)
      {
	histp = &histogram[c0][c1][c2min];
	for (c2 = c2min; c2 <= c2max; c2++, histp++)
	  if (*histp != 0)
	    {
	      ccount++;
	    }
      }
  boxp->colorcount = ccount;
}


LOCAL (int)
#ifdef ORIGINAL_LIB_JPEG
median_cut (j_decompress_ptr cinfo, boxptr boxlist, int numboxes,
	    int desired_colors)
#else
median_cut (gdImagePtr oim, gdImagePtr nim, my_cquantize_ptr cquantize,
	    boxptr boxlist, int numboxes, int desired_colors)
#endif
/* Repeatedly select and split the largest box until we have enough boxes */
{
  int n, lb;
  int c0, c1, c2, cmax;
  register boxptr b1, b2;

  while (numboxes < desired_colors)
    {
      /* Select box to split.
       * Current algorithm: by population for first half, then by volume.
       */
      if (numboxes * 2 <= desired_colors)
	{
	  b1 = find_biggest_color_pop (boxlist, numboxes);
	}
      else
	{
	  b1 = find_biggest_volume (boxlist, numboxes);
	}
      if (b1 == NULL)		/* no splittable boxes left! */
	break;
      b2 = &boxlist[numboxes];	/* where new box will go */
      /* Copy the color bounds to the new box. */
      b2->c0max = b1->c0max;
      b2->c1max = b1->c1max;
      b2->c2max = b1->c2max;
      b2->c0min = b1->c0min;
      b2->c1min = b1->c1min;
      b2->c2min = b1->c2min;
      /* Choose which axis to split the box on.
       * Current algorithm: longest scaled axis.
       * See notes in update_box about scaling distances.
       */
      c0 = ((b1->c0max - b1->c0min) << C0_SHIFT) * C0_SCALE;
      c1 = ((b1->c1max - b1->c1min) << C1_SHIFT) * C1_SCALE;
      c2 = ((b1->c2max - b1->c2min) << C2_SHIFT) * C2_SCALE;
      /* We want to break any ties in favor of green, then red, blue last.
       * This code does the right thing for R,G,B or B,G,R color orders only.
       */
#if RGB_RED == 0
      cmax = c1;
      n = 1;
      if (c0 > cmax)
	{
	  cmax = c0;
	  n = 0;
	}
      if (c2 > cmax)
	{
	  n = 2;
	}
#else
      cmax = c1;
      n = 1;
      if (c2 > cmax)
	{
	  cmax = c2;
	  n = 2;
	}
      if (c0 > cmax)
	{
	  n = 0;
	}
#endif
      /* Choose split point along selected axis, and update box bounds.
       * Current algorithm: split at halfway point.
       * (Since the box has been shrunk to minimum volume,
       * any split will produce two nonempty subboxes.)
       * Note that lb value is max for lower box, so must be < old max.
       */
      switch (n)
	{
	case 0:
	  lb = (b1->c0max + b1->c0min) / 2;
	  b1->c0max = lb;
	  b2->c0min = lb + 1;
	  break;
	case 1:
	  lb = (b1->c1max + b1->c1min) / 2;
	  b1->c1max = lb;
	  b2->c1min = lb + 1;
	  break;
	case 2:
	  lb = (b1->c2max + b1->c2min) / 2;
	  b1->c2max = lb;
	  b2->c2min = lb + 1;
	  break;
	}
      /* Update stats for boxes */
#ifdef ORIGINAL_LIB_JPEG
      update_box (cinfo, b1);
      update_box (cinfo, b2);
#else
      update_box (oim, nim, cquantize, b1);
      update_box (oim, nim, cquantize, b2);
#endif
      numboxes++;
    }
  return numboxes;
}


LOCAL (void)
#ifndef ORIGINAL_LIB_JPEG
  compute_color (gdImagePtr oim, gdImagePtr nim, my_cquantize_ptr cquantize,
	       boxptr boxp, int icolor)
{
#else
  compute_color (j_decompress_ptr cinfo, boxptr boxp, int icolor)
/* Compute representative color for a box, put it in colormap[icolor] */
{
  /* Current algorithm: mean weighted by pixels (not colors) */
  /* Note it is important to get the rounding correct! */
  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
#endif
  hist3d histogram = cquantize->histogram;
  histptr histp;
  int c0, c1, c2;
  int c0min, c0max, c1min, c1max, c2min, c2max;
  long count = 0; /* 2.0.28: = 0 */
  long total = 0;
  long c0total = 0;
  long c1total = 0;
  long c2total = 0;

  c0min = boxp->c0min;
  c0max = boxp->c0max;
  c1min = boxp->c1min;
  c1max = boxp->c1max;
  c2min = boxp->c2min;
  c2max = boxp->c2max;

  for (c0 = c0min; c0 <= c0max; c0++)
    for (c1 = c1min; c1 <= c1max; c1++)
      {
	histp = &histogram[c0][c1][c2min];
	for (c2 = c2min; c2 <= c2max; c2++)
	  {
	    if ((count = *histp++) != 0)
	      {
		total += count;
		c0total +=
		  ((c0 << C0_SHIFT) + ((1 << C0_SHIFT) >> 1)) * count;
		c1total +=
		  ((c1 << C1_SHIFT) + ((1 << C1_SHIFT) >> 1)) * count;
		c2total +=
		  ((c2 << C2_SHIFT) + ((1 << C2_SHIFT) >> 1)) * count;
	      }
	  }
      }

#ifdef ORIGINAL_LIB_JPEG
  cinfo->colormap[0][icolor] = (JSAMPLE) ((c0total + (total >> 1)) / total);
  cinfo->colormap[1][icolor] = (JSAMPLE) ((c1total + (total >> 1)) / total);
  cinfo->colormap[2][icolor] = (JSAMPLE) ((c2total + (total >> 1)) / total);
#else
  /* 2.0.16: Paul den Dulk found an occasion where total can be 0 */
  if (count)
    {
      nim->red[icolor] = (int) ((c0total + (total >> 1)) / total);
      nim->green[icolor] = (int) ((c1total + (total >> 1)) / total);
      nim->blue[icolor] = (int) ((c2total + (total >> 1)) / total);
    }
  else
    {
      nim->red[icolor] = 255;
      nim->green[icolor] = 255;
      nim->blue[icolor] = 255;
    }
		nim->open[icolor] = 0;
#endif
}


LOCAL (void)
#ifdef ORIGINAL_LIB_JPEG
select_colors (j_decompress_ptr cinfo, int desired_colors)
#else
select_colors (gdImagePtr oim, gdImagePtr nim, my_cquantize_ptr cquantize, int desired_colors)
#endif
/* Master routine for color selection */
{
  boxptr boxlist;
  int numboxes;
  int i;

  /* Allocate workspace for box list */
#ifdef ORIGINAL_LIB_JPEG
  boxlist = (boxptr) (*cinfo->mem->alloc_small)
    ((j_common_ptr) cinfo, JPOOL_IMAGE, desired_colors * SIZEOF (box));
#else
  /* This can't happen because we clamp desired_colors at gdMaxColors, 
    but anyway */
  if (overflow2(desired_colors, sizeof (box))) {
    return;
   }
  boxlist = (boxptr) gdMalloc (desired_colors * sizeof (box));
	if (!boxlist) {
		return;
	}
#endif
  /* Initialize one box containing whole space */
  numboxes = 1;
  boxlist[0].c0min = 0;
  boxlist[0].c0max = MAXJSAMPLE >> C0_SHIFT;
  boxlist[0].c1min = 0;
  boxlist[0].c1max = MAXJSAMPLE >> C1_SHIFT;
  boxlist[0].c2min = 0;
  boxlist[0].c2max = MAXJSAMPLE >> C2_SHIFT;
#ifdef ORIGINAL_LIB_JPEG
  /* Shrink it to actually-used volume and set its statistics */
  update_box (cinfo, &boxlist[0]);
  /* Perform median-cut to produce final box list */
  numboxes = median_cut (cinfo, boxlist, numboxes, desired_colors);
  /* Compute the representative color for each box, fill colormap */
  for (i = 0; i < numboxes; i++)
    compute_color (cinfo, &boxlist[i], i);
  cinfo->actual_number_of_colors = numboxes;
  TRACEMS1 (cinfo, 1, JTRC_QUANT_SELECTED, numboxes);
#else
  /* Shrink it to actually-used volume and set its statistics */
  update_box (oim, nim, cquantize, &boxlist[0]);
  /* Perform median-cut to produce final box list */
  numboxes = median_cut (oim, nim, cquantize, boxlist, numboxes, desired_colors);
  /* Compute the representative color for each box, fill colormap */
  for (i = 0; i < numboxes; i++)
    compute_color (oim, nim, cquantize, &boxlist[i], i);
  nim->colorsTotal = numboxes;

  /* If we had a pure transparency color, add it as the last palette entry.
   * Skip incrementing the color count so that the dither / matching phase
   * won't use it on pixels that shouldn't have been transparent.  We'll
   * increment it after all that finishes. */
  if (oim->transparent >= 0)
    {
      /* Save the transparent color. */
      nim->red[nim->colorsTotal] = gdTrueColorGetRed (oim->transparent);
      nim->green[nim->colorsTotal] = gdTrueColorGetGreen (oim->transparent);
      nim->blue[nim->colorsTotal] = gdTrueColorGetBlue (oim->transparent);
      nim->alpha[nim->colorsTotal] = gdAlphaTransparent;
      nim->open[nim->colorsTotal] = 0;
    }

  gdFree (boxlist);
#endif
}


/*
 * These routines are concerned with the time-critical task of mapping input
 * colors to the nearest color in the selected colormap.
 *
 * We re-use the histogram space as an "inverse color map", essentially a
 * cache for the results of nearest-color searches.  All colors within a
 * histogram cell will be mapped to the same colormap entry, namely the one
 * closest to the cell's center.  This may not be quite the closest entry to
 * the actual input color, but it's almost as good.  A zero in the cache
 * indicates we haven't found the nearest color for that cell yet; the array
 * is cleared to zeroes before starting the mapping pass.  When we find the
 * nearest color for a cell, its colormap index plus one is recorded in the
 * cache for future use.  The pass2 scanning routines call fill_inverse_cmap
 * when they need to use an unfilled entry in the cache.
 *
 * Our method of efficiently finding nearest colors is based on the "locally
 * sorted search" idea described by Heckbert and on the incremental distance
 * calculation described by Spencer W. Thomas in chapter III.1 of Graphics
 * Gems II (James Arvo, ed.  Academic Press, 1991).  Thomas points out that
 * the distances from a given colormap entry to each cell of the histogram can
 * be computed quickly using an incremental method: the differences between
 * distances to adjacent cells themselves differ by a constant.  This allows a
 * fairly fast implementation of the "brute force" approach of computing the
 * distance from every colormap entry to every histogram cell.  Unfortunately,
 * it needs a work array to hold the best-distance-so-far for each histogram
 * cell (because the inner loop has to be over cells, not colormap entries).
 * The work array elements have to be INT32s, so the work array would need
 * 256Kb at our recommended precision.  This is not feasible in DOS machines.
 *
 * To get around these problems, we apply Thomas' method to compute the
 * nearest colors for only the cells within a small subbox of the histogram.
 * The work array need be only as big as the subbox, so the memory usage
 * problem is solved.  Furthermore, we need not fill subboxes that are never
 * referenced in pass2; many images use only part of the color gamut, so a
 * fair amount of work is saved.  An additional advantage of this
 * approach is that we can apply Heckbert's locality criterion to quickly
 * eliminate colormap entries that are far away from the subbox; typically
 * three-fourths of the colormap entries are rejected by Heckbert's criterion,
 * and we need not compute their distances to individual cells in the subbox.
 * The speed of this approach is heavily influenced by the subbox size: too
 * small means too much overhead, too big loses because Heckbert's criterion
 * can't eliminate as many colormap entries.  Empirically the best subbox
 * size seems to be about 1/512th of the histogram (1/8th in each direction).
 *
 * Thomas' article also describes a refined method which is asymptotically
 * faster than the brute-force method, but it is also far more complex and
 * cannot efficiently be applied to small subboxes.  It is therefore not
 * useful for programs intended to be portable to DOS machines.  On machines
 * with plenty of memory, filling the whole histogram in one shot with Thomas'
 * refined method might be faster than the present code --- but then again,
 * it might not be any faster, and it's certainly more complicated.
 */


/* log2(histogram cells in update box) for each axis; this can be adjusted */
#define BOX_C0_LOG  (HIST_C0_BITS-3)
#define BOX_C1_LOG  (HIST_C1_BITS-3)
#define BOX_C2_LOG  (HIST_C2_BITS-3)

#define BOX_C0_ELEMS  (1<<BOX_C0_LOG)	/* # of hist cells in update box */
#define BOX_C1_ELEMS  (1<<BOX_C1_LOG)
#define BOX_C2_ELEMS  (1<<BOX_C2_LOG)

#define BOX_C0_SHIFT  (C0_SHIFT + BOX_C0_LOG)
#define BOX_C1_SHIFT  (C1_SHIFT + BOX_C1_LOG)
#define BOX_C2_SHIFT  (C2_SHIFT + BOX_C2_LOG)


/*
 * The next three routines implement inverse colormap filling.  They could
 * all be folded into one big routine, but splitting them up this way saves
 * some stack space (the mindist[] and bestdist[] arrays need not coexist)
 * and may allow some compilers to produce better code by registerizing more
 * inner-loop variables.
 */

LOCAL (int)
find_nearby_colors (
#ifdef ORIGINAL_LIB_JPEG
		     j_decompress_ptr cinfo,
#else
		     gdImagePtr oim, gdImagePtr nim, my_cquantize_ptr cquantize,
#endif
		     int minc0, int minc1, int minc2, JSAMPLE colorlist[])
/* Locate the colormap entries close enough to an update box to be candidates
 * for the nearest entry to some cell(s) in the update box.  The update box
 * is specified by the center coordinates of its first cell.  The number of
 * candidate colormap entries is returned, and their colormap indexes are
 * placed in colorlist[].
 * This routine uses Heckbert's "locally sorted search" criterion to select
 * the colors that need further consideration.
 */
{
#ifdef ORIGINAL_LIB_JPEG
  int numcolors = cinfo->actual_number_of_colors;
#else
  int numcolors = nim->colorsTotal;
#endif
  int maxc0, maxc1, maxc2;
  int centerc0, centerc1, centerc2;
  int i, x, ncolors;
  INT32 minmaxdist, min_dist, max_dist, tdist;
  INT32 mindist[MAXNUMCOLORS];	/* min distance to colormap entry i */

  /* Compute true coordinates of update box's upper corner and center.
   * Actually we compute the coordinates of the center of the upper-corner
   * histogram cell, which are the upper bounds of the volume we care about.
   * Note that since ">>" rounds down, the "center" values may be closer to
   * min than to max; hence comparisons to them must be "<=", not "<".
   */
  maxc0 = minc0 + ((1 << BOX_C0_SHIFT) - (1 << C0_SHIFT));
  centerc0 = (minc0 + maxc0) >> 1;
  maxc1 = minc1 + ((1 << BOX_C1_SHIFT) - (1 << C1_SHIFT));
  centerc1 = (minc1 + maxc1) >> 1;
  maxc2 = minc2 + ((1 << BOX_C2_SHIFT) - (1 << C2_SHIFT));
  centerc2 = (minc2 + maxc2) >> 1;

  /* For each color in colormap, find:
   *  1. its minimum squared-distance to any point in the update box
   *     (zero if color is within update box);
   *  2. its maximum squared-distance to any point in the update box.
   * Both of these can be found by considering only the corners of the box.
   * We save the minimum distance for each color in mindist[];
   * only the smallest maximum distance is of interest.
   */
  minmaxdist = 0x7FFFFFFFL;

  for (i = 0; i < numcolors; i++)
    {
      /* We compute the squared-c0-distance term, then add in the other two. */
#ifdef ORIGINAL_LIB_JPEG
      x = GETJSAMPLE (cinfo->colormap[0][i]);
#else
      x = nim->red[i];
#endif
      if (x < minc0)
	{
	  tdist = (x - minc0) * C0_SCALE;
	  min_dist = tdist * tdist;
	  tdist = (x - maxc0) * C0_SCALE;
	  max_dist = tdist * tdist;
	}
      else if (x > maxc0)
	{
	  tdist = (x - maxc0) * C0_SCALE;
	  min_dist = tdist * tdist;
	  tdist = (x - minc0) * C0_SCALE;
	  max_dist = tdist * tdist;
	}
      else
	{
	  /* within cell range so no contribution to min_dist */
	  min_dist = 0;
	  if (x <= centerc0)
	    {
	      tdist = (x - maxc0) * C0_SCALE;
	      max_dist = tdist * tdist;
	    }
	  else
	    {
	      tdist = (x - minc0) * C0_SCALE;
	      max_dist = tdist * tdist;
	    }
	}

#ifdef ORIGINAL_LIB_JPEG
      x = GETJSAMPLE (cinfo->colormap[1][i]);
#else
      x = nim->green[i];
#endif
      if (x < minc1)
	{
	  tdist = (x - minc1) * C1_SCALE;
	  min_dist += tdist * tdist;
	  tdist = (x - maxc1) * C1_SCALE;
	  max_dist += tdist * tdist;
	}
      else if (x > maxc1)
	{
	  tdist = (x - maxc1) * C1_SCALE;
	  min_dist += tdist * tdist;
	  tdist = (x - minc1) * C1_SCALE;
	  max_dist += tdist * tdist;
	}
      else
	{
	  /* within cell range so no contribution to min_dist */
	  if (x <= centerc1)
	    {
	      tdist = (x - maxc1) * C1_SCALE;
	      max_dist += tdist * tdist;
	    }
	  else
	    {
	      tdist = (x - minc1) * C1_SCALE;
	      max_dist += tdist * tdist;
	    }
	}

#ifdef ORIGINAL_LIB_JPEG
      x = GETJSAMPLE (cinfo->colormap[2][i]);
#else
      x = nim->blue[i];
#endif
      if (x < minc2)
	{
	  tdist = (x - minc2) * C2_SCALE;
	  min_dist += tdist * tdist;
	  tdist = (x - maxc2) * C2_SCALE;
	  max_dist += tdist * tdist;
	}
      else if (x > maxc2)
	{
	  tdist = (x - maxc2) * C2_SCALE;
	  min_dist += tdist * tdist;
	  tdist = (x - minc2) * C2_SCALE;
	  max_dist += tdist * tdist;
	}
      else
	{
	  /* within cell range so no contribution to min_dist */
	  if (x <= centerc2)
	    {
	      tdist = (x - maxc2) * C2_SCALE;
	      max_dist += tdist * tdist;
	    }
	  else
	    {
	      tdist = (x - minc2) * C2_SCALE;
	      max_dist += tdist * tdist;
	    }
	}

      mindist[i] = min_dist;	/* save away the results */
      if (max_dist < minmaxdist)
	minmaxdist = max_dist;
    }

  /* Now we know that no cell in the update box is more than minmaxdist
   * away from some colormap entry.  Therefore, only colors that are
   * within minmaxdist of some part of the box need be considered.
   */
  ncolors = 0;
  for (i = 0; i < numcolors; i++)
    {
      if (mindist[i] <= minmaxdist)
	colorlist[ncolors++] = (JSAMPLE) i;
    }
  return ncolors;
}


LOCAL (void) find_best_colors (
#ifdef ORIGINAL_LIB_JPEG
				j_decompress_ptr cinfo,
#else
				gdImagePtr oim, gdImagePtr nim, my_cquantize_ptr cquantize,
#endif
				int minc0, int minc1, int minc2,
				int numcolors, JSAMPLE colorlist[],
				JSAMPLE bestcolor[])
/* Find the closest colormap entry for each cell in the update box,
 * given the list of candidate colors prepared by find_nearby_colors.
 * Return the indexes of the closest entries in the bestcolor[] array.
 * This routine uses Thomas' incremental distance calculation method to
 * find the distance from a colormap entry to successive cells in the box.
 */
{
  int ic0, ic1, ic2;
  int i, icolor;
  register INT32 *bptr;		/* pointer into bestdist[] array */
  JSAMPLE *cptr;		/* pointer into bestcolor[] array */
  INT32 dist0, dist1;		/* initial distance values */
  register INT32 dist2;		/* current distance in inner loop */
  INT32 xx0, xx1;		/* distance increments */
  register INT32 xx2;
  INT32 inc0, inc1, inc2;	/* initial values for increments */
  /* This array holds the distance to the nearest-so-far color for each cell */
  INT32 bestdist[BOX_C0_ELEMS * BOX_C1_ELEMS * BOX_C2_ELEMS];

  /* Initialize best-distance for each cell of the update box */
  bptr = bestdist;
  for (i = BOX_C0_ELEMS * BOX_C1_ELEMS * BOX_C2_ELEMS - 1; i >= 0; i--)
    *bptr++ = 0x7FFFFFFFL;

  /* For each color selected by find_nearby_colors,
   * compute its distance to the center of each cell in the box.
   * If that's less than best-so-far, update best distance and color number.
   */

  /* Nominal steps between cell centers ("x" in Thomas article) */
#define STEP_C0  ((1 << C0_SHIFT) * C0_SCALE)
#define STEP_C1  ((1 << C1_SHIFT) * C1_SCALE)
#define STEP_C2  ((1 << C2_SHIFT) * C2_SCALE)

  for (i = 0; i < numcolors; i++)
    {
      int r, g, b;
#ifdef ORIGINAL_LIB_JPEG

      icolor = GETJSAMPLE (colorlist[i]);
      r = GETJSAMPLE (cinfo->colormap[0][icolor]);
      g = GETJSAMPLE (cinfo->colormap[1][icolor]);
      b = GETJSAMPLE (cinfo->colormap[2][icolor]);
#else
      icolor = colorlist[i];
      r = nim->red[icolor];
      g = nim->green[icolor];
      b = nim->blue[icolor];
#endif

      /* Compute (square of) distance from minc0/c1/c2 to this color */
      inc0 = (minc0 - r) * C0_SCALE;
      dist0 = inc0 * inc0;
      inc1 = (minc1 - g) * C1_SCALE;
      dist0 += inc1 * inc1;
      inc2 = (minc2 - b) * C2_SCALE;
      dist0 += inc2 * inc2;
      /* Form the initial difference increments */
      inc0 = inc0 * (2 * STEP_C0) + STEP_C0 * STEP_C0;
      inc1 = inc1 * (2 * STEP_C1) + STEP_C1 * STEP_C1;
      inc2 = inc2 * (2 * STEP_C2) + STEP_C2 * STEP_C2;
      /* Now loop over all cells in box, updating distance per Thomas method */
      bptr = bestdist;
      cptr = bestcolor;
      xx0 = inc0;
      for (ic0 = BOX_C0_ELEMS - 1; ic0 >= 0; ic0--)
	{
	  dist1 = dist0;
	  xx1 = inc1;
	  for (ic1 = BOX_C1_ELEMS - 1; ic1 >= 0; ic1--)
	    {
	      dist2 = dist1;
	      xx2 = inc2;
	      for (ic2 = BOX_C2_ELEMS - 1; ic2 >= 0; ic2--)
		{
		  if (dist2 < *bptr)
		    {
		      *bptr = dist2;
		      *cptr = (JSAMPLE) icolor;
		    }
		  dist2 += xx2;
		  xx2 += 2 * STEP_C2 * STEP_C2;
		  bptr++;
		  cptr++;
		}
	      dist1 += xx1;
	      xx1 += 2 * STEP_C1 * STEP_C1;
	    }
	  dist0 += xx0;
	  xx0 += 2 * STEP_C0 * STEP_C0;
	}
    }
}


LOCAL (void)
fill_inverse_cmap (
#ifdef ORIGINAL_LIB_JPEG
		    j_decompress_ptr cinfo,
#else
		    gdImagePtr oim, gdImagePtr nim, my_cquantize_ptr cquantize,
#endif
		    int c0, int c1, int c2)
/* Fill the inverse-colormap entries in the update box that contains */
/* histogram cell c0/c1/c2.  (Only that one cell MUST be filled, but */
/* we can fill as many others as we wish.) */
{
#ifdef ORIGINAL_LIB_JPEG
  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
#endif
  hist3d histogram = cquantize->histogram;
  int minc0, minc1, minc2;	/* lower left corner of update box */
  int ic0, ic1, ic2;
  register JSAMPLE *cptr;	/* pointer into bestcolor[] array */
  register histptr cachep;	/* pointer into main cache array */
  /* This array lists the candidate colormap indexes. */
  JSAMPLE colorlist[MAXNUMCOLORS];
  int numcolors;		/* number of candidate colors */
  /* This array holds the actually closest colormap index for each cell. */
  JSAMPLE bestcolor[BOX_C0_ELEMS * BOX_C1_ELEMS * BOX_C2_ELEMS];

  /* Convert cell coordinates to update box ID */
  c0 >>= BOX_C0_LOG;
  c1 >>= BOX_C1_LOG;
  c2 >>= BOX_C2_LOG;

  /* Compute true coordinates of update box's origin corner.
   * Actually we compute the coordinates of the center of the corner
   * histogram cell, which are the lower bounds of the volume we care about.
   */
  minc0 = (c0 << BOX_C0_SHIFT) + ((1 << C0_SHIFT) >> 1);
  minc1 = (c1 << BOX_C1_SHIFT) + ((1 << C1_SHIFT) >> 1);
  minc2 = (c2 << BOX_C2_SHIFT) + ((1 << C2_SHIFT) >> 1);

  /* Determine which colormap entries are close enough to be candidates
   * for the nearest entry to some cell in the update box.
   */
#ifdef ORIGINAL_LIB_JPEG
  numcolors = find_nearby_colors (cinfo, minc0, minc1, minc2, colorlist);

  /* Determine the actually nearest colors. */
  find_best_colors (cinfo, minc0, minc1, minc2, numcolors, colorlist,
		    bestcolor);
#else
  numcolors =
    find_nearby_colors (oim, nim, cquantize, minc0, minc1, minc2, colorlist);
  find_best_colors (oim, nim, cquantize, minc0, minc1, minc2, numcolors,
		    colorlist, bestcolor);
#endif

  /* Save the best color numbers (plus 1) in the main cache array */
  c0 <<= BOX_C0_LOG;		/* convert ID back to base cell indexes */
  c1 <<= BOX_C1_LOG;
  c2 <<= BOX_C2_LOG;
  cptr = bestcolor;
  for (ic0 = 0; ic0 < BOX_C0_ELEMS; ic0++)
    {
      for (ic1 = 0; ic1 < BOX_C1_ELEMS; ic1++)
	{
	  cachep = &histogram[c0 + ic0][c1 + ic1][c2];
	  for (ic2 = 0; ic2 < BOX_C2_ELEMS; ic2++)
	    {
#ifdef ORIGINAL_LIB_JPEG
	      *cachep++ = (histcell) (GETJSAMPLE (*cptr++) + 1);
#else
	      *cachep++ = (histcell) ((*cptr++) + 1);
#endif
	    }
	}
    }
}


/*
 * Map some rows of pixels to the output colormapped representation.
 */

METHODDEF (void)
#ifndef ORIGINAL_LIB_JPEG
pass2_no_dither (gdImagePtr oim, gdImagePtr nim, my_cquantize_ptr cquantize)
{
  register int *inptr;
  register unsigned char *outptr;
  int width = oim->sx;
  int num_rows = oim->sy;
#else
pass2_no_dither (j_decompress_ptr cinfo,
		 JSAMPARRAY input_buf, JSAMPARRAY output_buf, int num_rows)
/* This version performs no dithering */
{
  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
  register JSAMPROW inptr, outptr;
  JDIMENSION width = cinfo->output_width;
#endif
  hist3d histogram = cquantize->histogram;
  register int c0, c1, c2;
  int row;
  JDIMENSION col;
  register histptr cachep;


  for (row = 0; row < num_rows; row++)
    {
      inptr = input_buf[row];
      outptr = output_buf[row];
      for (col = width; col > 0; col--)
	{
	  /* get pixel value and index into the cache */
	  int r, g, b;
#ifdef ORIGINAL_LIB_JPEG
	  r = GETJSAMPLE (*inptr++);
	  g = GETJSAMPLE (*inptr++);
	  b = GETJSAMPLE (*inptr++);
#else
	  r = gdTrueColorGetRed (*inptr);
	  g = gdTrueColorGetGreen (*inptr);
	  /* 
	     2.0.24: inptr must not be incremented until after
	     transparency check, if any. Thanks to "Super Pikeman." 
	   */
	  b = gdTrueColorGetBlue (*inptr);

	  /* If the pixel is transparent, we assign it the palette index that
	   * will later be added at the end of the palette as the transparent
	   * index. */
	  if ((oim->transparent >= 0) && (oim->transparent == *inptr))
	    {
	      *outptr++ = nim->colorsTotal;
	      inptr++;
	      continue;
	    }
	  inptr++;
#endif
	  c0 = r >> C0_SHIFT;
	  c1 = g >> C1_SHIFT;
	  c2 = b >> C2_SHIFT;
	  cachep = &histogram[c0][c1][c2];
	  /* If we have not seen this color before, find nearest colormap entry */
	  /* and update the cache */
	  if (*cachep == 0)
#ifdef ORIGINAL_LIB_JPEG
	    fill_inverse_cmap (cinfo, c0, c1, c2);
#else
	    fill_inverse_cmap (oim, nim, cquantize, c0, c1, c2);
#endif
	  /* Now emit the colormap index for this cell */
#ifdef ORIGINAL_LIB_JPEG
	  *outptr++ = (JSAMPLE) (*cachep - 1);
#else
	  *outptr++ = (*cachep - 1);
#endif
	}
    }
}


METHODDEF (void)
#ifndef ORIGINAL_LIB_JPEG
pass2_fs_dither (gdImagePtr oim, gdImagePtr nim, my_cquantize_ptr cquantize)
{
#else
pass2_fs_dither (j_decompress_ptr cinfo,
		 JSAMPARRAY input_buf, JSAMPARRAY output_buf, int num_rows)
/* This version performs Floyd-Steinberg dithering */
{
  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
  JSAMPROW inptr;		/* => current input pixel */
#endif
  hist3d histogram = cquantize->histogram;
  register LOCFSERROR cur0, cur1, cur2;	/* current error or pixel value */
  LOCFSERROR belowerr0, belowerr1, belowerr2;	/* error for pixel below cur */
  LOCFSERROR bpreverr0, bpreverr1, bpreverr2;	/* error for below/prev col */
  register FSERRPTR errorptr;	/* => fserrors[] at column before current */
  histptr cachep;
  int dir;			/* +1 or -1 depending on direction */
  int dir3;			/* 3*dir, for advancing inptr & errorptr */
  int row;
  JDIMENSION col;
#ifdef ORIGINAL_LIB_JPEG
  JSAMPROW outptr;		/* => current output pixel */
  JDIMENSION width = cinfo->output_width;
  JSAMPLE *range_limit = cinfo->sample_range_limit;
  JSAMPROW colormap0 = cinfo->colormap[0];
  JSAMPROW colormap1 = cinfo->colormap[1];
  JSAMPROW colormap2 = cinfo->colormap[2];
#else
  int *inptr;			/* => current input pixel */
  unsigned char *outptr;	/* => current output pixel */
  int width = oim->sx;
  int num_rows = oim->sy;
  int *colormap0 = nim->red;
  int *colormap1 = nim->green;
  int *colormap2 = nim->blue;
#endif
  int *error_limit = cquantize->error_limiter;


  SHIFT_TEMPS for (row = 0; row < num_rows; row++)
    {
      inptr = input_buf[row];
      outptr = output_buf[row];
      if (cquantize->on_odd_row)
	{
	  /* work right to left in this row */
	  inptr += (width - 1) * 3;	/* so point to rightmost pixel */
	  outptr += width - 1;
	  dir = -1;
	  dir3 = -3;
	  errorptr = cquantize->fserrors + (width + 1) * 3;	/* => entry after last column */
#ifdef ORIGINAL_LIB_JPEG_REVERSE_ODD_ROWS
	  cquantize->on_odd_row = FALSE;	/* flip for next time */
#endif
	}
      else
	{
	  /* work left to right in this row */
	  dir = 1;
	  dir3 = 3;
	  errorptr = cquantize->fserrors;	/* => entry before first real column */
#ifdef ORIGINAL_LIB_JPEG_REVERSE_ODD_ROWS
	  cquantize->on_odd_row = TRUE;	/* flip for next time */
#endif
	}
      /* Preset error values: no error propagated to first pixel from left */
      cur0 = cur1 = cur2 = 0;
      /* and no error propagated to row below yet */
      belowerr0 = belowerr1 = belowerr2 = 0;
      bpreverr0 = bpreverr1 = bpreverr2 = 0;

      for (col = width; col > 0; col--)
	{

	  /* If this pixel is transparent, we want to assign it to the special
	   * transparency color index past the end of the palette rather than
	   * go through matching / dithering. */
	  if ((oim->transparent >= 0) && (*inptr == oim->transparent))
	    {
	      *outptr = nim->colorsTotal;
	      errorptr[0] = 0;
	      errorptr[1] = 0;
	      errorptr[2] = 0;
	      errorptr[3] = 0;
	      inptr += dir;
	      outptr += dir;
	      errorptr += dir3;
	      continue;
	    }
	  /* curN holds the error propagated from the previous pixel on the
	   * current line.  Add the error propagated from the previous line
	   * to form the complete error correction term for this pixel, and
	   * round the error term (which is expressed * 16) to an integer.
	   * RIGHT_SHIFT rounds towards minus infinity, so adding 8 is correct
	   * for either sign of the error value.
	   * Note: errorptr points to *previous* column's array entry.
	   */
	  cur0 = RIGHT_SHIFT (cur0 + errorptr[dir3 + 0] + 8, 4);
	  cur1 = RIGHT_SHIFT (cur1 + errorptr[dir3 + 1] + 8, 4);
	  cur2 = RIGHT_SHIFT (cur2 + errorptr[dir3 + 2] + 8, 4);
	  /* Limit the error using transfer function set by init_error_limit.
	   * See comments with init_error_limit for rationale.
	   */
	  cur0 = error_limit[cur0];
	  cur1 = error_limit[cur1];
	  cur2 = error_limit[cur2];
	  /* Form pixel value + error, and range-limit to 0..MAXJSAMPLE.
	   * The maximum error is +- MAXJSAMPLE (or less with error limiting);
	   * this sets the required size of the range_limit array.
	   */
#ifdef ORIGINAL_LIB_JPEG
	  cur0 += GETJSAMPLE (inptr[0]);
	  cur1 += GETJSAMPLE (inptr[1]);
	  cur2 += GETJSAMPLE (inptr[2]);
	  cur0 = GETJSAMPLE (range_limit[cur0]);
	  cur1 = GETJSAMPLE (range_limit[cur1]);
	  cur2 = GETJSAMPLE (range_limit[cur2]);
#else
	  cur0 += gdTrueColorGetRed (*inptr);
	  cur1 += gdTrueColorGetGreen (*inptr);
	  cur2 += gdTrueColorGetBlue (*inptr);
	  range_limit (cur0);
	  range_limit (cur1);
	  range_limit (cur2);
#endif

	  /* Index into the cache with adjusted pixel value */
	  cachep =
	    &histogram[cur0 >> C0_SHIFT][cur1 >> C1_SHIFT][cur2 >> C2_SHIFT];
	  /* If we have not seen this color before, find nearest colormap */
	  /* entry and update the cache */
	  if (*cachep == 0)
#ifdef ORIGINAL_LIB_JPEG
	    fill_inverse_cmap (cinfo, cur0 >> C0_SHIFT, cur1 >> C1_SHIFT,
			       cur2 >> C2_SHIFT);
#else
	    fill_inverse_cmap (oim, nim, cquantize, cur0 >> C0_SHIFT,
			       cur1 >> C1_SHIFT, cur2 >> C2_SHIFT);
#endif
	  /* Now emit the colormap index for this cell */
	  {
	    register int pixcode = *cachep - 1;
	    *outptr = (JSAMPLE) pixcode;
	    /* Compute representation error for this pixel */
#define GETJSAMPLE
	    cur0 -= GETJSAMPLE (colormap0[pixcode]);
	    cur1 -= GETJSAMPLE (colormap1[pixcode]);
	    cur2 -= GETJSAMPLE (colormap2[pixcode]);
#undef GETJSAMPLE
	  }
	  /* Compute error fractions to be propagated to adjacent pixels.
	   * Add these into the running sums, and simultaneously shift the
	   * next-line error sums left by 1 column.
	   */
	  {
	    register LOCFSERROR bnexterr, delta;

	    bnexterr = cur0;	/* Process component 0 */
	    delta = cur0 * 2;
	    cur0 += delta;	/* form error * 3 */
	    errorptr[0] = (FSERROR) (bpreverr0 + cur0);
	    cur0 += delta;	/* form error * 5 */
	    bpreverr0 = belowerr0 + cur0;
	    belowerr0 = bnexterr;
	    cur0 += delta;	/* form error * 7 */
	    bnexterr = cur1;	/* Process component 1 */
	    delta = cur1 * 2;
	    cur1 += delta;	/* form error * 3 */
	    errorptr[1] = (FSERROR) (bpreverr1 + cur1);
	    cur1 += delta;	/* form error * 5 */
	    bpreverr1 = belowerr1 + cur1;
	    belowerr1 = bnexterr;
	    cur1 += delta;	/* form error * 7 */
	    bnexterr = cur2;	/* Process component 2 */
	    delta = cur2 * 2;
	    cur2 += delta;	/* form error * 3 */
	    errorptr[2] = (FSERROR) (bpreverr2 + cur2);
	    cur2 += delta;	/* form error * 5 */
	    bpreverr2 = belowerr2 + cur2;
	    belowerr2 = bnexterr;
	    cur2 += delta;	/* form error * 7 */
	  }
	  /* At this point curN contains the 7/16 error value to be propagated
	   * to the next pixel on the current line, and all the errors for the
	   * next line have been shifted over.  We are therefore ready to move on.
	   */
#ifdef ORIGINAL_LIB_JPEG
	  inptr += dir3;	/* Advance pixel pointers to next column */
#else
	  inptr += dir;		/* Advance pixel pointers to next column */
#endif
	  outptr += dir;
	  errorptr += dir3;	/* advance errorptr to current column */
	}
      /* Post-loop cleanup: we must unload the final error values into the
       * final fserrors[] entry.  Note we need not unload belowerrN because
       * it is for the dummy column before or after the actual array.
       */
      errorptr[0] = (FSERROR) bpreverr0;	/* unload prev errs into array */
      errorptr[1] = (FSERROR) bpreverr1;
      errorptr[2] = (FSERROR) bpreverr2;
    }
}


/*
 * Initialize the error-limiting transfer function (lookup table).
 * The raw F-S error computation can potentially compute error values of up to
 * +- MAXJSAMPLE.  But we want the maximum correction applied to a pixel to be
 * much less, otherwise obviously wrong pixels will be created.  (Typical
 * effects include weird fringes at color-area boundaries, isolated bright
 * pixels in a dark area, etc.)  The standard advice for avoiding this problem
 * is to ensure that the "corners" of the color cube are allocated as output
 * colors; then repeated errors in the same direction cannot cause cascading
 * error buildup.  However, that only prevents the error from getting
 * completely out of hand; Aaron Giles reports that error limiting improves
 * the results even with corner colors allocated.
 * A simple clamping of the error values to about +- MAXJSAMPLE/8 works pretty
 * well, but the smoother transfer function used below is even better.  Thanks
 * to Aaron Giles for this idea.
 */

LOCAL (void)
#ifdef ORIGINAL_LIB_JPEG
init_error_limit (j_decompress_ptr cinfo)
#else
init_error_limit (gdImagePtr oim, gdImagePtr nim, my_cquantize_ptr cquantize)
#endif
/* Allocate and fill in the error_limiter table */
{
  int *table;
  int in, out;
#ifdef ORIGINAL_LIB_JPEG
  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
  table = (int *) (*cinfo->mem->alloc_small)
    ((j_common_ptr) cinfo, JPOOL_IMAGE, (MAXJSAMPLE * 2 + 1) * SIZEOF (int));
#else
  cquantize->error_limiter_storage =
    (int *) gdMalloc ((MAXJSAMPLE * 2 + 1) * sizeof (int));
  if (!cquantize->error_limiter_storage)
    {
      return;
    }
  table = cquantize->error_limiter_storage;
#endif

  table += MAXJSAMPLE;		/* so can index -MAXJSAMPLE .. +MAXJSAMPLE */
  cquantize->error_limiter = table;

#define STEPSIZE ((MAXJSAMPLE+1)/16)
  /* Map errors 1:1 up to +- MAXJSAMPLE/16 */
  out = 0;
  for (in = 0; in < STEPSIZE; in++, out++)
    {
      table[in] = out;
      table[-in] = -out;
    }
  /* Map errors 1:2 up to +- 3*MAXJSAMPLE/16 */
  for (; in < STEPSIZE * 3; in++, out += (in & 1) ? 0 : 1)
    {
      table[in] = out;
      table[-in] = -out;
    }
  /* Clamp the rest to final out value (which is (MAXJSAMPLE+1)/8) */
  for (; in <= MAXJSAMPLE; in++)
    {
      table[in] = out;
      table[-in] = -out;
    }
#undef STEPSIZE
}


/*
 * Finish up at the end of each pass.
 */

#ifdef ORIGINAL_LIB_JPEG
METHODDEF (void)
finish_pass1 (j_decompress_ptr cinfo)
{
  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;

  /* Select the representative colors and fill in cinfo->colormap */
  cinfo->colormap = cquantize->sv_colormap;
  select_colors (cinfo, cquantize->desired);
  /* Force next pass to zero the color index table */
  cquantize->needs_zeroed = TRUE;
}


METHODDEF (void)
finish_pass2 (j_decompress_ptr cinfo)
{
  /* no work */
}

/*
 * Initialize for each processing pass.
 */

METHODDEF (void)
start_pass_2_quant (j_decompress_ptr cinfo, boolean is_pre_scan)
{
  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
  hist3d histogram = cquantize->histogram;
  int i;

  /* Only F-S dithering or no dithering is supported. */
  /* If user asks for ordered dither, give him F-S. */
  if (cinfo->dither_mode != JDITHER_NONE)
    cinfo->dither_mode = JDITHER_FS;

  if (is_pre_scan)
    {
      /* Set up method pointers */
      cquantize->pub.color_quantize = prescan_quantize;
      cquantize->pub.finish_pass = finish_pass1;
      cquantize->needs_zeroed = TRUE;	/* Always zero histogram */
    }
  else
    {
      /* Set up method pointers */
      if (cinfo->dither_mode == JDITHER_FS)
	cquantize->pub.color_quantize = pass2_fs_dither;
      else
	cquantize->pub.color_quantize = pass2_no_dither;
      cquantize->pub.finish_pass = finish_pass2;

      /* Make sure color count is acceptable */
      i = cinfo->actual_number_of_colors;
      if (i < 1)
	ERREXIT1 (cinfo, JERR_QUANT_FEW_COLORS, 1);
      if (i > MAXNUMCOLORS)
	ERREXIT1 (cinfo, JERR_QUANT_MANY_COLORS, MAXNUMCOLORS);

      if (cinfo->dither_mode == JDITHER_FS)
	{
	  size_t arraysize = (size_t) ((cinfo->output_width + 2) *
				       (3 * SIZEOF (FSERROR)));
	  /* Allocate Floyd-Steinberg workspace if we didn't already. */
	  if (cquantize->fserrors == NULL)
	    cquantize->fserrors = (FSERRPTR) (*cinfo->mem->alloc_large)
	      ((j_common_ptr) cinfo, JPOOL_IMAGE, arraysize);
	  /* Initialize the propagated errors to zero. */
	  jzero_far ((void FAR *) cquantize->fserrors, arraysize);
	  /* Make the error-limit table if we didn't already. */
	  if (cquantize->error_limiter == NULL)
	    init_error_limit (cinfo);
	  cquantize->on_odd_row = FALSE;
	}

    }
  /* Zero the histogram or inverse color map, if necessary */
  if (cquantize->needs_zeroed)
    {
      for (i = 0; i < HIST_C0_ELEMS; i++)
	{
	  jzero_far ((void FAR *) histogram[i],
		     HIST_C1_ELEMS * HIST_C2_ELEMS * SIZEOF (histcell));
	}
      cquantize->needs_zeroed = FALSE;
    }
}


/*
 * Switch to a new external colormap between output passes.
 */

METHODDEF (void)
new_color_map_2_quant (j_decompress_ptr cinfo)
{
  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;

  /* Reset the inverse color map */
  cquantize->needs_zeroed = TRUE;
}
#else
static void
zeroHistogram (hist3d histogram)
{
  int i;
  /* Zero the histogram or inverse color map */
  for (i = 0; i < HIST_C0_ELEMS; i++)
    {
      memset (histogram[i],
	      0, HIST_C1_ELEMS * HIST_C2_ELEMS * sizeof (histcell));
    }
}
#endif

static void gdImageTrueColorToPaletteBody (gdImagePtr oim, int dither, int colorsWanted, gdImagePtr *cimP);

BGD_DECLARE(gdImagePtr) gdImageCreatePaletteFromTrueColor (gdImagePtr im, int dither, int colorsWanted)
{
	gdImagePtr nim;
	gdImageTrueColorToPaletteBody(im, dither, colorsWanted, &nim);
	return nim;
}

BGD_DECLARE(void) gdImageTrueColorToPalette (gdImagePtr im, int dither, int colorsWanted)
{
	gdImageTrueColorToPaletteBody(im, dither, colorsWanted, 0);
}

/*
 * Module initialization routine for 2-pass color quantization.
 */

#ifdef ORIGINAL_LIB_JPEG
GLOBAL (void)
jinit_2pass_quantizer (j_decompress_ptr cinfo)
#else
static void gdImageTrueColorToPaletteBody (gdImagePtr oim, int dither, int colorsWanted, gdImagePtr *cimP)
#endif
{
  my_cquantize_ptr cquantize = NULL;
  int i;

#ifndef ORIGINAL_LIB_JPEG
  /* Allocate the JPEG palette-storage */
  size_t arraysize;
  int maxColors = gdMaxColors;
  gdImagePtr nim;
  if (cimP) {
    nim = gdImageCreate(oim->sx, oim->sy);
    *cimP = nim;
    if (!nim) {
      return;
    }
  } else {
    nim = oim;
  }     
  if (!oim->trueColor)
    {
      /* (Almost) nothing to do! */
      if (cimP) {
        gdImageCopy(nim, oim, 0, 0, 0, 0, oim->sx, oim->sy);
        *cimP = nim;
      }
      return;
    }

  /* If we have a transparent color (the alphaless mode of transparency), we
   * must reserve a palette entry for it at the end of the palette. */
  if (oim->transparent >= 0)
    {
      maxColors--;
    }
  if (colorsWanted > maxColors)
    {
      colorsWanted = maxColors;
    }
  if (!cimP) {
    nim->pixels = gdCalloc (sizeof (unsigned char *), oim->sy);
    if (!nim->pixels)
      {
        /* No can do */
        goto outOfMemory;
      }
    for (i = 0; (i < nim->sy); i++)
      {
        nim->pixels[i] = gdCalloc (sizeof (unsigned char *), oim->sx);
        if (!nim->pixels[i])
  	{
  	  goto outOfMemory;
  	}
      }
  }
#endif

#ifdef ORIGINAL_LIB_JPEG
  cquantize = (my_cquantize_ptr)
    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
				SIZEOF (my_cquantizer));
  cinfo->cquantize = (struct jpeg_color_quantizer *) cquantize;
  cquantize->pub.start_pass = start_pass_2_quant;
  cquantize->pub.new_color_map = new_color_map_2_quant;
  /* Make sure jdmaster didn't give me a case I can't handle */
  if (cinfo->out_color_components != 3)
    ERREXIT (cinfo, JERR_NOTIMPL);
#else
  cquantize = (my_cquantize_ptr) gdCalloc (sizeof (my_cquantizer), 1);
  if (!cquantize)
    {
      /* No can do */
      goto outOfMemory;
    }
#endif
  cquantize->fserrors = NULL;	/* flag optional arrays not allocated */
  cquantize->error_limiter = NULL;


  /* Allocate the histogram/inverse colormap storage */
#ifdef ORIGINAL_LIB_JPEG
  cquantize->histogram = (hist3d) (*cinfo->mem->alloc_small)
    ((j_common_ptr) cinfo, JPOOL_IMAGE, HIST_C0_ELEMS * SIZEOF (hist2d));
  for (i = 0; i < HIST_C0_ELEMS; i++)
    {
      cquantize->histogram[i] = (hist2d) (*cinfo->mem->alloc_large)
	((j_common_ptr) cinfo, JPOOL_IMAGE,
	 HIST_C1_ELEMS * HIST_C2_ELEMS * SIZEOF (histcell));
    }
  cquantize->needs_zeroed = TRUE;	/* histogram is garbage now */
#else
  cquantize->histogram = (hist3d) gdMalloc (HIST_C0_ELEMS * sizeof (hist2d));
  for (i = 0; i < HIST_C0_ELEMS; i++)
    {
      cquantize->histogram[i] =
	(hist2d) gdMalloc (HIST_C1_ELEMS * HIST_C2_ELEMS * sizeof (histcell));
      if (!cquantize->histogram[i])
	{
	  goto outOfMemory;
	}
    }
#endif

#ifdef ORIGINAL_LIB_JPEG
  /* Allocate storage for the completed colormap, if required.
   * We do this now since it is FAR storage and may affect
   * the memory manager's space calculations.
   */
  if (cinfo->enable_2pass_quant)
    {
      /* Make sure color count is acceptable */
      int desired = cinfo->desired_number_of_colors;
      /* Lower bound on # of colors ... somewhat arbitrary as long as > 0 */
      if (desired < 8)
	ERREXIT1 (cinfo, JERR_QUANT_FEW_COLORS, 8);
      /* Make sure colormap indexes can be represented by JSAMPLEs */
      if (desired > MAXNUMCOLORS)
	ERREXIT1 (cinfo, JERR_QUANT_MANY_COLORS, MAXNUMCOLORS);
      cquantize->sv_colormap = (*cinfo->mem->alloc_sarray)
	((j_common_ptr) cinfo, JPOOL_IMAGE, (JDIMENSION) desired,
	 (JDIMENSION) 3);
      cquantize->desired = desired;
    }
  else
    cquantize->sv_colormap = NULL;

  /* Only F-S dithering or no dithering is supported. */
  /* If user asks for ordered dither, give him F-S. */
  if (cinfo->dither_mode != JDITHER_NONE)
    cinfo->dither_mode = JDITHER_FS;

  /* Allocate Floyd-Steinberg workspace if necessary.
   * This isn't really needed until pass 2, but again it is FAR storage.
   * Although we will cope with a later change in dither_mode,
   * we do not promise to honor max_memory_to_use if dither_mode changes.
   */
  if (cinfo->dither_mode == JDITHER_FS)
    {
      cquantize->fserrors = (FSERRPTR) (*cinfo->mem->alloc_large)
	((j_common_ptr) cinfo, JPOOL_IMAGE,
	 (size_t) ((cinfo->output_width + 2) * (3 * SIZEOF (FSERROR))));
      /* Might as well create the error-limiting table too. */
      init_error_limit (cinfo);
    }
#else

  cquantize->fserrors = (FSERRPTR) gdMalloc (3 * sizeof (FSERROR));
  init_error_limit (oim, nim, cquantize);
  arraysize = (size_t) ((nim->sx + 2) * (3 * sizeof (FSERROR)));
  /* Allocate Floyd-Steinberg workspace. */
	cquantize->fserrors = gdRealloc(cquantize->fserrors, arraysize);
  if (!cquantize->fserrors)
    {
      goto outOfMemory;
    }
  memset(cquantize->fserrors, 0, arraysize);
  cquantize->on_odd_row = FALSE;

  /* Do the work! */
  zeroHistogram (cquantize->histogram);
  prescan_quantize (oim, nim, cquantize);
  /* TBB 2.0.5: pass colorsWanted, not 256! */
  select_colors (oim, nim, cquantize, colorsWanted);
  zeroHistogram (cquantize->histogram);
  if (dither)
    {
      pass2_fs_dither (oim, nim, cquantize);
    }
  else
    {
      pass2_no_dither (oim, nim, cquantize);
    }
#if 0				/* 2.0.12; we no longer attempt full alpha in palettes */
  if (cquantize->transparentIsPresent)
    {
      int mt = -1;
      int mtIndex = -1;
      for (i = 0; (i < im->colorsTotal); i++)
	{
	  if (im->alpha[i] > mt)
	    {
	      mtIndex = i;
	      mt = im->alpha[i];
	    }
	}
      for (i = 0; (i < im->colorsTotal); i++)
	{
	  if (im->alpha[i] == mt)
	    {
	      im->alpha[i] = gdAlphaTransparent;
	    }
	}
    }
  if (cquantize->opaqueIsPresent)
    {
      int mo = 128;
      int moIndex = -1;
      for (i = 0; (i < im->colorsTotal); i++)
	{
	  if (im->alpha[i] < mo)
	    {
	      moIndex = i;
	      mo = im->alpha[i];
	    }
	}
      for (i = 0; (i < im->colorsTotal); i++)
	{
	  if (im->alpha[i] == mo)
	    {
	      im->alpha[i] = gdAlphaOpaque;
	    }
	}
    }
#endif

  /* If we had a 'transparent' color, increment the color count so it's
   * officially in the palette and convert the transparent variable to point to
   * an index rather than a color (Its data already exists and transparent
   * pixels have already been mapped to it by this point, it is done late as to
   * avoid color matching / dithering with it). */
  if (oim->transparent >= 0)
    {
      nim->transparent = nim->colorsTotal;
      nim->colorsTotal++;
    }

  /* Success! Get rid of the truecolor image data. */
  if (!cimP) { 
    oim->trueColor = 0;
    /* Junk the truecolor pixels */
    for (i = 0; i < oim->sy; i++)
      {
        gdFree (oim->tpixels[i]);
      }
    gdFree (oim->tpixels);
    oim->tpixels = 0;
  }
  goto success;
  /* Tediously free stuff. */
outOfMemory:
  if (oim->trueColor)
    {
      if (!cimP) {
        /* On failure only */
        for (i = 0; i < nim->sy; i++)
  	{
  	  if (nim->pixels[i])
  	    {
  	      gdFree (nim->pixels[i]);
  	    }
  	}
        if (nim->pixels)
  	{
  	  gdFree (nim->pixels);
  	}
        nim->pixels = 0;
      } else {
        gdImageDestroy(nim);
        *cimP = 0;
      }
    }
success:
  for (i = 0; i < HIST_C0_ELEMS; i++)
    {
      if (cquantize->histogram[i])
	{
	  gdFree (cquantize->histogram[i]);
	}
    }
  if (cquantize->histogram)
    {
      gdFree (cquantize->histogram);
    }
  if (cquantize->fserrors)
    {
      gdFree (cquantize->fserrors);
    }
  if (cquantize->error_limiter_storage)
    {
      gdFree (cquantize->error_limiter_storage);
    }
  if (cquantize)
    {
      gdFree (cquantize);
    }

#endif
}

#endif
5588        312592      242016      1193225269  200         0           100640      9   gd_wbmp.c `


/*
   WBMP: Wireless Bitmap Type 0: B/W, Uncompressed Bitmap
   Specification of the WBMP format can be found in the file: 
   SPEC-WAESpec-19990524.pdf
   You can download the WAP specification on: http://www.wapforum.com/ 

   gd_wbmp.c

   Copyright (C) Johan Van den Brande (johan@vandenbrande.com)

   Fixed: gdImageWBMPPtr, gdImageWBMP

   Recoded: gdImageWBMPCtx for use with my wbmp library
   (wbmp library included, but you can find the latest distribution
   at http://www.vandenbrande.com/wbmp)

   Implemented: gdImageCreateFromWBMPCtx, gdImageCreateFromWBMP 

   ---------------------------------------------------------------------------

   Parts of this code are from Maurice Smurlo.


   ** Copyright (C) Maurice Szmurlo --- T-SIT --- January 2000
   ** (Maurice.Szmurlo@info.unicaen.fr)

   ** Permission to use, copy, modify, and distribute this software and its
   ** documentation for any purpose and without fee is hereby granted, provided
   ** that the above copyright notice appear in all copies and that both that
   ** copyright notice and this permission notice appear in supporting
   ** documentation.  This software is provided "as is" without express or
   ** implied warranty.

   ---------------------------------------------------------------------------
   Parts od this code are inspired by  'pbmtowbmp.c' and 'wbmptopbm.c' by 
   Terje Sannum <terje@looplab.com>.
   **
   ** Permission to use, copy, modify, and distribute this software and its
   ** documentation for any purpose and without fee is hereby granted, provided
   ** that the above copyright notice appear in all copies and that both that
   ** copyright notice and this permission notice appear in supporting
   ** documentation.  This software is provided "as is" without express or
   ** implied warranty.
   **
   ---------------------------------------------------------------------------

   Todo:

   gdCreateFromWBMP function for reading WBMP files

   ----------------------------------------------------------------------------
 */

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include "gd.h"
#include "gdfonts.h"
#include <stdio.h>
#include <stdlib.h>
#include <limits.h>

#include "wbmp.h"


/* gd_putout
   ** ---------
   ** Wrapper around gdPutC for use with writewbmp
   **
 */
void
gd_putout (int i, void *out)
{
  gdPutC (i, (gdIOCtx *) out);
}


/* gd_getin
   ** --------
   ** Wrapper around gdGetC for use with readwbmp
   **
 */
int
gd_getin (void *in)
{
  return (gdGetC ((gdIOCtx *) in));
}


/*      gdImageWBMPCtx
   **  --------------
   **  Write the image as a wbmp file
   **  Parameters are:
   **  image:  gd image structure;
   **  fg:     the index of the foreground color. any other value will be 
   **          considered as background and will not be written
   **  out:    the stream where to write
 */
BGD_DECLARE(void) gdImageWBMPCtx (gdImagePtr image, int fg, gdIOCtx * out)
{

  int x, y, pos;
  Wbmp *wbmp;


  /* create the WBMP */
  if ((wbmp =
       createwbmp (gdImageSX (image), gdImageSY (image), WBMP_WHITE)) == NULL)
    fprintf (stderr, "Could not create WBMP\n");

  /* fill up the WBMP structure */
  pos = 0;
  for (y = 0; y < gdImageSY (image); y++)
    {
      for (x = 0; x < gdImageSX (image); x++)
	{
	  if (gdImageGetPixel (image, x, y) == fg)
	    {
	      wbmp->bitmap[pos] = WBMP_BLACK;
	    }
	  pos++;
	}
    }

  /* write the WBMP to a gd file descriptor */
  if (writewbmp (wbmp, &gd_putout, out))
    fprintf (stderr, "Could not save WBMP\n");
  /* des submitted this bugfix: gdFree the memory. */
  freewbmp (wbmp);
}


/* gdImageCreateFromWBMPCtx
   ** ------------------------
   ** Create a gdImage from a WBMP file input from an gdIOCtx
 */
BGD_DECLARE(gdImagePtr) gdImageCreateFromWBMPCtx (gdIOCtx * infile)
{
  /* FILE *wbmp_file; */
  Wbmp *wbmp;
  gdImagePtr im = NULL;
  int black, white;
  int col, row, pos;

  if (readwbmp (&gd_getin, infile, &wbmp))
    return (NULL);

  if (!(im = gdImageCreate (wbmp->width, wbmp->height)))
    {
      freewbmp (wbmp);
      return (NULL);
    }

  /* create the background color */
  white = gdImageColorAllocate (im, 255, 255, 255);
  /* create foreground color */
  black = gdImageColorAllocate (im, 0, 0, 0);

  /* fill in image (in a wbmp 1 = white/ 0 = black) */
  pos = 0;
  for (row = 0; row < wbmp->height; row++)
    {
      for (col = 0; col < wbmp->width; col++)
	{
	  if (wbmp->bitmap[pos++] == WBMP_WHITE)
	    {
	      gdImageSetPixel (im, col, row, white);
	    }
	  else
	    {
	      gdImageSetPixel (im, col, row, black);
	    }
	}
    }

  freewbmp (wbmp);

  return (im);
}


/* gdImageCreateFromWBMP
   ** ---------------------
 */
BGD_DECLARE(gdImagePtr) gdImageCreateFromWBMP (FILE * inFile)
{
  gdImagePtr im;
  gdIOCtx *in = gdNewFileCtx (inFile);
  im = gdImageCreateFromWBMPCtx (in);
  in->gd_free (in);
  return (im);
}

BGD_DECLARE(gdImagePtr) gdImageCreateFromWBMPPtr (int size, void *data)
{
  gdImagePtr im;
  gdIOCtx *in = gdNewDynamicCtxEx (size, data, 0);
  im = gdImageCreateFromWBMPCtx (in);
  in->gd_free (in);
  return im;
}

/* gdImageWBMP
   ** -----------
 */
BGD_DECLARE(void) gdImageWBMP (gdImagePtr im, int fg, FILE * outFile)
{
  gdIOCtx *out = gdNewFileCtx (outFile);
  gdImageWBMPCtx (im, fg, out);
  out->gd_free (out);
}

/* gdImageWBMPPtr
   ** --------------
 */
BGD_DECLARE(void *)
gdImageWBMPPtr (gdImagePtr im, int *size, int fg)
{
  void *rv;
  gdIOCtx *out = gdNewDynamicCtx (2048, NULL);
  gdImageWBMPCtx (im, fg, out);
  rv = gdDPExtractData (out, size);
  out->gd_free (out);
  return rv;
}


5382        318074      306904      1193070199  200         0           100640      9   gdcache.c `

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include "gd.h"
#include "gdhelpers.h"

#ifdef HAVE_LIBTTF
#define NEED_CACHE 1
#else
#ifdef HAVE_LIBFREETYPE
#define NEED_CACHE 1
#endif
#endif

#ifdef NEED_CACHE

/* 
 * gdcache.c
 *
 * Caches of pointers to user structs in which the least-recently-used 
 * element is replaced in the event of a cache miss after the cache has 
 * reached a given size.
 *
 * John Ellson  (ellson@graphviz.org)  Oct 31, 1997
 *
 * Test this with:
 *               gcc -o gdcache -g -Wall -DTEST gdcache.c
 *
 * The cache is implemented by a singly-linked list of elements
 * each containing a pointer to a user struct that is being managed by
 * the cache.
 *
 * The head structure has a pointer to the most-recently-used
 * element, and elements are moved to this position in the list each
 * time they are used.  The head also contains pointers to three
 * user defined functions: 
 *              - a function to test if a cached userdata matches some keydata 
 *              - a function to provide a new userdata struct to the cache 
 *          if there has been a cache miss.
 *              - a function to release a userdata struct when it is
 *          no longer being managed by the cache
 *
 * In the event of a cache miss the cache is allowed to grow up to
 * a specified maximum size.  After the maximum size is reached then
 * the least-recently-used element is discarded to make room for the 
 * new.  The most-recently-returned value is always left at the 
 * beginning of the list after retrieval.
 *
 * In the current implementation the cache is traversed by a linear
 * search from most-recent to least-recent.  This linear search
 * probably limits the usefulness of this implementation to cache
 * sizes of a few tens of elements.
 */

#include "gdcache.h"

/*********************************************************/
/* implementation                                        */
/*********************************************************/


/* create a new cache */
gdCache_head_t *
gdCacheCreate (int size,
	       gdCacheTestFn_t gdCacheTest,
	       gdCacheFetchFn_t gdCacheFetch,
	       gdCacheReleaseFn_t gdCacheRelease)
{
  gdCache_head_t *head;

  head = (gdCache_head_t *) gdMalloc (sizeof (gdCache_head_t));
	if (!head) {
		return NULL;
	}

  head->mru = NULL;
  head->size = size;
  head->gdCacheTest = gdCacheTest;
  head->gdCacheFetch = gdCacheFetch;
  head->gdCacheRelease = gdCacheRelease;
  return head;
}

void
gdCacheDelete (gdCache_head_t * head)
{
  gdCache_element_t *elem, *prev;

  elem = head->mru;
  while (elem)
    {
      (*(head->gdCacheRelease)) (elem->userdata);
      prev = elem;
      elem = elem->next;
      gdFree ((char *) prev);
    }
  gdFree ((char *) head);
}

void *
gdCacheGet (gdCache_head_t * head, void *keydata)
{
  int i = 0;
  gdCache_element_t *elem, *prev = NULL, *prevprev = NULL;
  void *userdata;

  elem = head->mru;
  while (elem)
    {
      if ((*(head->gdCacheTest)) (elem->userdata, keydata))
	{
	  if (i)
	    {			/* if not already most-recently-used */
	      /* relink to top of list */
	      prev->next = elem->next;
	      elem->next = head->mru;
	      head->mru = elem;
	    }
	  return elem->userdata;
	}
      prevprev = prev;
      prev = elem;
      elem = elem->next;
      i++;
    }
  userdata = (*(head->gdCacheFetch)) (&(head->error), keydata);
  if (!userdata)
    {
      /* if there was an error in the fetch then don't cache */
      return NULL;
    }
  if (i < head->size)
    {				/* cache still growing - add new elem */
      elem = (gdCache_element_t *) gdMalloc (sizeof (gdCache_element_t));
			if (!elem)
			 {
				(*(head->gdCacheRelease)) (userdata);
					return NULL;
			 }
    }
  else
    {				/* cache full - replace least-recently-used */
      /* preveprev becomes new end of list */
      prevprev->next = NULL;
      elem = prev;
      (*(head->gdCacheRelease)) (elem->userdata);
    }
  /* relink to top of list */
  elem->next = head->mru;
  head->mru = elem;
  elem->userdata = userdata;
  return userdata;
}



/*********************************************************/
/* test stub                                             */
/*********************************************************/


#ifdef TEST

#include <stdio.h>

typedef struct
{
  int key;
  int value;
}
key_value_t;

static int
cacheTest (void *map, void *key)
{
  return (((key_value_t *) map)->key == *(int *) key);
}

static void *
cacheFetch (char **error, void *key)
{
  key_value_t *map;

  map = (key_value_t *) gdMalloc (sizeof (key_value_t));
  map->key = *(int *) key;
  map->value = 3;

  *error = NULL;
  return (void *) map;
}

static void
cacheRelease (void *map)
{
  gdFree ((char *) map);
}

int
main (char *argv[], int argc)
{
  gdCache_head_t *cacheTable;
  int elem, key;

  cacheTable = gdCacheCreate (3, cacheTest, cacheFetch, cacheRelease);
	if (!cacheTable) {
		exit(1);
	}

  key = 20;
  elem = *(int *) gdCacheGet (cacheTable, &key);
  key = 30;
  elem = *(int *) gdCacheGet (cacheTable, &key);
  key = 40;
  elem = *(int *) gdCacheGet (cacheTable, &key);
  key = 50;
  elem = *(int *) gdCacheGet (cacheTable, &key);
  key = 30;
  elem = *(int *) gdCacheGet (cacheTable, &key);
  key = 30;
  elem = *(int *) gdCacheGet (cacheTable, &key);

  gdCacheDelete (cacheTable);

  return 0;
}

#endif /* TEST */
#endif /* HAVE_LIBTTF */
1903        320078      312592      1193070199  200         0           100640      10  gdcmpgif.c`
#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include <stdio.h>
#include <stdlib.h>
#ifndef WIN32
#include <unistd.h> /* For unlink function */
#endif

#include "gd.h"

/* A short program which converts a .png file into a .gd file, for
	your convenience in creating images on the fly from a
	basis image that must be loaded quickly. The .gd format
	is not intended to be a general-purpose format. */

void CompareImages(char *msg, gdImagePtr im1, gdImagePtr im2);


int main(int argc, char **argv)
{
	gdImagePtr im1, im2;
	FILE *in;

	if (argc != 3) {
		fprintf(stderr, "Usage: gdcmpgif filename.gif filename.gif\n");
		exit(1);
	}
	in = fopen(argv[1], "rb");
	if (!in) {
		fprintf(stderr, "Input file does not exist!\n");
		exit(1);
	}
	im1 = gdImageCreateFromGif(in);
	fclose(in);

	if (!im1) {
		fprintf(stderr, "Input is not in GIF format!\n");
		exit(1);
	}

	in = fopen(argv[2], "rb");
	if (!in) {
		fprintf(stderr, "Input file 2 does not exist!\n");
		exit(1);
	}
	im2 = gdImageCreateFromGif(in);
	fclose(in);

	if (!im2) {
		fprintf(stderr, "Input 2 is not in GIF format!\n");
		exit(1);
	}

	CompareImages("gdcmpgif", im1, im2);

	gdImageDestroy(im1);
        gdImageDestroy(im2);

	return 0;
}

void CompareImages(char *msg, gdImagePtr im1, gdImagePtr im2)
{
	int cmpRes;

	cmpRes = gdImageCompare(im1, im2);

	if (cmpRes & GD_CMP_IMAGE) {
		printf("%%%s: ERROR images differ: BAD\n",msg);
	} else if (cmpRes != 0) {
		printf("%%%s: WARNING images differ: WARNING - Probably OK\n",msg);
	} else {
		printf("%%%s: OK\n",msg);
		return;
	}

	if (cmpRes & (GD_CMP_SIZE_X + GD_CMP_SIZE_Y)) {
		printf("-%s: INFO image sizes differ\n",msg);
	}

	if (cmpRes & GD_CMP_NUM_COLORS) {
		printf("-%s: INFO number of pallette entries differ %d Vs. %d\n",msg,
			im1->colorsTotal, im2->colorsTotal);
	}

	if (cmpRes & GD_CMP_COLOR) {
		printf("-%s: INFO actual colours of pixels differ\n",msg);
	}
}


 5741        325918      318074      1193070199  200         0           100640      8   gddemo.c`

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include <stdio.h>
#include <math.h>
#include <stdlib.h>
#include "gd.h"
#include "gdfontt.h"
#include "gdfonts.h"
#include "gdfontmb.h"
#include "gdfontl.h"
#include "gdfontg.h"

int
main (void)
{
#ifdef HAVE_LIBPNG
  /* Input and output files */
  FILE *in;
  FILE *out;

  /* Input and output images */
  gdImagePtr im_in = 0, im_out = 0;

  /* Brush image */
  gdImagePtr brush;

  /* Color indexes */
  int white;
  int blue;
  int red;
  int green;

  /* Points for polygon */
  gdPoint points[3];
  int i;

  /* gd fonts for font test */
  gdFontPtr fonts[5];
  int y;

  /* Create output image, in true color. */
  im_out = gdImageCreateTrueColor (256 + 384, 384);
  /* 2.0.2: first color allocated would automatically be background in a 
     palette based image. Since this is a truecolor image, with an 
     automatic background of black, we must fill it explicitly. */
  white = gdImageColorAllocate (im_out, 255, 255, 255);
  gdImageFilledRectangle (im_out, 0, 0, gdImageSX (im_out),
			  gdImageSY (im_out), white);

  /* Set transparent color. */
  gdImageColorTransparent (im_out, white);

  /* Try to load demoin.png and paste part of it into the
     output image. */
  in = fopen ("demoin.png", "rb");
  if (!in)
    {
      fprintf (stderr, "Can't load source image; this demo\n");
      fprintf (stderr, "is much more impressive if demoin.png\n");
      fprintf (stderr, "is available.\n");
      im_in = 0;
    }
  else
    {
      int a;
      im_in = gdImageCreateFromPng (in);
      fclose (in);
      /* Now copy, and magnify as we do so */
      gdImageCopyResampled (im_out, im_in, 32, 32, 0, 0, 192, 192, 255, 255);
      /* Now display variously rotated space shuttles in a circle of our own */
      for (a = 0; (a < 360); a += 45)
	{
	  int cx = cos (a * .0174532925) * 128;
	  int cy = -sin (a * .0174532925) * 128;
	  gdImageCopyRotated (im_out, im_in,
			      256 + 192 + cx, 192 + cy,
			      0, 0, gdImageSX (im_in), gdImageSY (im_in), a);
	}
    }
  red = gdImageColorAllocate (im_out, 255, 0, 0);
  green = gdImageColorAllocate (im_out, 0, 255, 0);
  blue = gdImageColorAllocate (im_out, 0, 0, 255);
  /* Fat Rectangle */
  gdImageSetThickness (im_out, 4);
  gdImageLine (im_out, 16, 16, 240, 16, green);
  gdImageLine (im_out, 240, 16, 240, 240, green);
  gdImageLine (im_out, 240, 240, 16, 240, green);
  gdImageLine (im_out, 16, 240, 16, 16, green);
  gdImageSetThickness (im_out, 1);
  /* Circle */
  gdImageArc (im_out, 128, 128, 60, 20, 0, 720, blue);
  /* Arc */
  gdImageArc (im_out, 128, 128, 40, 40, 90, 270, blue);
  /* Flood fill: doesn't do much on a continuously
     variable tone jpeg original. */
  gdImageFill (im_out, 8, 8, blue);
  /* Polygon */
  points[0].x = 64;
  points[0].y = 0;
  points[1].x = 0;
  points[1].y = 128;
  points[2].x = 128;
  points[2].y = 128;
  gdImageFilledPolygon (im_out, points, 3, green);
  /* 2.0.12: Antialiased Polygon */
  gdImageSetAntiAliased (im_out, green);
  for (i = 0; (i < 3); i++)
    {
      points[i].x += 128;
    }
  gdImageFilledPolygon (im_out, points, 3, gdAntiAliased);
  /* Brush. A fairly wild example also involving a line style! */
  if (im_in)
    {
      int style[8];
      brush = gdImageCreateTrueColor (16, 16);
      gdImageCopyResized (brush, im_in,
			  0, 0, 0, 0,
			  gdImageSX (brush), gdImageSY (brush),
			  gdImageSX (im_in), gdImageSY (im_in));
      gdImageSetBrush (im_out, brush);
      /* With a style, so they won't overprint each other.
         Normally, they would, yielding a fat-brush effect. */
      style[0] = 0;
      style[1] = 0;
      style[2] = 0;
      style[3] = 0;
      style[4] = 0;
      style[5] = 0;
      style[6] = 0;
      style[7] = 1;
      gdImageSetStyle (im_out, style, 8);
      /* Draw the styled, brushed line */
      gdImageLine (im_out, 0, 255, 255, 0, gdStyledBrushed);
    }
  /* Text (non-truetype; see gdtestft for a freetype demo) */
  fonts[0] = gdFontGetTiny ();
  fonts[1] = gdFontGetSmall ();
  fonts[2] = gdFontGetMediumBold ();
  fonts[3] = gdFontGetLarge ();
  fonts[4] = gdFontGetGiant ();
  y = 0;
  for (i = 0; (i <= 4); i++)
    {
      gdImageString (im_out, fonts[i], 32, 32 + y, (unsigned char *) "hi",
		     red);
      y += fonts[i]->h;
    }
  y = 0;
  for (i = 0; (i <= 4); i++)
    {
      gdImageStringUp (im_out, fonts[i], 64 + y, 64,
		       (unsigned char *) "hi", red);
      y += fonts[i]->h;
    }
  /* Random antialiased lines; coordinates all over the image, 
     but the output will respect a small clipping rectangle */
  gdImageSetClip (im_out, 0, gdImageSY (im_out) - 100,
		  100, gdImageSY (im_out));
  /* Fixed seed for reproducibility of results */
  srand (100);
  for (i = 0; (i < 100); i++)
    {
      int x1 = rand () % gdImageSX (im_out);
      int y1 = rand () % gdImageSY (im_out);
      int x2 = rand () % gdImageSX (im_out);
      int y2 = rand () % gdImageSY (im_out);
      gdImageSetAntiAliased (im_out, white); 
      gdImageLine (im_out, x1, y1, x2, y2, gdAntiAliased); 
    }
  /* Make output image interlaced (progressive, in the case of JPEG) */
  gdImageInterlace (im_out, 1);
  out = fopen ("demoout.png", "wb");
  /* Write PNG */
  gdImagePng (im_out, out);
  fclose (out);
  out = fopen ("demoout.gif", "wb");
  /* Write GIF (2.0.28) */
  gdImageGif (im_out, out);
  fclose (out);
  /* 2.0.12: also write a paletteized png comparable to the gif */
  out = fopen ("demooutp.png", "wb");
  gdImageTrueColorToPalette (im_out, 0, 256);
  gdImagePng (im_out, out);
  fclose (out);
  gdImageDestroy (im_out);
  if (im_in)
    {
      gdImageDestroy (im_in);
    }
#else
  fprintf (stderr, "No PNG library support.\n");
#endif /* HAVE_LIBPNG */
  return 0;
}
 115983      442002      320078      1193070199  200         0           100640      9   gdfontg.c `


/*
   This is a header file for gd font, generated using
   bdftogd version 0.51 by Jan Pazdziora, adelton@fi.muni.cz
   from bdf font
   -Misc-Fixed-Bold-R-Normal-Sans-15-140-75-75-C-90-ISO8859-2
   at Mon Jan 26 14:45:58 1998.
   The original bdf was holding following copyright:
   "Libor Skarvada, libor@informatics.muni.cz"
 */


#include "gdfontg.h"

char gdFontGiantData[] = {
/* Char 0 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 1 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 1, 1, 1, 1, 0, 0, 0,
  0, 1, 1, 1, 1, 1, 1, 0, 0,
  1, 1, 1, 1, 1, 1, 1, 1, 0,
  0, 1, 1, 1, 1, 1, 1, 0, 0,
  0, 0, 1, 1, 1, 1, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 2 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  1, 0, 1, 0, 1, 0, 1, 0, 0,
  0, 1, 0, 1, 0, 1, 0, 1, 0,
  1, 0, 1, 0, 1, 0, 1, 0, 0,
  0, 1, 0, 1, 0, 1, 0, 1, 0,
  1, 0, 1, 0, 1, 0, 1, 0, 0,
  0, 1, 0, 1, 0, 1, 0, 1, 0,
  1, 0, 1, 0, 1, 0, 1, 0, 0,
  0, 1, 0, 1, 0, 1, 0, 1, 0,
  1, 0, 1, 0, 1, 0, 1, 0, 0,
  0, 1, 0, 1, 0, 1, 0, 1, 0,
  1, 0, 1, 0, 1, 0, 1, 0, 0,
  0, 1, 0, 1, 0, 1, 0, 1, 0,
  1, 0, 1, 0, 1, 0, 1, 0, 0,
  0, 1, 0, 1, 0, 1, 0, 1, 0,

/* Char 3 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 1, 1, 0, 0, 0,
  1, 1, 0, 0, 1, 1, 0, 0, 0,
  1, 1, 1, 1, 1, 1, 0, 0, 0,
  1, 1, 0, 0, 1, 1, 0, 0, 0,
  1, 1, 0, 0, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 1, 1, 1, 1, 0,
  0, 0, 0, 0, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 4 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 1, 1, 1, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 5 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 1, 0, 0, 0,
  1, 1, 0, 0, 0, 1, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 1, 0, 0, 0,
  0, 1, 1, 1, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 1, 1, 1, 0, 0,
  0, 0, 1, 1, 0, 0, 1, 1, 0,
  0, 0, 1, 1, 1, 1, 1, 0, 0,
  0, 0, 1, 1, 0, 0, 1, 1, 0,
  0, 0, 1, 1, 0, 0, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 6 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 1, 1, 1, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 7 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 1, 1, 0, 0, 0,
  0, 1, 1, 0, 0, 1, 1, 0, 0,
  0, 1, 1, 0, 0, 1, 1, 0, 0,
  0, 0, 1, 1, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 8 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 1, 1, 1, 0,
  1, 1, 1, 1, 1, 1, 1, 1, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 1, 1, 1, 0,
  1, 1, 1, 1, 1, 1, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 9 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 1, 1, 0, 0, 0,
  1, 1, 1, 0, 1, 1, 0, 0, 0,
  1, 1, 1, 1, 1, 1, 0, 0, 0,
  1, 1, 0, 1, 1, 1, 0, 0, 0,
  1, 1, 0, 0, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 1, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 10 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 1, 1, 0, 0, 0,
  1, 1, 0, 0, 1, 1, 0, 0, 0,
  1, 1, 0, 0, 1, 1, 0, 0, 0,
  0, 1, 1, 1, 1, 0, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 1, 1, 1, 1, 0,
  0, 0, 0, 0, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 11 */
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 12 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,

/* Char 13 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 1, 1, 1, 1,
  0, 0, 0, 1, 1, 1, 1, 1, 1,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,

/* Char 14 */
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 1, 1, 1, 1,
  0, 0, 0, 1, 1, 1, 1, 1, 1,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 15 */
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,

/* Char 16 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 17 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 18 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 19 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 20 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 21 */
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 1, 1, 1, 1,
  0, 0, 0, 1, 1, 1, 1, 1, 1,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,

/* Char 22 */
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,

/* Char 23 */
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 24 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,

/* Char 25 */
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,

/* Char 26 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 1, 1, 1, 0,
  0, 0, 0, 1, 1, 1, 0, 0, 0,
  0, 1, 1, 1, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 0, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 1, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 1, 1, 1, 0,
  1, 1, 1, 1, 1, 1, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 27 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 1, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 0, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 1, 1, 0,
  0, 0, 0, 0, 1, 1, 1, 0, 0,
  0, 0, 1, 1, 1, 0, 0, 0, 0,
  1, 1, 1, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 1, 1, 1, 0,
  1, 1, 1, 1, 1, 1, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 28 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 1, 1, 1, 0,
  1, 1, 1, 1, 1, 1, 1, 1, 0,
  0, 0, 1, 0, 0, 1, 1, 0, 0,
  0, 0, 1, 0, 0, 1, 1, 0, 0,
  0, 0, 1, 0, 0, 1, 1, 0, 0,
  0, 1, 1, 0, 0, 1, 1, 0, 0,
  1, 1, 1, 0, 0, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 29 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 1, 1, 0,
  0, 0, 0, 0, 0, 1, 1, 0, 0,
  1, 1, 1, 1, 1, 1, 1, 1, 0,
  1, 1, 1, 1, 1, 1, 1, 1, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 1, 1, 1, 0,
  1, 1, 1, 1, 1, 1, 1, 1, 0,
  0, 1, 1, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 30 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 1, 1, 0, 0,
  0, 0, 1, 1, 0, 0, 1, 1, 0,
  0, 0, 1, 1, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 1, 1, 0, 0,
  0, 0, 1, 1, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 0, 0, 0, 0,
  1, 0, 1, 1, 1, 1, 1, 1, 0,
  1, 1, 1, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 31 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 32 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 33 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 34 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 0, 1, 1, 0, 0,
  0, 0, 1, 1, 0, 1, 1, 0, 0,
  0, 0, 1, 1, 0, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 35 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 0, 1, 1, 0, 0, 0,
  0, 1, 1, 0, 1, 1, 0, 0, 0,
  1, 1, 1, 1, 1, 1, 1, 0, 0,
  0, 1, 1, 0, 1, 1, 0, 0, 0,
  0, 1, 1, 0, 1, 1, 0, 0, 0,
  1, 1, 1, 1, 1, 1, 1, 0, 0,
  0, 1, 1, 0, 1, 1, 0, 0, 0,
  0, 1, 1, 0, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 36 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 1, 1, 1, 1, 1, 0, 0,
  0, 1, 1, 0, 1, 0, 1, 1, 0,
  0, 1, 1, 0, 1, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 0, 0, 0, 0,
  0, 0, 1, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 1, 1, 1, 1, 0,
  0, 0, 0, 0, 1, 0, 1, 1, 0,
  0, 1, 1, 0, 1, 0, 1, 1, 0,
  0, 0, 1, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 37 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 1, 0, 0, 1, 1, 0, 0,
  1, 1, 1, 0, 0, 1, 1, 0, 0,
  0, 1, 0, 0, 1, 1, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 1, 0, 0,
  0, 1, 1, 0, 0, 1, 1, 1, 0,
  0, 1, 1, 0, 0, 1, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 38 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 1, 0, 0, 0, 0,
  0, 1, 1, 0, 1, 1, 0, 0, 0,
  0, 1, 1, 0, 1, 1, 0, 0, 0,
  0, 1, 1, 1, 1, 0, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 0, 0, 1, 0,
  1, 1, 0, 0, 1, 1, 1, 1, 0,
  1, 1, 0, 0, 0, 1, 1, 0, 0,
  1, 1, 0, 0, 1, 1, 1, 0, 0,
  0, 1, 1, 1, 1, 0, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 39 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 1, 0, 0, 0,
  0, 0, 0, 1, 1, 1, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 40 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 1, 1, 0, 0,
  0, 0, 0, 0, 1, 1, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 0, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 41 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 0, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 1, 1, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0, 0, 0,
  0, 1, 1, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 42 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 0, 1, 1, 0, 0, 0,
  0, 0, 1, 1, 1, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 1, 1, 0, 0,
  0, 0, 1, 1, 1, 0, 0, 0, 0,
  0, 1, 1, 0, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 43 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 1, 1, 1, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 44 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 1, 1, 0, 0, 0,
  0, 0, 1, 1, 1, 0, 0, 0, 0,
  0, 1, 1, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 45 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 1, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 46 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 1, 1, 1, 1, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 47 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 1, 1, 0,
  0, 0, 0, 0, 0, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 1, 1, 0, 0,
  0, 0, 0, 0, 1, 1, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0, 0, 0,
  0, 1, 1, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 48 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 1, 1, 1, 1, 0, 0, 0,
  0, 1, 1, 0, 0, 1, 1, 0, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  0, 1, 1, 0, 0, 1, 1, 0, 0,
  0, 0, 1, 1, 1, 1, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 49 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 1, 1, 1, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 50 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 1, 1, 0, 0, 0,
  0, 1, 1, 0, 0, 1, 1, 0, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 1, 1, 0,
  0, 0, 0, 0, 0, 1, 1, 0, 0,
  0, 0, 0, 0, 1, 1, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0, 0, 0,
  0, 1, 1, 0, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 1, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 51 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 1, 0, 0, 0,
  1, 1, 0, 0, 0, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 1, 1, 0,
  0, 0, 0, 0, 0, 1, 1, 0, 0,
  0, 0, 0, 1, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 1, 1, 0, 0,
  0, 1, 1, 1, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 52 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 1, 1, 0, 0,
  0, 0, 0, 0, 1, 1, 1, 0, 0,
  0, 0, 0, 1, 1, 1, 1, 0, 0,
  0, 0, 1, 1, 0, 1, 1, 0, 0,
  0, 1, 1, 0, 0, 1, 1, 0, 0,
  1, 1, 0, 0, 0, 1, 1, 0, 0,
  1, 1, 1, 1, 1, 1, 1, 1, 0,
  0, 0, 0, 0, 0, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 53 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 1, 1, 0, 0,
  1, 1, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 1, 1, 1, 0, 0, 0,
  1, 1, 1, 0, 0, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  0, 1, 1, 0, 0, 1, 1, 0, 0,
  0, 0, 1, 1, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 54 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 1, 1, 0, 0, 0,
  0, 1, 1, 0, 0, 1, 1, 0, 0,
  1, 1, 0, 0, 0, 0, 1, 0, 0,
  1, 1, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 1, 1, 1, 0, 0, 0,
  1, 1, 1, 0, 0, 1, 1, 0, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  0, 1, 1, 0, 0, 1, 1, 0, 0,
  0, 0, 1, 1, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 55 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 1, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 1, 1, 0,
  0, 0, 0, 0, 0, 1, 1, 0, 0,
  0, 0, 0, 0, 1, 1, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0, 0, 0,
  0, 1, 1, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 56 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 1, 1, 0, 0, 0,
  0, 1, 1, 0, 0, 1, 1, 0, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  0, 1, 1, 0, 0, 1, 1, 0, 0,
  0, 0, 1, 1, 1, 1, 0, 0, 0,
  0, 1, 1, 0, 0, 1, 1, 0, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  0, 1, 1, 0, 0, 1, 1, 0, 0,
  0, 0, 1, 1, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 57 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 1, 1, 0, 0, 0,
  0, 1, 1, 0, 0, 1, 1, 0, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  0, 1, 1, 0, 0, 1, 1, 1, 0,
  0, 0, 1, 1, 1, 0, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 1, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 1, 0,
  0, 1, 1, 0, 0, 1, 1, 0, 0,
  0, 0, 1, 1, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 58 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 1, 1, 1, 1, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 1, 1, 1, 1, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 59 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 1, 1, 1, 1, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 1, 1, 0, 0, 0,
  0, 0, 1, 1, 1, 0, 0, 0, 0,
  0, 1, 1, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 60 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 1, 1, 0, 0,
  0, 0, 0, 0, 1, 1, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0, 0, 0,
  0, 1, 1, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 0, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 61 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 1, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 1, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 62 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 0, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 1, 1, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0, 0, 0,
  0, 1, 1, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 63 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 1, 1, 1, 0, 0,
  0, 1, 1, 0, 0, 0, 1, 1, 0,
  0, 1, 1, 0, 0, 0, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 1, 1, 0,
  0, 0, 0, 0, 0, 1, 1, 0, 0,
  0, 0, 0, 0, 1, 1, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 64 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 1, 1, 0, 0, 0,
  0, 1, 1, 0, 0, 1, 1, 0, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 1, 1, 0,
  1, 1, 0, 1, 1, 0, 1, 1, 0,
  1, 1, 0, 1, 1, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 1, 0, 0,
  1, 1, 0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 0, 0, 0, 1, 1, 0,
  0, 0, 1, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 65 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 1, 1, 1, 1, 0, 0, 0,
  0, 1, 1, 0, 0, 1, 1, 0, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 1, 1, 1, 1, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 66 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 1, 0, 0, 0,
  1, 1, 0, 0, 0, 1, 1, 0, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 1, 1, 0, 0,
  1, 1, 1, 1, 1, 1, 0, 0, 0,
  1, 1, 0, 0, 0, 1, 1, 0, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 1, 1, 0, 0,
  1, 1, 1, 1, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 67 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 1, 1, 1, 0, 0,
  0, 1, 1, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 0, 1, 0,
  1, 1, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0, 1, 0,
  0, 1, 1, 0, 0, 0, 1, 1, 0,
  0, 0, 1, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 68 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 1, 0, 0, 0,
  1, 1, 0, 0, 0, 1, 1, 0, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 1, 1, 0, 0,
  1, 1, 1, 1, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 69 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 1, 1, 0, 0,
  1, 1, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 1, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 70 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 1, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 1, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 71 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 1, 1, 1, 0, 0,
  0, 1, 1, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 1, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  0, 1, 1, 0, 0, 0, 1, 1, 0,
  0, 0, 1, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 72 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 1, 1, 1, 1, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 73 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 74 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 1, 1, 0, 0,
  0, 1, 0, 0, 0, 1, 1, 0, 0,
  0, 1, 1, 0, 1, 1, 0, 0, 0,
  0, 0, 1, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 75 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 1, 1, 0, 0,
  1, 1, 0, 0, 1, 1, 0, 0, 0,
  1, 1, 0, 1, 1, 0, 0, 0, 0,
  1, 1, 1, 1, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 0, 0, 0, 0, 0,
  1, 1, 0, 1, 1, 0, 0, 0, 0,
  1, 1, 0, 0, 1, 1, 0, 0, 0,
  1, 1, 0, 0, 0, 1, 1, 0, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 76 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 77 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 1, 0, 0, 1, 1, 1, 0,
  1, 1, 1, 1, 1, 1, 1, 1, 0,
  1, 1, 0, 1, 1, 0, 1, 1, 0,
  1, 1, 0, 1, 1, 0, 1, 1, 0,
  1, 1, 0, 1, 1, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 78 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 1, 0, 0, 0, 1, 1, 0,
  1, 1, 1, 1, 0, 0, 1, 1, 0,
  1, 1, 1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 1, 1, 0, 1, 1, 0,
  1, 1, 0, 1, 1, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 1, 1, 0,
  1, 1, 0, 0, 0, 1, 1, 1, 0,
  1, 1, 0, 0, 0, 1, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 79 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 1, 1, 0, 0, 0,
  0, 1, 1, 0, 0, 1, 1, 0, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  0, 1, 1, 0, 0, 1, 1, 0, 0,
  0, 0, 1, 1, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 80 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 1, 1, 0, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 1, 1, 1, 1, 1, 0, 0,
  1, 1, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 81 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 1, 1, 0, 0, 0,
  0, 1, 1, 0, 0, 1, 1, 0, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 1, 1, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 1, 1, 0,
  0, 1, 1, 0, 0, 1, 1, 0, 0,
  0, 0, 1, 1, 1, 1, 0, 1, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 82 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 1, 1, 0, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 1, 1, 1, 1, 1, 0, 0,
  1, 1, 1, 1, 1, 0, 0, 0, 0,
  1, 1, 0, 0, 1, 1, 0, 0, 0,
  1, 1, 0, 0, 0, 1, 1, 0, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 83 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 1, 1, 0, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  0, 1, 1, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 84 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 1, 1, 1, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 85 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  0, 1, 1, 0, 0, 1, 1, 0, 0,
  0, 0, 1, 1, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 86 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  0, 1, 1, 0, 0, 1, 1, 0, 0,
  0, 1, 1, 0, 0, 1, 1, 0, 0,
  0, 1, 1, 0, 0, 1, 1, 0, 0,
  0, 0, 1, 1, 1, 1, 0, 0, 0,
  0, 0, 1, 1, 1, 1, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 87 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 1, 1, 0, 1, 1, 0,
  1, 1, 0, 1, 1, 0, 1, 1, 0,
  1, 1, 0, 1, 1, 0, 1, 1, 0,
  1, 1, 1, 1, 1, 1, 1, 1, 0,
  1, 1, 1, 0, 0, 1, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 88 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  0, 1, 1, 0, 0, 1, 1, 0, 0,
  0, 0, 1, 1, 1, 1, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 1, 1, 1, 1, 0, 0, 0,
  0, 1, 1, 0, 0, 1, 1, 0, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 89 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  0, 1, 1, 0, 0, 1, 1, 0, 0,
  0, 0, 1, 1, 1, 1, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 90 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 1, 1, 0, 0,
  0, 0, 0, 0, 1, 1, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0, 0, 0,
  0, 1, 1, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 91 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 1, 1, 1, 0, 0,
  0, 0, 1, 1, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 92 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 0, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 93 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 1, 1, 0, 0, 0,
  0, 1, 1, 1, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 94 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 1, 1, 1, 1, 0, 0, 0,
  0, 1, 1, 0, 0, 1, 1, 0, 0,
  0, 1, 0, 0, 0, 0, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 95 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 1, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 96 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 1, 0, 0, 0, 0,
  0, 0, 1, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 0, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 97 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 1, 1, 1, 0, 0,
  0, 1, 1, 0, 0, 0, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 1, 1, 0,
  0, 1, 1, 1, 1, 1, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 1, 1, 1, 0,
  0, 1, 1, 1, 1, 0, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 98 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 1, 1, 1, 0, 0, 0,
  1, 1, 1, 0, 0, 1, 1, 0, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 1, 0, 0, 1, 1, 0, 0,
  1, 1, 0, 1, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 99 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 1, 1, 1, 0, 0,
  0, 1, 1, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 0, 0, 0, 1, 1, 0,
  0, 0, 1, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 100 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 1, 1, 0,
  0, 0, 1, 1, 1, 0, 1, 1, 0,
  0, 1, 1, 0, 0, 1, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  0, 1, 1, 0, 0, 1, 1, 1, 0,
  0, 0, 1, 1, 1, 0, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 101 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 1, 1, 0, 0, 0,
  0, 1, 1, 0, 0, 1, 1, 0, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 1, 1, 1, 1, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 0, 0, 0, 1, 1, 0,
  0, 0, 1, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 102 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 1, 1, 0, 0,
  0, 0, 1, 1, 0, 0, 1, 1, 0,
  0, 0, 1, 1, 0, 0, 1, 1, 0,
  0, 0, 1, 1, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 1, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 103 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 1, 0, 1, 0,
  1, 1, 0, 0, 0, 1, 1, 1, 0,
  1, 1, 0, 0, 0, 1, 1, 0, 0,
  1, 1, 0, 0, 0, 1, 1, 0, 0,
  0, 1, 1, 1, 1, 1, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 1, 1, 0, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  0, 1, 1, 1, 1, 1, 1, 0, 0,

/* Char 104 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 1, 1, 1, 0, 0, 0,
  1, 1, 1, 0, 0, 1, 1, 0, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 105 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 106 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 1, 1, 0, 0,
  1, 1, 0, 0, 0, 1, 1, 0, 0,
  1, 1, 0, 0, 0, 1, 1, 0, 0,
  0, 1, 1, 1, 1, 1, 0, 0, 0,

/* Char 107 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 0, 0, 1, 1, 0, 0,
  0, 1, 1, 0, 1, 1, 0, 0, 0,
  0, 1, 1, 1, 1, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 0, 0, 0, 0,
  0, 1, 1, 0, 1, 1, 0, 0, 0,
  0, 1, 1, 0, 0, 1, 1, 0, 0,
  0, 1, 1, 0, 0, 0, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 108 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 1, 1, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 109 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  1, 0, 1, 1, 0, 1, 1, 0, 0,
  1, 1, 0, 1, 1, 0, 1, 1, 0,
  1, 1, 0, 1, 1, 0, 1, 1, 0,
  1, 1, 0, 1, 1, 0, 1, 1, 0,
  1, 1, 0, 1, 1, 0, 1, 1, 0,
  1, 1, 0, 1, 1, 0, 1, 1, 0,
  1, 1, 0, 1, 1, 0, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 110 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 1, 1, 1, 0, 0, 0,
  1, 1, 1, 0, 0, 1, 1, 0, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 111 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 1, 1, 0, 0, 0,
  0, 1, 1, 0, 0, 1, 1, 0, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  0, 1, 1, 0, 0, 1, 1, 0, 0,
  0, 0, 1, 1, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 112 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 1, 1, 1, 0, 0, 0,
  1, 1, 1, 0, 0, 1, 1, 0, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 1, 0, 0, 1, 1, 0, 0,
  1, 1, 0, 1, 1, 1, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0, 0, 0,

/* Char 113 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 1, 0, 1, 1, 0,
  0, 1, 1, 0, 0, 1, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  0, 1, 1, 0, 0, 1, 1, 1, 0,
  0, 0, 1, 1, 1, 0, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 1, 1, 0,

/* Char 114 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 1, 1, 1, 1, 0, 0,
  0, 1, 1, 1, 0, 0, 1, 1, 0,
  0, 1, 1, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 115 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 1, 1, 0, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  0, 1, 1, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 116 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 1, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 1, 1, 0,
  0, 0, 0, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 117 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  0, 1, 1, 0, 0, 1, 1, 1, 0,
  0, 0, 1, 1, 1, 0, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 118 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  0, 1, 1, 0, 0, 1, 1, 0, 0,
  0, 1, 1, 0, 0, 1, 1, 0, 0,
  0, 0, 1, 1, 1, 1, 0, 0, 0,
  0, 0, 1, 1, 1, 1, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 119 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 1, 1, 0, 1, 1, 0,
  1, 1, 0, 1, 1, 0, 1, 1, 0,
  1, 1, 0, 1, 1, 0, 1, 1, 0,
  1, 1, 1, 1, 1, 1, 1, 1, 0,
  0, 1, 1, 0, 0, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 120 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  0, 1, 1, 0, 0, 1, 1, 0, 0,
  0, 0, 1, 1, 1, 1, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 1, 1, 1, 1, 0, 0, 0,
  0, 1, 1, 0, 0, 1, 1, 0, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 121 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  0, 1, 1, 0, 0, 1, 1, 1, 0,
  0, 0, 1, 1, 1, 0, 1, 1, 0,
  1, 0, 0, 0, 0, 0, 1, 1, 0,
  0, 1, 1, 1, 1, 1, 1, 0, 0,

/* Char 122 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 1, 1, 0, 0,
  0, 0, 0, 0, 1, 1, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0, 0, 0,
  0, 1, 1, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 123 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 1, 1, 1, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 0, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 124 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 125 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 0, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 0, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 1, 1, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 1, 1, 1, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 126 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 1, 1, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 127 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 128 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 129 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 130 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 131 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 132 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 133 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 134 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 135 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 136 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 137 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 138 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 139 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 140 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 141 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 142 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 143 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 144 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 145 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 146 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 147 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 148 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 149 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 150 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 151 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 152 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 153 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 154 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 155 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 156 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 157 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 158 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 159 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 160 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 161 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 1, 1, 1, 1, 0, 0, 0,
  0, 1, 1, 0, 0, 1, 1, 0, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 1, 1, 1, 1, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  0, 0, 0, 0, 0, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 1, 1, 0,

/* Char 162 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  0, 1, 1, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 163 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 0, 0, 1, 0, 0, 0,
  0, 1, 1, 0, 1, 1, 0, 0, 0,
  0, 1, 1, 1, 1, 0, 0, 0, 0,
  0, 1, 1, 1, 0, 0, 0, 0, 0,
  1, 1, 1, 0, 0, 0, 0, 0, 0,
  1, 1, 1, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 164 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 0, 0, 0, 1, 1, 0,
  0, 1, 1, 1, 1, 1, 1, 1, 0,
  0, 0, 1, 1, 0, 1, 1, 0, 0,
  0, 0, 1, 0, 0, 0, 1, 0, 0,
  0, 0, 1, 1, 0, 1, 1, 0, 0,
  0, 1, 1, 1, 1, 1, 1, 1, 0,
  0, 1, 1, 0, 0, 0, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 165 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 1, 1, 0, 0, 0,
  1, 1, 0, 0, 1, 1, 0, 0, 0,
  1, 1, 0, 1, 1, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 166 */
  0, 0, 0, 0, 1, 1, 1, 0, 0,
  0, 0, 1, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 1, 1, 0, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  0, 1, 1, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 167 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 1, 1, 0, 0, 0,
  0, 1, 1, 0, 0, 1, 1, 0, 0,
  0, 1, 1, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 1, 1, 0, 0, 0,
  0, 1, 1, 0, 0, 1, 1, 0, 0,
  0, 1, 1, 0, 0, 1, 1, 0, 0,
  0, 1, 1, 0, 0, 1, 1, 0, 0,
  0, 0, 1, 1, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 1, 1, 0, 0,
  0, 1, 1, 0, 0, 1, 1, 0, 0,
  0, 0, 1, 1, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 168 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 0, 0, 1, 1, 0, 0,
  0, 1, 1, 0, 0, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 169 */
  0, 1, 1, 0, 0, 1, 1, 0, 0,
  0, 0, 1, 1, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 1, 1, 0, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  0, 1, 1, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 170 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 1, 1, 0, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  0, 1, 1, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 1, 1, 1, 0, 0, 0, 0, 0,

/* Char 171 */
  0, 1, 1, 0, 0, 1, 1, 0, 0,
  0, 0, 1, 1, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 1, 1, 1, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 172 */
  0, 0, 0, 0, 1, 1, 1, 0, 0,
  0, 0, 1, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 1, 1, 0, 0,
  0, 0, 0, 0, 1, 1, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0, 0, 0,
  0, 1, 1, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 173 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 1, 1, 0, 0,
  0, 1, 1, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 174 */
  0, 1, 1, 0, 1, 1, 0, 0, 0,
  0, 0, 1, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 1, 1, 0, 0,
  0, 0, 0, 0, 1, 1, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0, 0, 0,
  0, 1, 1, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 175 */
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 1, 1, 0, 0,
  0, 0, 0, 0, 1, 1, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0, 0, 0,
  0, 1, 1, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 176 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 1, 1, 0, 0, 0,
  0, 1, 1, 0, 0, 1, 1, 0, 0,
  0, 1, 1, 0, 0, 1, 1, 0, 0,
  0, 0, 1, 1, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 177 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 1, 1, 1, 0, 0,
  0, 1, 1, 0, 0, 0, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 1, 1, 0,
  0, 1, 1, 1, 1, 1, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 1, 1, 1, 0,
  0, 1, 1, 1, 1, 0, 1, 1, 0,
  0, 0, 0, 0, 0, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 1, 1, 1,

/* Char 178 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 1, 1, 0,
  0, 0, 0, 0, 1, 1, 1, 0, 0,

/* Char 179 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 1, 0, 0,
  0, 0, 0, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 1, 1, 1, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 1, 1, 1, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 0, 0, 0, 0,
  0, 1, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 180 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 1, 1, 0, 0,
  0, 0, 0, 0, 1, 1, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 181 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 1, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 1, 1, 0,
  0, 1, 1, 1, 0, 0, 1, 1, 0,
  0, 0, 1, 1, 0, 1, 1, 0, 0,
  0, 0, 1, 1, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 182 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 1, 1, 0, 0,
  0, 0, 0, 0, 1, 1, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 1, 1, 0, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  0, 1, 1, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 183 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 0, 0, 1, 1, 0, 0,
  0, 0, 1, 1, 1, 1, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 184 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 1, 1, 0, 0, 0,
  0, 1, 1, 0, 1, 1, 0, 0, 0,
  0, 0, 1, 1, 1, 0, 0, 0, 0,

/* Char 185 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 0, 0, 1, 1, 0, 0,
  0, 0, 1, 1, 1, 1, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 1, 1, 0, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  0, 1, 1, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 186 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 1, 1, 0, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  0, 1, 1, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 1, 1, 1, 0, 0, 0, 0, 0,

/* Char 187 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 1, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 1, 1, 0,
  0, 0, 1, 1, 0, 0, 1, 1, 0,
  0, 0, 1, 1, 0, 1, 1, 0, 0,
  1, 1, 1, 1, 1, 0, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 1, 1, 0,
  0, 0, 0, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 188 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 1, 1, 0, 0,
  0, 0, 0, 0, 1, 1, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 1, 1, 0, 0,
  0, 0, 0, 0, 1, 1, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0, 0, 0,
  0, 1, 1, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 189 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 1, 1, 0,
  0, 1, 1, 0, 0, 1, 1, 0, 0,
  1, 1, 0, 0, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 190 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 0, 0, 1, 1, 0, 0,
  0, 0, 1, 1, 1, 1, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 1, 1, 0, 0,
  0, 0, 0, 0, 1, 1, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0, 0, 0,
  0, 1, 1, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 191 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 1, 1, 0, 0,
  0, 0, 0, 0, 1, 1, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0, 0, 0,
  0, 1, 1, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 192 */
  0, 0, 0, 0, 1, 1, 1, 0, 0,
  0, 0, 1, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 1, 1, 0, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 1, 1, 1, 1, 1, 0, 0,
  1, 1, 1, 1, 1, 0, 0, 0, 0,
  1, 1, 0, 0, 1, 1, 0, 0, 0,
  1, 1, 0, 0, 0, 1, 1, 0, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 193 */
  0, 0, 0, 0, 1, 1, 1, 0, 0,
  0, 0, 1, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 1, 1, 1, 1, 0, 0, 0,
  0, 1, 1, 0, 0, 1, 1, 0, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 1, 1, 1, 1, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 194 */
  0, 0, 1, 1, 1, 1, 0, 0, 0,
  0, 1, 1, 0, 0, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 1, 1, 1, 1, 0, 0, 0,
  0, 1, 1, 0, 0, 1, 1, 0, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 1, 1, 1, 1, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 195 */
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  0, 1, 1, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 1, 1, 1, 1, 0, 0, 0,
  0, 1, 1, 0, 0, 1, 1, 0, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 1, 1, 1, 1, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 196 */
  0, 1, 1, 0, 0, 1, 1, 0, 0,
  0, 1, 1, 0, 0, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 1, 1, 1, 1, 0, 0, 0,
  0, 1, 1, 0, 0, 1, 1, 0, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 1, 1, 1, 1, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 197 */
  0, 0, 0, 1, 1, 1, 0, 0, 0,
  0, 1, 1, 1, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 198 */
  0, 0, 0, 0, 0, 1, 1, 1, 0,
  0, 0, 0, 1, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 1, 1, 1, 0, 0,
  0, 1, 1, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 0, 1, 0,
  1, 1, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0, 1, 0,
  0, 1, 1, 0, 0, 0, 1, 1, 0,
  0, 0, 1, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 199 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 1, 1, 1, 0, 0,
  0, 1, 1, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 0, 1, 0,
  1, 1, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0, 1, 0,
  0, 1, 1, 0, 0, 0, 1, 1, 0,
  0, 0, 1, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 1, 1, 0, 0, 0,
  0, 0, 1, 1, 1, 0, 0, 0, 0,

/* Char 200 */
  0, 0, 1, 1, 0, 1, 1, 0, 0,
  0, 0, 0, 1, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 1, 1, 1, 0, 0,
  0, 1, 1, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 0, 1, 0,
  1, 1, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0, 1, 0,
  0, 1, 1, 0, 0, 0, 1, 1, 0,
  0, 0, 1, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 201 */
  0, 0, 0, 0, 0, 1, 1, 1, 0,
  0, 0, 0, 1, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 1, 1, 0, 0,
  1, 1, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 1, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 202 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 1, 1, 0, 0,
  1, 1, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 1, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 1, 1, 1, 0,

/* Char 203 */
  0, 1, 1, 0, 0, 1, 1, 0, 0,
  0, 1, 1, 0, 0, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 1, 1, 0, 0,
  1, 1, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 1, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 204 */
  0, 1, 1, 0, 0, 1, 1, 0, 0,
  0, 0, 1, 1, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 1, 1, 0, 0,
  1, 1, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 1, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 205 */
  0, 0, 0, 0, 1, 1, 1, 0, 0,
  0, 0, 1, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 206 */
  0, 0, 1, 1, 1, 1, 0, 0, 0,
  0, 1, 1, 0, 0, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 207 */
  0, 1, 1, 0, 1, 1, 0, 0, 0,
  0, 0, 1, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 1, 0, 0, 0,
  1, 1, 0, 0, 0, 1, 1, 0, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 1, 1, 0, 0,
  1, 1, 1, 1, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 208 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 1, 0, 0, 0,
  0, 1, 1, 0, 0, 1, 1, 0, 0,
  0, 1, 1, 0, 0, 0, 1, 1, 0,
  0, 1, 1, 0, 0, 0, 1, 1, 0,
  1, 1, 1, 1, 0, 0, 1, 1, 0,
  1, 1, 1, 1, 0, 0, 1, 1, 0,
  0, 1, 1, 0, 0, 0, 1, 1, 0,
  0, 1, 1, 0, 0, 0, 1, 1, 0,
  0, 1, 1, 0, 0, 1, 1, 0, 0,
  1, 1, 1, 1, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 209 */
  0, 0, 0, 0, 1, 1, 1, 0, 0,
  0, 0, 1, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 1, 0, 0, 0, 1, 1, 0,
  1, 1, 1, 1, 0, 0, 1, 1, 0,
  1, 1, 1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 1, 1, 0, 1, 1, 0,
  1, 1, 0, 1, 1, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 1, 1, 0,
  1, 1, 0, 0, 0, 1, 1, 1, 0,
  1, 1, 0, 0, 0, 1, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 210 */
  0, 1, 1, 0, 0, 1, 1, 0, 0,
  0, 0, 1, 1, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 1, 0, 0, 0, 1, 1, 0,
  1, 1, 1, 1, 0, 0, 1, 1, 0,
  1, 1, 1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 1, 1, 0, 1, 1, 0,
  1, 1, 0, 1, 1, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 1, 1, 0,
  1, 1, 0, 0, 0, 1, 1, 1, 0,
  1, 1, 0, 0, 0, 1, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 211 */
  0, 0, 0, 0, 1, 1, 1, 0, 0,
  0, 0, 1, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 1, 1, 0, 0, 0,
  0, 1, 1, 0, 0, 1, 1, 0, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  0, 1, 1, 0, 0, 1, 1, 0, 0,
  0, 0, 1, 1, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 212 */
  0, 0, 1, 1, 1, 1, 0, 0, 0,
  0, 1, 1, 0, 0, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 1, 1, 0, 0, 0,
  0, 1, 1, 0, 0, 1, 1, 0, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  0, 1, 1, 0, 0, 1, 1, 0, 0,
  0, 0, 1, 1, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 213 */
  0, 0, 1, 1, 0, 0, 1, 1, 0,
  0, 1, 1, 0, 0, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 1, 1, 0, 0, 0,
  0, 1, 1, 0, 0, 1, 1, 0, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  0, 1, 1, 0, 0, 1, 1, 0, 0,
  0, 0, 1, 1, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 214 */
  0, 1, 1, 0, 0, 1, 1, 0, 0,
  0, 1, 1, 0, 0, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 1, 1, 0, 0, 0,
  0, 1, 1, 0, 0, 1, 1, 0, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  0, 1, 1, 0, 0, 1, 1, 0, 0,
  0, 0, 1, 1, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 215 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0, 0, 1, 0,
  0, 1, 1, 0, 0, 0, 1, 1, 0,
  0, 0, 1, 1, 0, 1, 1, 0, 0,
  0, 0, 0, 1, 1, 1, 0, 0, 0,
  0, 0, 0, 1, 1, 1, 0, 0, 0,
  0, 0, 1, 1, 0, 1, 1, 0, 0,
  0, 1, 1, 0, 0, 0, 1, 1, 0,
  0, 1, 0, 0, 0, 0, 0, 1, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 216 */
  0, 1, 1, 0, 0, 1, 1, 0, 0,
  0, 0, 1, 1, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 1, 1, 0, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 1, 1, 1, 1, 1, 0, 0,
  1, 1, 1, 1, 1, 0, 0, 0, 0,
  1, 1, 0, 0, 1, 1, 0, 0, 0,
  1, 1, 0, 0, 0, 1, 1, 0, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 217 */
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 1, 0, 0, 1, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  0, 1, 1, 0, 0, 1, 1, 0, 0,
  0, 0, 1, 1, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 218 */
  0, 0, 0, 0, 1, 1, 1, 0, 0,
  0, 0, 1, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  0, 1, 1, 0, 0, 1, 1, 0, 0,
  0, 0, 1, 1, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 219 */
  0, 0, 1, 1, 0, 0, 1, 1, 0,
  0, 1, 1, 0, 0, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  0, 1, 1, 0, 0, 1, 1, 0, 0,
  0, 0, 1, 1, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 220 */
  0, 1, 1, 0, 0, 1, 1, 0, 0,
  0, 1, 1, 0, 0, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  0, 1, 1, 0, 0, 1, 1, 0, 0,
  0, 0, 1, 1, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 221 */
  0, 0, 0, 0, 1, 1, 1, 0, 0,
  0, 0, 1, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  0, 1, 1, 0, 0, 1, 1, 0, 0,
  0, 0, 1, 1, 1, 1, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 222 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 1, 1, 1, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 0, 1, 1, 0, 0, 0,
  0, 0, 1, 1, 1, 0, 0, 0, 0,

/* Char 223 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 1, 1, 0, 0,
  0, 0, 1, 1, 0, 0, 1, 1, 0,
  0, 1, 1, 0, 0, 0, 1, 1, 0,
  0, 1, 1, 0, 0, 1, 1, 0, 0,
  1, 1, 1, 0, 1, 1, 0, 0, 0,
  0, 1, 1, 0, 0, 1, 1, 0, 0,
  0, 1, 1, 0, 0, 0, 1, 1, 0,
  0, 1, 1, 0, 0, 0, 1, 1, 0,
  0, 1, 1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 224 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 1, 1, 0, 0,
  0, 0, 0, 0, 1, 1, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 1, 1, 1, 1, 0, 0,
  0, 1, 1, 1, 0, 0, 1, 1, 0,
  0, 1, 1, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 225 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 1, 1, 0, 0,
  0, 0, 0, 0, 1, 1, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 1, 1, 1, 0, 0,
  0, 1, 1, 0, 0, 0, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 1, 1, 0,
  0, 1, 1, 1, 1, 1, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 1, 1, 1, 0,
  0, 1, 1, 1, 1, 0, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 226 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 1, 1, 1, 1, 0, 0, 0,
  0, 1, 1, 0, 0, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 1, 1, 1, 0, 0,
  0, 1, 1, 0, 0, 0, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 1, 1, 0,
  0, 1, 1, 1, 1, 1, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 1, 1, 1, 0,
  0, 1, 1, 1, 1, 0, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 227 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 0, 0, 1, 1, 0, 0,
  0, 1, 1, 0, 0, 1, 1, 0, 0,
  0, 0, 1, 1, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 1, 1, 1, 0, 0,
  0, 1, 1, 0, 0, 0, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 1, 1, 0,
  0, 1, 1, 1, 1, 1, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 1, 1, 1, 0,
  0, 1, 1, 1, 1, 0, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 228 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 0, 0, 1, 1, 0, 0,
  0, 1, 1, 0, 0, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 1, 1, 1, 0, 0,
  0, 1, 1, 0, 0, 0, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 1, 1, 0,
  0, 1, 1, 1, 1, 1, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 1, 1, 1, 0,
  0, 1, 1, 1, 1, 0, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 229 */
  0, 0, 0, 0, 1, 1, 1, 0, 0,
  0, 0, 1, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 230 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 1, 1, 0, 0,
  0, 0, 0, 0, 1, 1, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 1, 1, 1, 0, 0,
  0, 1, 1, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 0, 0, 0, 1, 1, 0,
  0, 0, 1, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 231 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 1, 1, 1, 0, 0,
  0, 1, 1, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 0, 0, 0, 1, 1, 0,
  0, 0, 1, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 1, 1, 0, 0, 0,
  0, 0, 1, 1, 1, 0, 0, 0, 0,

/* Char 232 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 0, 1, 1, 0, 0,
  0, 0, 0, 1, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 1, 1, 1, 0, 0,
  0, 1, 1, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 0, 0, 0, 1, 1, 0,
  0, 0, 1, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 233 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 1, 1, 0, 0,
  0, 0, 0, 0, 1, 1, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 1, 1, 0, 0, 0,
  0, 1, 1, 0, 0, 1, 1, 0, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 1, 1, 1, 1, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 0, 0, 0, 1, 1, 0,
  0, 0, 1, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 234 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 1, 1, 0, 0, 0,
  0, 1, 1, 0, 0, 1, 1, 0, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 1, 1, 1, 1, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 0, 0, 0, 1, 1, 0,
  0, 0, 1, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 1, 1, 1, 0,

/* Char 235 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 0, 0, 1, 1, 0, 0,
  0, 1, 1, 0, 0, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 1, 1, 0, 0, 0,
  0, 1, 1, 0, 0, 1, 1, 0, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 1, 1, 1, 1, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 0, 0, 0, 1, 1, 0,
  0, 0, 1, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 236 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 0, 0, 1, 1, 0, 0,
  0, 0, 1, 1, 1, 1, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 1, 1, 0, 0, 0,
  0, 1, 1, 0, 0, 1, 1, 0, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 1, 1, 1, 1, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 0, 0, 0, 1, 1, 0,
  0, 0, 1, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 237 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 1, 1, 0, 0,
  0, 0, 0, 0, 1, 1, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 238 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 1, 1, 1, 1, 0, 0, 0,
  0, 1, 1, 0, 0, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 239 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 1, 1, 1,
  0, 0, 0, 0, 0, 0, 0, 1, 1,
  0, 0, 0, 0, 0, 1, 1, 1, 1,
  0, 0, 0, 0, 0, 1, 1, 1, 0,
  0, 0, 0, 0, 0, 1, 1, 0, 0,
  0, 0, 1, 1, 0, 1, 1, 0, 0,
  0, 1, 1, 0, 1, 1, 1, 0, 0,
  1, 1, 0, 0, 0, 1, 1, 0, 0,
  1, 1, 0, 0, 0, 1, 1, 0, 0,
  1, 1, 0, 0, 0, 1, 1, 0, 0,
  0, 1, 1, 0, 1, 1, 1, 0, 0,
  0, 0, 1, 1, 0, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 240 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 1, 1, 0, 0,
  0, 0, 0, 0, 1, 1, 1, 1, 0,
  0, 0, 0, 0, 0, 1, 1, 0, 0,
  0, 0, 1, 1, 0, 1, 1, 0, 0,
  0, 1, 1, 0, 1, 1, 1, 0, 0,
  1, 1, 0, 0, 0, 1, 1, 0, 0,
  1, 1, 0, 0, 0, 1, 1, 0, 0,
  1, 1, 0, 0, 0, 1, 1, 0, 0,
  0, 1, 1, 0, 1, 1, 1, 0, 0,
  0, 0, 1, 1, 0, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 241 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 1, 1, 0, 0,
  0, 0, 0, 0, 1, 1, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 1, 1, 1, 0, 0, 0,
  1, 1, 1, 0, 0, 1, 1, 0, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 242 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 0, 0, 1, 1, 0, 0,
  0, 0, 1, 1, 1, 1, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 1, 1, 1, 0, 0, 0,
  1, 1, 1, 0, 0, 1, 1, 0, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 243 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 1, 1, 0, 0,
  0, 0, 0, 0, 1, 1, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 1, 1, 0, 0, 0,
  0, 1, 1, 0, 0, 1, 1, 0, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  0, 1, 1, 0, 0, 1, 1, 0, 0,
  0, 0, 1, 1, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 244 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 1, 1, 1, 1, 0, 0, 0,
  0, 1, 1, 0, 0, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 1, 1, 0, 0, 0,
  0, 1, 1, 0, 0, 1, 1, 0, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  0, 1, 1, 0, 0, 1, 1, 0, 0,
  0, 0, 1, 1, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 245 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 1, 1, 0,
  0, 0, 1, 1, 0, 1, 1, 0, 0,
  0, 1, 1, 0, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 1, 1, 0, 0, 0,
  0, 1, 1, 0, 0, 1, 1, 0, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  0, 1, 1, 0, 0, 1, 1, 0, 0,
  0, 0, 1, 1, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 246 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 0, 0, 1, 1, 0, 0,
  0, 1, 1, 0, 0, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 1, 1, 0, 0, 0,
  0, 1, 1, 0, 0, 1, 1, 0, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  0, 1, 1, 0, 0, 1, 1, 0, 0,
  0, 0, 1, 1, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 247 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 1, 1, 1, 0,
  1, 1, 1, 1, 1, 1, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 248 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 0, 1, 1, 0, 0,
  0, 0, 0, 1, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 1, 1, 1, 1, 0, 0,
  0, 1, 1, 1, 0, 0, 1, 1, 0,
  0, 1, 1, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 249 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 1, 0, 0, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 1, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  0, 1, 1, 0, 0, 1, 1, 1, 0,
  0, 0, 1, 1, 1, 0, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 250 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 1, 1, 0, 0,
  0, 0, 0, 0, 1, 1, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  0, 1, 1, 0, 0, 1, 1, 1, 0,
  0, 0, 1, 1, 1, 0, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 251 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 1, 1, 0,
  0, 0, 1, 1, 0, 1, 1, 0, 0,
  0, 1, 1, 0, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  0, 1, 1, 0, 0, 1, 1, 1, 0,
  0, 0, 1, 1, 1, 0, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 252 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 0, 0, 1, 1, 0, 0,
  0, 1, 1, 0, 0, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  0, 1, 1, 0, 0, 1, 1, 1, 0,
  0, 0, 1, 1, 1, 0, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,

/* Char 253 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 1, 1, 0, 0,
  0, 0, 0, 0, 1, 1, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 0,
  0, 1, 1, 0, 0, 1, 1, 1, 0,
  0, 0, 1, 1, 1, 0, 1, 1, 0,
  1, 0, 0, 0, 0, 0, 1, 1, 0,
  0, 1, 1, 1, 1, 1, 1, 0, 0,

/* Char 254 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 1, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 1, 1, 0,
  0, 0, 0, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 1, 1, 0, 0, 0,
  0, 0, 1, 1, 1, 0, 0, 0, 0,

/* Char 255 */
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,


};

gdFont gdFontGiantRep = {
  256,
  0,
  9,
  15,
  gdFontGiantData
};

BGD_EXPORT_DATA_IMPL gdFontPtr gdFontGiant = &gdFontGiantRep;

BGD_DECLARE(gdFontPtr) gdFontGetGiant (void)
{
  return gdFontGiant;
}

/* This file has not been truncated. */
 111117      553220      325918      1193070199  200         0           100640      9   gdfontl.c `


/*
   This is a header file for gd font, generated using
   bdftogd version 0.5 by Jan Pazdziora, adelton@fi.muni.cz
   from bdf font
   -misc-fixed-medium-r-normal--16-140-75-75-c-80-iso8859-2
   at Tue Jan  6 19:39:27 1998.

   The original bdf was holding following copyright:
   "Libor Skarvada, libor@informatics.muni.cz"
 */


#include "gdfontl.h"

char gdFontLargeData[] = {
/* Char 0 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 1 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 1, 1, 1, 0, 0, 0,
  0, 1, 1, 1, 1, 1, 0, 0,
  1, 1, 1, 1, 1, 1, 1, 0,
  1, 1, 1, 1, 1, 1, 1, 0,
  0, 1, 1, 1, 1, 1, 0, 0,
  0, 0, 1, 1, 1, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 2 */
  1, 0, 1, 0, 1, 0, 1, 0,
  0, 1, 0, 1, 0, 1, 0, 1,
  1, 0, 1, 0, 1, 0, 1, 0,
  0, 1, 0, 1, 0, 1, 0, 1,
  1, 0, 1, 0, 1, 0, 1, 0,
  0, 1, 0, 1, 0, 1, 0, 1,
  1, 0, 1, 0, 1, 0, 1, 0,
  0, 1, 0, 1, 0, 1, 0, 1,
  1, 0, 1, 0, 1, 0, 1, 0,
  0, 1, 0, 1, 0, 1, 0, 1,
  1, 0, 1, 0, 1, 0, 1, 0,
  0, 1, 0, 1, 0, 1, 0, 1,
  1, 0, 1, 0, 1, 0, 1, 0,
  0, 1, 0, 1, 0, 1, 0, 1,
  1, 0, 1, 0, 1, 0, 1, 0,
  0, 1, 0, 1, 0, 1, 0, 1,

/* Char 3 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  1, 0, 0, 0, 1, 0, 0, 0,
  1, 0, 0, 0, 1, 0, 0, 0,
  1, 1, 1, 1, 1, 0, 0, 0,
  1, 0, 0, 0, 1, 0, 0, 0,
  1, 0, 0, 0, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 1, 1, 1, 0,
  0, 0, 0, 0, 1, 0, 0, 0,
  0, 0, 0, 0, 1, 0, 0, 0,
  0, 0, 0, 0, 1, 0, 0, 0,
  0, 0, 0, 0, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 4 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 0, 0, 0, 0,
  1, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 1, 0, 0, 0, 0, 0,
  1, 0, 0, 0, 0, 0, 0, 0,
  1, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 1, 1, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 1, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 5 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 0, 0, 0, 0,
  1, 0, 0, 0, 0, 0, 0, 0,
  1, 0, 0, 0, 0, 0, 0, 0,
  1, 0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 1, 0, 0,
  0, 0, 0, 1, 0, 0, 1, 0,
  0, 0, 0, 1, 1, 1, 0, 0,
  0, 0, 0, 1, 0, 1, 0, 0,
  0, 0, 0, 1, 0, 0, 1, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 6 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  1, 0, 0, 0, 0, 0, 0, 0,
  1, 0, 0, 0, 0, 0, 0, 0,
  1, 0, 0, 0, 0, 0, 0, 0,
  1, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 1, 1, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 1, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 7 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 1, 0, 0,
  0, 0, 1, 0, 0, 1, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 8 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 9 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  1, 0, 0, 0, 1, 0, 0, 0,
  1, 1, 0, 0, 1, 0, 0, 0,
  1, 0, 1, 0, 1, 0, 0, 0,
  1, 0, 0, 1, 1, 0, 0, 0,
  1, 0, 0, 0, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 10 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  1, 0, 0, 0, 1, 0, 0, 0,
  1, 0, 0, 0, 1, 0, 0, 0,
  0, 1, 0, 1, 0, 0, 0, 0,
  0, 1, 0, 1, 0, 0, 0, 0,
  0, 0, 1, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 1, 1, 1, 0,
  0, 0, 0, 0, 1, 0, 0, 0,
  0, 0, 0, 0, 1, 0, 0, 0,
  0, 0, 0, 0, 1, 0, 0, 0,
  0, 0, 0, 0, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 11 */
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  1, 1, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 12 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,

/* Char 13 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 1, 1, 1,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,

/* Char 14 */
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 1, 1, 1,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 15 */
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 1, 1, 1,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,

/* Char 16 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 1, 1, 1,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 17 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 1, 1, 1,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 18 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 1, 1, 1,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 19 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 1, 1, 1,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 20 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 1, 1, 1,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 21 */
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 1, 1, 1,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,

/* Char 22 */
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  1, 1, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,

/* Char 23 */
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 1, 1, 1,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 24 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 1, 1, 1,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,

/* Char 25 */
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,

/* Char 26 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 1, 0,
  0, 0, 0, 0, 1, 1, 0, 0,
  0, 0, 1, 1, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 0, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 1, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 27 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 0, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 1, 0,
  0, 0, 0, 0, 1, 1, 0, 0,
  0, 0, 1, 1, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 28 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 1, 1, 0,
  1, 0, 1, 0, 1, 0, 0, 0,
  0, 0, 1, 0, 1, 0, 0, 0,
  0, 0, 1, 0, 1, 0, 0, 0,
  0, 0, 1, 0, 1, 0, 0, 0,
  0, 0, 1, 0, 1, 0, 0, 0,
  1, 1, 0, 0, 0, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 29 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 1, 0,
  0, 0, 0, 0, 0, 1, 0, 0,
  1, 1, 1, 1, 1, 1, 1, 0,
  0, 0, 0, 1, 1, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 1, 1, 0,
  0, 1, 0, 0, 0, 0, 0, 0,
  1, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 30 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 1, 0, 0,
  0, 0, 1, 0, 0, 0, 0, 0,
  0, 0, 1, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 0, 0, 0,
  0, 0, 1, 0, 0, 0, 0, 0,
  0, 0, 1, 0, 0, 0, 0, 0,
  0, 1, 1, 0, 0, 0, 1, 0,
  1, 0, 1, 1, 1, 1, 0, 0,
  1, 1, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 31 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 32 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 33 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 34 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 0, 0, 1, 0, 0,
  0, 0, 1, 0, 0, 1, 0, 0,
  0, 0, 1, 0, 0, 1, 0, 0,
  0, 0, 1, 0, 0, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 35 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 1, 0,
  0, 0, 0, 1, 0, 0, 1, 0,
  0, 0, 0, 1, 0, 0, 1, 0,
  0, 1, 1, 1, 1, 1, 1, 0,
  0, 0, 1, 0, 0, 1, 0, 0,
  0, 0, 1, 0, 0, 1, 0, 0,
  0, 1, 1, 1, 1, 1, 1, 0,
  0, 1, 0, 0, 1, 0, 0, 0,
  0, 1, 0, 0, 1, 0, 0, 0,
  0, 1, 0, 0, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 36 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 1, 0, 0,
  1, 0, 0, 1, 0, 0, 1, 0,
  1, 0, 0, 1, 0, 0, 0, 0,
  0, 1, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 1, 0, 0,
  0, 0, 0, 1, 0, 0, 1, 0,
  1, 0, 0, 1, 0, 0, 1, 0,
  0, 1, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 37 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 0, 0, 0, 1, 0,
  1, 0, 0, 1, 0, 1, 0, 0,
  1, 0, 0, 1, 0, 1, 0, 0,
  0, 1, 1, 0, 1, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 1, 0, 1, 1, 0, 0,
  0, 1, 0, 1, 0, 0, 1, 0,
  0, 1, 0, 1, 0, 0, 1, 0,
  1, 0, 0, 0, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 38 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 1, 0, 0, 0,
  0, 1, 0, 0, 0, 1, 0, 0,
  0, 1, 0, 0, 0, 1, 0, 0,
  0, 1, 0, 0, 0, 1, 0, 0,
  0, 0, 1, 1, 1, 0, 0, 0,
  0, 1, 1, 1, 0, 0, 1, 0,
  1, 0, 0, 0, 1, 0, 1, 0,
  1, 0, 0, 0, 0, 1, 0, 0,
  1, 0, 0, 0, 1, 1, 0, 0,
  0, 1, 1, 1, 0, 0, 1, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 39 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 1, 0, 0, 0,
  0, 0, 0, 0, 1, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 40 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 1, 0, 0,
  0, 0, 0, 0, 1, 0, 0, 0,
  0, 0, 0, 0, 1, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 0, 1, 0, 0, 0,
  0, 0, 0, 0, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 41 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 0, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 0, 1, 0, 0, 0,
  0, 0, 0, 0, 1, 0, 0, 0,
  0, 0, 0, 0, 1, 0, 0, 0,
  0, 0, 0, 0, 1, 0, 0, 0,
  0, 0, 0, 0, 1, 0, 0, 0,
  0, 0, 0, 0, 1, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 1, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 42 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  1, 0, 0, 1, 0, 0, 1, 0,
  0, 1, 0, 1, 0, 1, 0, 0,
  0, 0, 1, 1, 1, 0, 0, 0,
  0, 1, 0, 1, 0, 1, 0, 0,
  1, 0, 0, 1, 0, 0, 1, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 43 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 1, 1, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 44 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 1, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 45 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 46 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 47 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 1, 0,
  0, 0, 0, 0, 0, 0, 1, 0,
  0, 0, 0, 0, 0, 1, 0, 0,
  0, 0, 0, 0, 1, 0, 0, 0,
  0, 0, 0, 0, 1, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 1, 0, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 48 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 1, 0, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 0, 1, 0, 0, 1, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 49 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 1, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0,
  0, 0, 1, 0, 1, 0, 0, 0,
  0, 0, 0, 0, 1, 0, 0, 0,
  0, 0, 0, 0, 1, 0, 0, 0,
  0, 0, 0, 0, 1, 0, 0, 0,
  0, 0, 0, 0, 1, 0, 0, 0,
  0, 0, 0, 0, 1, 0, 0, 0,
  0, 0, 0, 0, 1, 0, 0, 0,
  0, 0, 1, 1, 1, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 50 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 1, 1, 0, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 0, 0, 0, 0, 0, 1, 0,
  0, 0, 0, 0, 1, 1, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 1, 0, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 51 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 1, 1, 0, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 0, 0, 0, 0, 0, 1, 0,
  0, 0, 0, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 1, 0,
  0, 0, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 0, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 52 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 1, 0, 0,
  0, 0, 0, 0, 1, 1, 0, 0,
  0, 0, 0, 1, 0, 1, 0, 0,
  0, 0, 1, 0, 0, 1, 0, 0,
  0, 1, 0, 0, 0, 1, 0, 0,
  0, 1, 0, 0, 0, 1, 0, 0,
  0, 1, 1, 1, 1, 1, 1, 0,
  0, 0, 0, 0, 0, 1, 0, 0,
  0, 0, 0, 0, 0, 1, 0, 0,
  0, 0, 0, 0, 0, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 53 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 1, 1, 0,
  0, 1, 0, 0, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 1, 0,
  0, 0, 0, 0, 0, 0, 1, 0,
  0, 0, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 0, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 54 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 1, 0, 0,
  0, 0, 1, 0, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 1, 0, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 0, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 55 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 1, 0,
  0, 0, 0, 0, 0, 0, 1, 0,
  0, 0, 0, 0, 0, 1, 0, 0,
  0, 0, 0, 0, 0, 1, 0, 0,
  0, 0, 0, 0, 0, 1, 0, 0,
  0, 0, 0, 0, 1, 0, 0, 0,
  0, 0, 0, 0, 1, 0, 0, 0,
  0, 0, 0, 0, 1, 0, 0, 0,
  0, 0, 0, 0, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 56 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 1, 1, 0, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 0, 1, 1, 1, 1, 0, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 0, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 57 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 1, 1, 0, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 0, 1, 1, 1, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 1, 0,
  0, 0, 0, 0, 0, 0, 1, 0,
  0, 0, 0, 0, 0, 0, 1, 0,
  0, 0, 0, 0, 0, 1, 0, 0,
  0, 0, 1, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 58 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 59 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 1, 0, 0, 0,
  0, 0, 0, 0, 1, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 60 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 1, 0, 0,
  0, 0, 0, 0, 1, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 1, 0, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 0, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 0, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 61 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 62 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 0, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 0, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 1, 0, 0,
  0, 0, 0, 0, 1, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 1, 0, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 63 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 1, 1, 0, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 0, 0, 0, 0, 0, 1, 0,
  0, 0, 0, 0, 0, 1, 0, 0,
  0, 0, 0, 0, 1, 0, 0, 0,
  0, 0, 0, 0, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 1, 0, 0, 0,
  0, 0, 0, 0, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 64 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 1, 0, 0,
  0, 0, 1, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 1, 0, 1, 0,
  0, 1, 0, 1, 0, 1, 1, 0,
  0, 1, 0, 1, 0, 0, 1, 0,
  0, 1, 0, 1, 0, 0, 1, 0,
  0, 1, 0, 1, 0, 0, 1, 0,
  0, 1, 0, 0, 1, 1, 1, 0,
  0, 0, 1, 0, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 65 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 1, 0, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 1, 1, 1, 1, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 66 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 1, 0, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 1, 1, 1, 1, 0, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 67 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 1, 1, 0, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 0, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 68 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 0, 0, 0,
  0, 1, 0, 0, 0, 1, 0, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 1, 0, 0,
  0, 1, 1, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 69 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 1, 1, 0,
  0, 1, 0, 0, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 1, 0, 0,
  0, 1, 0, 0, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 70 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 1, 1, 0,
  0, 1, 0, 0, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 1, 0, 0,
  0, 1, 0, 0, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 71 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 1, 1, 0, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0, 0, 0,
  0, 1, 0, 0, 1, 1, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 1, 1, 0,
  0, 0, 1, 1, 1, 0, 1, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 72 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 1, 1, 1, 1, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 73 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 74 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 1, 1, 1, 0,
  0, 0, 0, 0, 0, 1, 0, 0,
  0, 0, 0, 0, 0, 1, 0, 0,
  0, 0, 0, 0, 0, 1, 0, 0,
  0, 0, 0, 0, 0, 1, 0, 0,
  0, 0, 0, 0, 0, 1, 0, 0,
  0, 0, 0, 0, 0, 1, 0, 0,
  0, 1, 0, 0, 0, 1, 0, 0,
  0, 1, 0, 0, 0, 1, 0, 0,
  0, 0, 1, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 75 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 1, 0, 0,
  0, 1, 0, 0, 1, 0, 0, 0,
  0, 1, 0, 1, 0, 0, 0, 0,
  0, 1, 1, 0, 0, 0, 0, 0,
  0, 1, 1, 0, 0, 0, 0, 0,
  0, 1, 0, 1, 0, 0, 0, 0,
  0, 1, 0, 0, 1, 0, 0, 0,
  0, 1, 0, 0, 0, 1, 0, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 76 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 77 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  1, 0, 0, 0, 0, 0, 1, 0,
  1, 1, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 1, 1, 0,
  1, 0, 1, 0, 1, 0, 1, 0,
  1, 0, 1, 0, 1, 0, 1, 0,
  1, 0, 0, 1, 0, 0, 1, 0,
  1, 0, 0, 1, 0, 0, 1, 0,
  1, 0, 0, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 0, 0, 1, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 78 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 1, 0, 0, 0, 1, 0,
  0, 1, 1, 0, 0, 0, 1, 0,
  0, 1, 0, 1, 0, 0, 1, 0,
  0, 1, 0, 1, 0, 0, 1, 0,
  0, 1, 0, 0, 1, 0, 1, 0,
  0, 1, 0, 0, 1, 0, 1, 0,
  0, 1, 0, 0, 0, 1, 1, 0,
  0, 1, 0, 0, 0, 1, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 79 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 1, 1, 0, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 0, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 80 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 1, 0, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 1, 1, 1, 1, 0, 0,
  0, 1, 0, 0, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 81 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 1, 1, 0, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 1, 1, 0, 1, 0,
  0, 1, 1, 0, 0, 1, 1, 0,
  0, 0, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 1, 1,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 82 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 1, 0, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 1, 1, 1, 1, 0, 0,
  0, 1, 0, 0, 1, 0, 0, 0,
  0, 1, 0, 0, 0, 1, 0, 0,
  0, 1, 0, 0, 0, 1, 0, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 83 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 1, 1, 0, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 0, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 0, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 84 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 1, 1, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 85 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 0, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 86 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  1, 0, 0, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 1, 0, 0,
  0, 1, 0, 0, 0, 1, 0, 0,
  0, 1, 0, 0, 0, 1, 0, 0,
  0, 0, 1, 0, 1, 0, 0, 0,
  0, 0, 1, 0, 1, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 87 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  1, 0, 0, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 0, 0, 1, 0,
  1, 0, 0, 1, 0, 0, 1, 0,
  1, 0, 0, 1, 0, 0, 1, 0,
  1, 0, 0, 1, 0, 0, 1, 0,
  1, 0, 0, 1, 0, 0, 1, 0,
  1, 0, 1, 0, 1, 0, 1, 0,
  1, 0, 1, 0, 1, 0, 1, 0,
  0, 1, 0, 0, 0, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 88 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 0, 1, 0, 0, 1, 0, 0,
  0, 0, 1, 0, 0, 1, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 1, 0, 0,
  0, 0, 1, 0, 0, 1, 0, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 89 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  1, 0, 0, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 1, 0, 0,
  0, 1, 0, 0, 0, 1, 0, 0,
  0, 0, 1, 0, 1, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 90 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 1, 0,
  0, 0, 0, 0, 0, 0, 1, 0,
  0, 0, 0, 0, 0, 1, 0, 0,
  0, 0, 0, 0, 1, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 1, 0, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 91 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 1, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 92 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 0, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 0, 1, 0, 0, 0,
  0, 0, 0, 0, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 1, 0,
  0, 0, 0, 0, 0, 0, 1, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 93 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 1, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 94 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 1, 0, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 95 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 96 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 0, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 97 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 1, 1, 0, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 0, 0, 0, 1, 1, 1, 0,
  0, 0, 1, 1, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 1, 1, 0,
  0, 0, 1, 1, 1, 0, 1, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 98 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0, 0, 0,
  0, 1, 0, 1, 1, 1, 0, 0,
  0, 1, 1, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 1, 0, 0, 0, 1, 0,
  0, 1, 0, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 99 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 1, 1, 0, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 0, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 100 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 1, 0,
  0, 0, 0, 0, 0, 0, 1, 0,
  0, 0, 0, 0, 0, 0, 1, 0,
  0, 0, 1, 1, 1, 0, 1, 0,
  0, 1, 0, 0, 0, 1, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 1, 1, 0,
  0, 0, 1, 1, 1, 0, 1, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 101 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 1, 1, 0, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 1, 1, 1, 1, 1, 0,
  0, 1, 0, 0, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 102 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 1, 0, 0,
  0, 0, 1, 0, 0, 0, 1, 0,
  0, 0, 1, 0, 0, 0, 0, 0,
  0, 0, 1, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 1, 0, 0,
  0, 0, 1, 0, 0, 0, 0, 0,
  0, 0, 1, 0, 0, 0, 0, 0,
  0, 0, 1, 0, 0, 0, 0, 0,
  0, 0, 1, 0, 0, 0, 0, 0,
  0, 0, 1, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 103 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 1, 0,
  0, 0, 1, 1, 1, 0, 1, 0,
  0, 1, 0, 0, 0, 1, 0, 0,
  0, 1, 0, 0, 0, 1, 0, 0,
  0, 1, 0, 0, 0, 1, 0, 0,
  0, 0, 1, 1, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 1, 1, 0, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 0, 1, 1, 1, 1, 0, 0,

/* Char 104 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0, 0, 0,
  0, 1, 0, 1, 1, 1, 0, 0,
  0, 1, 1, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 105 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 106 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 1, 0, 0,
  0, 0, 0, 0, 0, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 1, 0, 0,
  0, 0, 0, 0, 0, 1, 0, 0,
  0, 0, 0, 0, 0, 1, 0, 0,
  0, 0, 0, 0, 0, 1, 0, 0,
  0, 0, 0, 0, 0, 1, 0, 0,
  0, 0, 0, 0, 0, 1, 0, 0,
  0, 0, 0, 0, 0, 1, 0, 0,
  0, 1, 0, 0, 1, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0, 0,

/* Char 107 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 1, 0, 0,
  0, 1, 0, 0, 1, 0, 0, 0,
  0, 1, 0, 1, 0, 0, 0, 0,
  0, 1, 1, 1, 0, 0, 0, 0,
  0, 1, 0, 0, 1, 0, 0, 0,
  0, 1, 0, 0, 0, 1, 0, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 108 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 109 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 1, 0, 1, 1, 0, 0,
  1, 0, 0, 1, 0, 0, 1, 0,
  1, 0, 0, 1, 0, 0, 1, 0,
  1, 0, 0, 1, 0, 0, 1, 0,
  1, 0, 0, 1, 0, 0, 1, 0,
  1, 0, 0, 1, 0, 0, 1, 0,
  1, 0, 0, 1, 0, 0, 1, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 110 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 1, 0, 1, 1, 1, 0, 0,
  0, 1, 1, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 111 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 1, 1, 0, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 0, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 112 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 1, 0, 1, 1, 1, 0, 0,
  0, 1, 1, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 1, 0, 0, 0, 1, 0,
  0, 1, 0, 1, 1, 1, 0, 0,
  0, 1, 0, 0, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0, 0, 0,

/* Char 113 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 1, 0, 1, 0,
  0, 1, 0, 0, 0, 1, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 1, 1, 0,
  0, 0, 1, 1, 1, 0, 1, 0,
  0, 0, 0, 0, 0, 0, 1, 0,
  0, 0, 0, 0, 0, 0, 1, 0,
  0, 0, 0, 0, 0, 0, 1, 0,

/* Char 114 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 1, 0, 1, 1, 1, 0, 0,
  0, 1, 1, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 115 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 1, 1, 0, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 0, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 116 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 1, 0,
  0, 0, 0, 0, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 117 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 1, 1, 0,
  0, 0, 1, 1, 1, 0, 1, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 118 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 0, 1, 0, 0, 1, 0, 0,
  0, 0, 1, 0, 0, 1, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 119 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  1, 0, 0, 0, 0, 0, 1, 0,
  1, 0, 0, 1, 0, 0, 1, 0,
  1, 0, 0, 1, 0, 0, 1, 0,
  1, 0, 0, 1, 0, 0, 1, 0,
  1, 0, 0, 1, 0, 0, 1, 0,
  1, 0, 1, 0, 1, 0, 1, 0,
  0, 1, 0, 0, 0, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 120 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 0, 1, 0, 0, 1, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 1, 0, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 121 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 0, 1, 0, 0, 1, 1, 0,
  0, 0, 0, 1, 1, 0, 1, 0,
  0, 0, 0, 0, 0, 0, 1, 0,
  0, 0, 0, 0, 0, 1, 0, 0,
  0, 0, 1, 1, 1, 0, 0, 0,

/* Char 122 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 1, 1, 0,
  0, 0, 0, 0, 0, 1, 0, 0,
  0, 0, 0, 0, 1, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 1, 0, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 123 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 0, 0, 0,
  0, 0, 1, 0, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 1, 0, 0, 0, 0, 0,
  0, 0, 1, 0, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 1, 0, 0, 0, 0, 0,
  0, 0, 1, 0, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 124 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 125 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 0, 1, 0, 0, 0,
  0, 0, 0, 0, 1, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 0, 1, 0, 0, 0,
  0, 0, 0, 0, 1, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 0, 1, 0, 0, 0,
  0, 0, 0, 0, 1, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 126 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 0, 0, 0, 1, 0,
  1, 0, 0, 1, 0, 0, 1, 0,
  1, 0, 0, 0, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 127 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 128 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 129 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 130 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 131 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 132 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 133 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 134 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 135 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 136 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 137 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 138 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 139 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 140 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 141 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 142 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 143 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 144 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 145 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 146 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 147 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 148 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 149 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 150 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 151 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 152 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 153 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 154 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 155 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 156 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 157 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 158 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 159 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 160 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 161 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 1, 0, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 1, 1, 1, 1, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 0, 0, 0, 0, 1, 0, 0,
  0, 0, 0, 0, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 1, 1, 0,

/* Char 162 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 0, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 163 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0, 0, 0,
  0, 1, 0, 1, 0, 0, 0, 0,
  0, 1, 1, 0, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 164 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  1, 0, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 1, 0, 0,
  0, 0, 1, 1, 1, 0, 0, 0,
  0, 1, 0, 0, 0, 1, 0, 0,
  0, 1, 0, 0, 0, 1, 0, 0,
  0, 0, 1, 1, 1, 0, 0, 0,
  0, 1, 0, 0, 0, 1, 0, 0,
  1, 0, 0, 0, 0, 0, 1, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 165 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 1, 0, 0, 0,
  0, 1, 0, 0, 1, 0, 0, 0,
  0, 1, 0, 1, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 166 */
  0, 0, 0, 0, 0, 1, 1, 0,
  0, 0, 0, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 1, 1, 0, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 0, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 0, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 167 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 1, 1, 0, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 1, 1, 0, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 0, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 0, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 168 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 0, 0, 1, 0, 0,
  0, 0, 1, 0, 0, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 169 */
  0, 0, 1, 0, 0, 1, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 1, 1, 0, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 0, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 0, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 170 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 1, 1, 0, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 0, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 0, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 1, 0, 0, 0,
  0, 0, 0, 0, 1, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,

/* Char 171 */
  0, 0, 1, 0, 1, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 1, 1, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 172 */
  0, 0, 0, 0, 0, 1, 1, 0,
  0, 0, 0, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 1, 0,
  0, 0, 0, 0, 0, 0, 1, 0,
  0, 0, 0, 0, 0, 1, 0, 0,
  0, 0, 0, 0, 1, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 1, 0, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 173 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 174 */
  0, 0, 1, 0, 0, 1, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 1, 0,
  0, 0, 0, 0, 0, 0, 1, 0,
  0, 0, 0, 0, 0, 1, 0, 0,
  0, 0, 0, 0, 1, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 1, 0, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 175 */
  0, 0, 0, 1, 1, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 1, 0,
  0, 0, 0, 0, 0, 0, 1, 0,
  0, 0, 0, 0, 0, 1, 0, 0,
  0, 0, 0, 0, 1, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 1, 0, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 176 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 1, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 177 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 1, 1, 0, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 0, 0, 0, 1, 1, 1, 0,
  0, 0, 1, 1, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 1, 1, 0,
  0, 0, 1, 1, 1, 0, 1, 0,
  0, 0, 0, 0, 0, 1, 0, 0,
  0, 0, 0, 0, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 1, 1, 0,

/* Char 178 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 1, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 0, 1, 1, 1, 0,

/* Char 179 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 1, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0, 0,
  0, 1, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 180 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 1, 1, 0, 0,
  0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 181 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 1, 1, 0,
  0, 0, 1, 1, 0, 0, 1, 0,
  0, 0, 0, 1, 0, 0, 1, 0,
  0, 0, 0, 1, 0, 1, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 182 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 1, 0, 0,
  0, 0, 0, 0, 1, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 1, 1, 0, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 0, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 183 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 1, 0, 0,
  0, 0, 1, 0, 1, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 184 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 1, 0, 0,
  0, 0, 1, 1, 1, 0, 0, 0,

/* Char 185 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 0, 0, 1, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 1, 1, 0, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 0, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 186 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 1, 1, 0, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 0, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 1, 0, 0, 0,
  0, 0, 0, 0, 1, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,

/* Char 187 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 1, 1, 0,
  0, 0, 1, 0, 0, 0, 1, 0,
  0, 0, 1, 0, 0, 0, 1, 0,
  1, 1, 1, 1, 0, 1, 0, 0,
  0, 0, 1, 0, 0, 0, 0, 0,
  0, 0, 1, 0, 0, 0, 0, 0,
  0, 0, 1, 0, 0, 0, 0, 0,
  0, 0, 1, 0, 0, 0, 0, 0,
  0, 0, 1, 0, 0, 1, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 188 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 1, 0, 0,
  0, 0, 0, 0, 1, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 1, 1, 0,
  0, 0, 0, 0, 0, 1, 0, 0,
  0, 0, 0, 0, 1, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 1, 0, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 189 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 1, 0,
  0, 0, 1, 0, 0, 1, 0, 0,
  0, 1, 0, 0, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 190 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 0, 0, 1, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 1, 1, 0,
  0, 0, 0, 0, 0, 1, 0, 0,
  0, 0, 0, 0, 1, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 1, 0, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 191 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 1, 1, 0,
  0, 0, 0, 0, 0, 1, 0, 0,
  0, 0, 0, 0, 1, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 1, 0, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 192 */
  0, 0, 0, 0, 0, 1, 1, 0,
  0, 0, 0, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 1, 0, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 1, 1, 1, 1, 0, 0,
  0, 1, 0, 0, 1, 0, 0, 0,
  0, 1, 0, 0, 0, 1, 0, 0,
  0, 1, 0, 0, 0, 1, 0, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 193 */
  0, 0, 0, 0, 0, 1, 1, 0,
  0, 0, 0, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 1, 0, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 1, 1, 1, 1, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 194 */
  0, 0, 0, 1, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 1, 0, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 1, 1, 1, 1, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 195 */
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 0, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 1, 0, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 1, 1, 1, 1, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 196 */
  0, 0, 1, 0, 0, 1, 0, 0,
  0, 0, 1, 0, 0, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 1, 0, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 1, 1, 1, 1, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 197 */
  0, 0, 0, 0, 1, 1, 0, 0,
  0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 198 */
  0, 0, 0, 0, 0, 1, 1, 0,
  0, 0, 0, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 1, 1, 0, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 0, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 199 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 1, 1, 0, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 0, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 1, 0, 0,
  0, 0, 1, 1, 1, 0, 0, 0,

/* Char 200 */
  0, 0, 1, 0, 0, 1, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 1, 1, 0, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 0, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 201 */
  0, 0, 0, 0, 0, 1, 1, 0,
  0, 0, 0, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 1, 1, 0,
  0, 1, 0, 0, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 1, 0, 0,
  0, 1, 0, 0, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 202 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 1, 1, 0,
  0, 1, 0, 0, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 1, 0, 0,
  0, 1, 0, 0, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 1, 1, 0,
  0, 0, 0, 0, 0, 1, 0, 0,
  0, 0, 0, 0, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 1, 1, 0,

/* Char 203 */
  0, 0, 1, 0, 0, 1, 0, 0,
  0, 0, 1, 0, 0, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 1, 1, 0,
  0, 1, 0, 0, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 1, 0, 0,
  0, 1, 0, 0, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 204 */
  0, 0, 1, 0, 0, 1, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 1, 1, 0,
  0, 1, 0, 0, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 1, 0, 0,
  0, 1, 0, 0, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 205 */
  0, 0, 0, 0, 1, 1, 0, 0,
  0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 206 */
  0, 0, 1, 1, 1, 0, 0, 0,
  0, 1, 0, 0, 0, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 207 */
  0, 0, 1, 0, 0, 1, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 0, 0, 0,
  0, 1, 0, 0, 0, 1, 0, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 1, 0, 0,
  0, 1, 1, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 208 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 0, 0, 0,
  0, 1, 0, 0, 0, 1, 0, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  1, 1, 1, 1, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 1, 0, 0,
  0, 1, 1, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 209 */
  0, 0, 0, 0, 0, 1, 1, 0,
  0, 0, 0, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 1, 0, 0, 0, 1, 0,
  0, 1, 1, 0, 0, 0, 1, 0,
  0, 1, 0, 1, 0, 0, 1, 0,
  0, 1, 0, 1, 0, 0, 1, 0,
  0, 1, 0, 0, 1, 0, 1, 0,
  0, 1, 0, 0, 1, 0, 1, 0,
  0, 1, 0, 0, 0, 1, 1, 0,
  0, 1, 0, 0, 0, 1, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 210 */
  0, 0, 1, 0, 0, 1, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 1, 0, 0, 0, 1, 0,
  0, 1, 1, 0, 0, 0, 1, 0,
  0, 1, 0, 1, 0, 0, 1, 0,
  0, 1, 0, 1, 0, 0, 1, 0,
  0, 1, 0, 0, 1, 0, 1, 0,
  0, 1, 0, 0, 1, 0, 1, 0,
  0, 1, 0, 0, 0, 1, 1, 0,
  0, 1, 0, 0, 0, 1, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 211 */
  0, 0, 0, 0, 0, 1, 1, 0,
  0, 0, 0, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 1, 1, 0, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 0, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 212 */
  0, 0, 0, 1, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 1, 1, 0, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 0, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 213 */
  0, 0, 0, 1, 0, 0, 1, 0,
  0, 0, 1, 0, 0, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 1, 1, 0, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 0, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 214 */
  0, 0, 1, 0, 0, 1, 0, 0,
  0, 0, 1, 0, 0, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 1, 1, 0, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 0, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 215 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 0, 1, 0, 0, 1, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 1, 0, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 216 */
  0, 0, 1, 0, 0, 1, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 1, 0, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 1, 1, 1, 1, 0, 0,
  0, 1, 0, 0, 1, 0, 0, 0,
  0, 1, 0, 0, 0, 1, 0, 0,
  0, 1, 0, 0, 0, 1, 0, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 217 */
  0, 0, 0, 1, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 1, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 0, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 218 */
  0, 0, 0, 0, 0, 1, 1, 0,
  0, 0, 0, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 0, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 219 */
  0, 0, 0, 1, 0, 0, 1, 0,
  0, 0, 1, 0, 0, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 0, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 220 */
  0, 0, 1, 0, 0, 1, 0, 0,
  0, 0, 1, 0, 0, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 0, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 221 */
  0, 0, 0, 0, 0, 1, 1, 0,
  0, 0, 0, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  1, 0, 0, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 1, 0, 0,
  0, 1, 0, 0, 0, 1, 0, 0,
  0, 0, 1, 0, 1, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 222 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 1, 1, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 0, 1, 0, 0, 0,
  0, 0, 0, 0, 1, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,

/* Char 223 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 1, 0, 0, 0,
  0, 1, 0, 0, 0, 1, 0, 0,
  0, 1, 0, 0, 0, 1, 0, 0,
  0, 1, 0, 0, 0, 1, 0, 0,
  1, 1, 0, 0, 1, 0, 0, 0,
  0, 1, 0, 0, 0, 1, 0, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 1, 0, 0, 0, 1, 0,
  0, 1, 0, 1, 1, 1, 0, 0,
  1, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 224 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 1, 0, 0,
  0, 0, 0, 0, 1, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 1, 0, 1, 1, 1, 0, 0,
  0, 1, 1, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 225 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 1, 0, 0,
  0, 0, 0, 0, 1, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 1, 1, 0, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 0, 0, 0, 1, 1, 1, 0,
  0, 0, 1, 1, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 1, 1, 0,
  0, 0, 1, 1, 1, 0, 1, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 226 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 1, 0, 0, 0,
  0, 0, 0, 1, 0, 1, 0, 0,
  0, 0, 1, 0, 0, 0, 1, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 1, 1, 0, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 0, 0, 0, 1, 1, 1, 0,
  0, 0, 1, 1, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 1, 1, 0,
  0, 0, 1, 1, 1, 0, 1, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 227 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 0, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 1, 1, 0, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 0, 0, 0, 1, 1, 1, 0,
  0, 0, 1, 1, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 1, 1, 0,
  0, 0, 1, 1, 1, 0, 1, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 228 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 0, 0, 1, 0, 0,
  0, 0, 1, 0, 0, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 1, 1, 0, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 0, 0, 0, 1, 1, 1, 0,
  0, 0, 1, 1, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 1, 1, 0,
  0, 0, 1, 1, 1, 0, 1, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 229 */
  0, 0, 0, 0, 1, 1, 0, 0,
  0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 230 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 1, 0, 0,
  0, 0, 0, 0, 1, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 1, 1, 0, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 0, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 231 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 1, 1, 0, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 0, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 1, 0, 0,
  0, 0, 1, 1, 1, 0, 0, 0,

/* Char 232 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 0, 0, 1, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 1, 1, 0, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 0, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 233 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 1, 0, 0,
  0, 0, 0, 0, 1, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 1, 1, 0, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 1, 1, 1, 1, 1, 0,
  0, 1, 0, 0, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 234 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 1, 1, 0, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 1, 1, 1, 1, 1, 0,
  0, 1, 0, 0, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 1, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 0, 1, 1, 0, 0,

/* Char 235 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 0, 0, 1, 0, 0,
  0, 0, 1, 0, 0, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 1, 1, 0, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 1, 1, 1, 1, 1, 0,
  0, 1, 0, 0, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 236 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 0, 0, 1, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 1, 1, 0, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 1, 1, 1, 1, 1, 0,
  0, 1, 0, 0, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 237 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 1, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 1, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 238 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 1, 0, 1, 0, 0, 0,
  0, 1, 0, 0, 0, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 239 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 1, 1,
  0, 0, 0, 0, 0, 0, 0, 1,
  0, 0, 0, 0, 0, 1, 0, 1,
  0, 0, 0, 0, 0, 1, 1, 0,
  0, 0, 0, 0, 0, 1, 0, 0,
  0, 1, 1, 1, 0, 1, 0, 0,
  1, 0, 0, 0, 1, 1, 0, 0,
  1, 0, 0, 0, 0, 1, 0, 0,
  1, 0, 0, 0, 0, 1, 0, 0,
  1, 0, 0, 0, 0, 1, 0, 0,
  1, 0, 0, 0, 1, 1, 0, 0,
  0, 1, 1, 1, 0, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 240 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 1, 0, 0,
  0, 0, 0, 1, 1, 1, 1, 0,
  0, 0, 0, 0, 0, 1, 0, 0,
  0, 1, 1, 1, 0, 1, 0, 0,
  1, 0, 0, 0, 1, 1, 0, 0,
  1, 0, 0, 0, 0, 1, 0, 0,
  1, 0, 0, 0, 0, 1, 0, 0,
  1, 0, 0, 0, 0, 1, 0, 0,
  1, 0, 0, 0, 1, 1, 0, 0,
  0, 1, 1, 1, 0, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 241 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 1, 0, 0,
  0, 0, 0, 0, 1, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 1, 0, 1, 1, 1, 0, 0,
  0, 1, 1, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 242 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 0, 0, 1, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 1, 0, 1, 1, 1, 0, 0,
  0, 1, 1, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 243 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 1, 0, 0,
  0, 0, 0, 0, 1, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 1, 1, 0, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 0, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 244 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 1, 1, 0, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 0, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 245 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 1, 0, 0, 1,
  0, 0, 0, 1, 0, 0, 1, 0,
  0, 0, 1, 0, 0, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 1, 1, 0, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 0, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 246 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 0, 0, 1, 0, 0,
  0, 0, 1, 0, 0, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 1, 1, 0, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 0, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 247 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 248 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 0, 0, 1, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 1, 0, 1, 1, 1, 0, 0,
  0, 1, 1, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 249 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 1, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 1, 1, 0,
  0, 0, 1, 1, 1, 0, 1, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 250 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 1, 0, 0,
  0, 0, 0, 0, 1, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 1, 1, 0,
  0, 0, 1, 1, 1, 0, 1, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 251 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 1, 0, 0, 1,
  0, 0, 0, 1, 0, 0, 1, 0,
  0, 0, 1, 0, 0, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 1, 1, 0,
  0, 0, 1, 1, 1, 0, 1, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 252 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 0, 0, 1, 0, 0,
  0, 0, 1, 0, 0, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 1, 1, 0,
  0, 0, 1, 1, 1, 0, 1, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,

/* Char 253 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 1, 0, 0,
  0, 0, 0, 0, 1, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0, 1, 0,
  0, 0, 1, 0, 0, 1, 1, 0,
  0, 0, 0, 1, 1, 0, 1, 0,
  0, 0, 0, 0, 0, 0, 1, 0,
  0, 0, 0, 0, 0, 1, 0, 0,
  0, 0, 1, 1, 1, 0, 0, 0,

/* Char 254 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 1, 0,
  0, 0, 0, 0, 1, 1, 0, 0,
  0, 0, 0, 0, 1, 0, 0, 0,
  0, 0, 0, 0, 1, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0,

/* Char 255 */
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,


};

gdFont gdFontLargeRep = {
  256,
  0,
  8,
  16,
  gdFontLargeData
};

BGD_EXPORT_DATA_IMPL gdFontPtr gdFontLarge = &gdFontLargeRep;

BGD_DECLARE(gdFontPtr)
gdFontGetLarge (void)
{
  return gdFontLarge;
}

/* This file has not been truncated. */
 81155       634476      442002      1193070199  200         0           100640      10  gdfontmb.c`


/*
   This is a header file for gd font, generated using
   bdftogd version 0.5 by Jan Pazdziora, adelton@fi.muni.cz
   from bdf font
   -misc-fixed-bold-r-normal-sans-13-94-100-100-c-70-iso8859-2
   at Thu Jan  8 13:54:57 1998.
   No copyright info was found in the original bdf.
 */


#include "gdfontmb.h"

char gdFontMediumBoldData[] = {
/* Char 0 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 1 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 1, 1, 1, 1, 0, 0,
  1, 1, 1, 1, 1, 1, 0,
  0, 1, 1, 1, 1, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 2 */
  0, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 1, 1, 0,
  0, 0, 1, 1, 0, 0, 0,
  1, 1, 0, 0, 1, 1, 0,
  0, 0, 1, 1, 0, 0, 0,
  1, 1, 0, 0, 1, 1, 0,
  0, 0, 1, 1, 0, 0, 0,
  1, 1, 0, 0, 1, 1, 0,
  0, 0, 1, 1, 0, 0, 0,
  1, 1, 0, 0, 1, 1, 0,
  0, 0, 1, 1, 0, 0, 0,
  1, 1, 0, 0, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 3 */
  0, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 1, 1, 0, 0,
  1, 1, 0, 1, 1, 0, 0,
  1, 1, 1, 1, 1, 0, 0,
  1, 1, 0, 1, 1, 0, 0,
  1, 1, 0, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 1, 1, 0,
  0, 0, 0, 1, 1, 0, 0,
  0, 0, 0, 1, 1, 0, 0,
  0, 0, 0, 1, 1, 0, 0,
  0, 0, 0, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 4 */
  0, 0, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0,
  1, 1, 1, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 1, 1, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 1, 1, 1, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 5 */
  0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 1, 0, 0,
  0, 0, 1, 1, 0, 1, 0,
  0, 0, 1, 1, 1, 0, 0,
  0, 0, 1, 1, 0, 1, 0,
  0, 0, 1, 1, 0, 1, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 6 */
  0, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 1, 1, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 1, 1, 1, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 7 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 0, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  0, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 8 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  1, 1, 1, 1, 1, 1, 0,
  1, 1, 1, 1, 1, 1, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 1, 0,
  1, 1, 1, 1, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 9 */
  0, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 1, 0, 1, 1, 0,
  1, 1, 1, 1, 1, 1, 0,
  1, 1, 0, 1, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 1, 1, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 10 */
  0, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  0, 1, 0, 0, 1, 0, 0,
  0, 1, 1, 1, 1, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 1, 1, 0,
  0, 0, 0, 1, 1, 0, 0,
  0, 0, 0, 1, 1, 0, 0,
  0, 0, 0, 1, 1, 0, 0,
  0, 0, 0, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 11 */
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  1, 1, 1, 1, 0, 0, 0,
  1, 1, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 12 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 0, 0, 0,
  1, 1, 1, 1, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0,

/* Char 13 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 1, 1, 1,
  0, 0, 1, 1, 1, 1, 1,
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0,

/* Char 14 */
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 1, 1, 1, 1, 1,
  0, 0, 1, 1, 1, 1, 1,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 15 */
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1,
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0,

/* Char 16 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 17 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 18 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 19 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 20 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1,
  0, 0, 0, 0, 0, 0, 0,

/* Char 21 */
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 1, 1, 1, 1, 1,
  0, 0, 1, 1, 1, 1, 1,
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0,

/* Char 22 */
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  1, 1, 1, 1, 0, 0, 0,
  1, 1, 1, 1, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0,

/* Char 23 */
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 24 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1,
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0,

/* Char 25 */
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0,

/* Char 26 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 1, 1, 0,
  0, 0, 0, 1, 1, 0, 0,
  0, 1, 1, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0,
  0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0,
  0, 0, 0, 0, 1, 1, 0,
  1, 1, 1, 1, 1, 1, 0,
  1, 1, 1, 1, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 27 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0,
  0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0,
  0, 0, 0, 0, 1, 1, 0,
  0, 0, 0, 1, 1, 0, 0,
  0, 1, 1, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 1, 0,
  1, 1, 1, 1, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 28 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 1, 0,
  0, 1, 1, 0, 1, 1, 0,
  0, 1, 1, 0, 1, 1, 0,
  0, 1, 1, 0, 1, 1, 0,
  1, 1, 1, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 29 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 1, 0,
  0, 0, 0, 0, 1, 1, 0,
  1, 1, 1, 1, 1, 1, 0,
  1, 1, 1, 1, 1, 1, 0,
  0, 0, 1, 1, 0, 0, 0,
  1, 1, 1, 1, 1, 1, 0,
  1, 1, 1, 1, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 0,
  1, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 30 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 1, 0, 0,
  0, 1, 1, 0, 1, 1, 0,
  0, 1, 1, 0, 0, 0, 0,
  0, 1, 1, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 0, 0,
  0, 1, 1, 0, 0, 0, 0,
  0, 1, 1, 0, 0, 0, 0,
  0, 1, 1, 0, 1, 1, 0,
  1, 0, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 31 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 32 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 33 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 34 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 0, 1, 1, 0,
  0, 1, 1, 0, 1, 1, 0,
  0, 1, 1, 0, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 35 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 0, 1, 0, 0,
  0, 0, 1, 0, 1, 0, 0,
  0, 1, 1, 1, 1, 1, 0,
  0, 1, 1, 1, 1, 1, 0,
  0, 0, 1, 0, 1, 0, 0,
  0, 1, 1, 1, 1, 1, 0,
  0, 1, 1, 1, 1, 1, 0,
  0, 0, 1, 0, 1, 0, 0,
  0, 0, 1, 0, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 36 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 1, 1, 1, 1, 0, 0,
  1, 0, 1, 1, 0, 1, 0,
  1, 0, 1, 1, 0, 0, 0,
  0, 1, 1, 1, 1, 0, 0,
  0, 0, 1, 1, 0, 1, 0,
  1, 0, 1, 1, 0, 1, 0,
  0, 1, 1, 1, 1, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 37 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  1, 1, 1, 0, 0, 1, 0,
  1, 0, 1, 0, 1, 1, 0,
  1, 1, 1, 0, 1, 0, 0,
  0, 0, 0, 1, 1, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 1, 1, 0, 0, 0, 0,
  0, 1, 0, 1, 1, 1, 0,
  1, 1, 0, 1, 0, 1, 0,
  1, 0, 0, 1, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 38 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 0, 0, 0,
  1, 1, 0, 1, 1, 0, 0,
  1, 1, 0, 1, 1, 0, 0,
  0, 1, 1, 1, 0, 0, 0,
  1, 1, 0, 1, 0, 1, 0,
  1, 1, 0, 1, 1, 1, 0,
  1, 1, 0, 1, 1, 0, 0,
  0, 1, 1, 1, 0, 1, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 39 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 1, 0, 0,
  0, 0, 1, 1, 1, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 40 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 1, 1, 0, 0, 0, 0,
  0, 1, 1, 0, 0, 0, 0,
  0, 1, 1, 0, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 41 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 0, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0,
  0, 0, 0, 1, 1, 0, 0,
  0, 0, 0, 1, 1, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 42 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 1, 0, 0, 1, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  1, 1, 1, 1, 1, 1, 0,
  1, 1, 1, 1, 1, 1, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 1, 0, 0, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 43 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  1, 1, 1, 1, 1, 1, 0,
  1, 1, 1, 1, 1, 1, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 44 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 1, 0, 0,
  0, 0, 1, 1, 1, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 45 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 1, 0,
  1, 1, 1, 1, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 46 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 1, 1, 1, 1, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 47 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 1, 1, 0,
  0, 0, 0, 0, 1, 1, 0,
  0, 0, 0, 1, 1, 0, 0,
  0, 0, 0, 1, 1, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 1, 1, 0, 0, 0, 0,
  0, 1, 1, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 48 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 0, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 1, 1, 1, 0,
  1, 1, 1, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  0, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 49 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 1, 1, 1, 0, 0, 0,
  1, 0, 1, 1, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  1, 1, 1, 1, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 50 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 0, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  0, 0, 0, 0, 1, 1, 0,
  0, 0, 1, 1, 1, 0, 0,
  0, 1, 1, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 51 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 0, 0,
  1, 1, 0, 0, 1, 1, 0,
  0, 0, 0, 0, 1, 1, 0,
  0, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 1, 1, 0,
  0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  0, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 52 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 1, 1, 0,
  0, 0, 0, 1, 1, 1, 0,
  0, 0, 1, 1, 1, 1, 0,
  0, 1, 1, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 1, 1, 1, 1, 0,
  0, 0, 0, 0, 1, 1, 0,
  0, 0, 0, 0, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 53 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 0, 0,
  1, 1, 0, 0, 1, 1, 0,
  0, 0, 0, 0, 1, 1, 0,
  0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  0, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 54 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 0, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 0, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  0, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 55 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 1, 0,
  0, 0, 0, 0, 1, 1, 0,
  0, 0, 0, 1, 1, 0, 0,
  0, 0, 0, 1, 1, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 1, 1, 0, 0, 0, 0,
  0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 56 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 0, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  0, 1, 1, 1, 1, 0, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  0, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 57 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 0, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  0, 1, 1, 1, 1, 1, 0,
  0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  0, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 58 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 1, 1, 1, 1, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 1, 1, 1, 1, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 59 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 1, 1, 1, 1, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 1, 0, 0,
  0, 0, 1, 1, 1, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 60 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 1, 1, 0,
  0, 0, 0, 1, 1, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 1, 1, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0,
  0, 1, 1, 0, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0,
  0, 0, 0, 0, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 61 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 1, 0,
  1, 1, 1, 1, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 1, 0,
  1, 1, 1, 1, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 62 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0,
  0, 1, 1, 0, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0,
  0, 0, 0, 0, 1, 1, 0,
  0, 0, 0, 1, 1, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 1, 1, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 63 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 0, 0,
  1, 1, 0, 0, 1, 1, 0,
  0, 0, 0, 0, 1, 1, 0,
  0, 0, 1, 1, 1, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 64 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 0, 0,
  1, 0, 0, 0, 1, 1, 0,
  1, 0, 1, 1, 1, 1, 0,
  1, 0, 1, 0, 1, 1, 0,
  1, 0, 1, 1, 1, 1, 0,
  1, 0, 0, 0, 0, 0, 0,
  1, 0, 0, 0, 1, 1, 0,
  0, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 65 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 0, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 1, 1, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 66 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 0, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 1, 1, 1, 0, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 67 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 0, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 1, 1, 0,
  0, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 68 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 0, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 69 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 0, 0,
  1, 1, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 70 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 0, 0,
  1, 1, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 71 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 0, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0,
  1, 1, 0, 1, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  0, 1, 1, 1, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 72 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 1, 1, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 73 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 1, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  1, 1, 1, 1, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 74 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 1, 1, 0,
  0, 0, 0, 0, 1, 1, 0,
  0, 0, 0, 0, 1, 1, 0,
  0, 0, 0, 0, 1, 1, 0,
  0, 0, 0, 0, 1, 1, 0,
  0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  0, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 75 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 1, 1, 0, 0,
  1, 1, 1, 1, 0, 0, 0,
  1, 1, 1, 0, 0, 0, 0,
  1, 1, 1, 0, 0, 0, 0,
  1, 1, 1, 1, 0, 0, 0,
  1, 1, 0, 1, 1, 0, 0,
  1, 1, 0, 0, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 76 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 77 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  1, 0, 0, 0, 0, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 1, 1, 1, 1, 0,
  1, 1, 1, 1, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 78 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 1, 0, 1, 1, 0,
  1, 1, 1, 0, 1, 1, 0,
  1, 1, 1, 1, 1, 1, 0,
  1, 1, 0, 1, 1, 1, 0,
  1, 1, 0, 1, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 79 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 0, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  0, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 80 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 0, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 1, 1, 1, 0, 0,
  1, 1, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 81 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 0, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 1, 0, 1, 1, 0,
  1, 1, 0, 1, 1, 1, 0,
  0, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 82 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 0, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 1, 1, 1, 0, 0,
  1, 1, 1, 1, 0, 0, 0,
  1, 1, 0, 1, 1, 0, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 83 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 0, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 1, 1, 0,
  0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  0, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 84 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 1, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 85 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  0, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 86 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  0, 1, 0, 0, 1, 0, 0,
  0, 1, 0, 0, 1, 0, 0,
  0, 1, 1, 1, 1, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 87 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 1, 1, 1, 1, 0,
  1, 1, 1, 1, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 0, 0, 0, 0, 1, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 88 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  1, 0, 0, 0, 0, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  0, 1, 0, 0, 1, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 1, 1, 1, 1, 0, 0,
  0, 1, 0, 0, 1, 0, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 0, 0, 0, 0, 1, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 89 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  0, 1, 1, 1, 1, 0, 0,
  0, 1, 1, 1, 1, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 90 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 1, 0,
  0, 0, 0, 0, 1, 1, 0,
  0, 0, 0, 1, 1, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 1, 1, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 91 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 0, 0,
  0, 1, 1, 0, 0, 0, 0,
  0, 1, 1, 0, 0, 0, 0,
  0, 1, 1, 0, 0, 0, 0,
  0, 1, 1, 0, 0, 0, 0,
  0, 1, 1, 0, 0, 0, 0,
  0, 1, 1, 0, 0, 0, 0,
  0, 1, 1, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 92 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0,
  0, 1, 1, 0, 0, 0, 0,
  0, 1, 1, 0, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0,
  0, 0, 0, 1, 1, 0, 0,
  0, 0, 0, 0, 1, 1, 0,
  0, 0, 0, 0, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 93 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 1, 1, 0, 0,
  0, 0, 0, 1, 1, 0, 0,
  0, 0, 0, 1, 1, 0, 0,
  0, 0, 0, 1, 1, 0, 0,
  0, 0, 0, 1, 1, 0, 0,
  0, 0, 0, 1, 1, 0, 0,
  0, 0, 0, 1, 1, 0, 0,
  0, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 94 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 1, 1, 1, 1, 0, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 0, 0, 0, 0, 1, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 95 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 1, 0,
  1, 1, 1, 1, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 96 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 0, 0, 0,
  0, 1, 1, 1, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 97 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 1, 1, 0,
  0, 1, 1, 1, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  0, 1, 1, 1, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 98 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 0, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 99 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 0, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 1, 1, 0,
  0, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 100 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 1, 1, 0,
  0, 0, 0, 0, 1, 1, 0,
  0, 0, 0, 0, 1, 1, 0,
  0, 1, 1, 1, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  0, 1, 1, 1, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 101 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 0, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 1, 1, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 1, 1, 0,
  0, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 102 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 1, 0, 0,
  0, 1, 1, 0, 1, 1, 0,
  0, 1, 1, 0, 0, 0, 0,
  0, 1, 1, 0, 0, 0, 0,
  1, 1, 1, 1, 0, 0, 0,
  0, 1, 1, 0, 0, 0, 0,
  0, 1, 1, 0, 0, 0, 0,
  0, 1, 1, 0, 0, 0, 0,
  0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 103 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 0, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  0, 1, 1, 1, 1, 0, 0,
  1, 1, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 0, 0,
  1, 1, 0, 0, 1, 1, 0,
  0, 1, 1, 1, 1, 0, 0,

/* Char 104 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 0, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 105 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  1, 1, 1, 1, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 106 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 1, 1, 0,
  0, 0, 0, 0, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 1, 1, 0,
  0, 0, 0, 0, 1, 1, 0,
  0, 0, 0, 0, 1, 1, 0,
  0, 0, 0, 0, 1, 1, 0,
  0, 0, 0, 0, 1, 1, 0,
  0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  0, 1, 1, 1, 1, 0, 0,

/* Char 107 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 1, 1, 0, 0,
  1, 1, 1, 1, 0, 0, 0,
  1, 1, 1, 1, 0, 0, 0,
  1, 1, 0, 1, 1, 0, 0,
  1, 1, 0, 0, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 108 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  1, 1, 1, 1, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 109 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 1, 1, 0, 0,
  1, 1, 1, 1, 1, 1, 0,
  1, 1, 1, 1, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 110 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 0, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 111 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 0, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  0, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 112 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 0, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 1, 1, 1, 0, 0,
  1, 1, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0,

/* Char 113 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  0, 1, 1, 1, 1, 1, 0,
  0, 0, 0, 0, 1, 1, 0,
  0, 0, 0, 0, 1, 1, 0,
  0, 0, 0, 0, 1, 1, 0,

/* Char 114 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 0, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 115 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 0, 0,
  1, 1, 0, 0, 1, 1, 0,
  0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0,
  1, 1, 0, 0, 1, 1, 0,
  0, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 116 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 0, 0, 0, 0,
  0, 1, 1, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 0, 0,
  0, 1, 1, 0, 0, 0, 0,
  0, 1, 1, 0, 0, 0, 0,
  0, 1, 1, 0, 0, 0, 0,
  0, 1, 1, 0, 1, 1, 0,
  0, 0, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 117 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  0, 1, 1, 1, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 118 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  0, 1, 1, 1, 1, 0, 0,
  0, 1, 1, 1, 1, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 119 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 1, 1, 1, 1, 0,
  1, 1, 1, 1, 1, 1, 0,
  0, 1, 0, 0, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 120 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  0, 1, 1, 1, 1, 0, 0,
  0, 1, 1, 1, 1, 0, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 121 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  0, 1, 1, 1, 1, 1, 0,
  0, 0, 0, 0, 1, 1, 0,
  0, 0, 0, 0, 1, 1, 0,
  0, 1, 1, 1, 1, 0, 0,

/* Char 122 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 1, 0,
  0, 0, 0, 0, 1, 1, 0,
  0, 0, 0, 1, 1, 0, 0,
  0, 1, 1, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 123 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 1, 0, 0,
  0, 1, 1, 0, 0, 0, 0,
  0, 1, 1, 0, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 1, 1, 0, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 1, 1, 0, 0, 0, 0,
  0, 1, 1, 0, 0, 0, 0,
  0, 0, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 124 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 125 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0,
  0, 0, 0, 1, 1, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0,
  0, 0, 0, 1, 1, 0, 0,
  0, 1, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 126 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 0, 0, 1, 0,
  1, 1, 1, 1, 1, 1, 0,
  1, 0, 0, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 127 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 128 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 129 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 130 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 131 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 132 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 133 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 134 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 135 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 136 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 137 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 138 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 139 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 140 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 141 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 142 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 143 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 144 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 145 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 146 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 147 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 148 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 149 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 150 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 151 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 152 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 153 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 154 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 155 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 156 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 157 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 158 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 159 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 160 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 161 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 0, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 1, 1, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  0, 0, 0, 1, 1, 0, 0,
  0, 0, 0, 0, 1, 1, 0,

/* Char 162 */
  0, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 1, 1, 0,
  0, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 163 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 0, 1, 0, 0,
  0, 1, 1, 1, 1, 0, 0,
  0, 1, 1, 1, 0, 0, 0,
  0, 1, 1, 0, 0, 0, 0,
  1, 1, 1, 0, 0, 0, 0,
  1, 1, 1, 0, 0, 0, 0,
  0, 1, 1, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 164 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 1, 1, 1, 1, 0,
  0, 1, 0, 0, 1, 0, 0,
  0, 1, 0, 0, 1, 0, 0,
  1, 1, 1, 1, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 165 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 1, 1, 0, 0,
  1, 1, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 166 */
  0, 0, 0, 1, 1, 1, 0,
  0, 1, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 0, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 1, 1, 0,
  0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  0, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 167 */
  0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 0, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 0, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  0, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  0, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 168 */
  0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 0, 1, 1, 0,
  0, 1, 1, 0, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 169 */
  0, 1, 1, 0, 1, 1, 0,
  0, 0, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 0, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 1, 1, 0,
  0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  0, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 170 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 0, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 1, 1, 0,
  0, 0, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  0, 1, 1, 1, 1, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 1, 1, 0, 0, 0, 0,

/* Char 171 */
  0, 1, 1, 0, 1, 1, 0,
  0, 0, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 1, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 172 */
  0, 0, 0, 1, 1, 1, 0,
  0, 1, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 1, 0,
  0, 0, 0, 0, 1, 1, 0,
  0, 0, 0, 1, 1, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 1, 1, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 173 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 1, 0,
  0, 1, 1, 1, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 174 */
  0, 1, 1, 0, 1, 1, 0,
  0, 0, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 1, 0,
  0, 0, 0, 0, 1, 1, 0,
  0, 0, 0, 1, 1, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 1, 1, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 175 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 1, 0,
  0, 0, 0, 0, 1, 1, 0,
  0, 0, 0, 1, 1, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 1, 1, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 176 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 0, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  0, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 177 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 1, 1, 0,
  0, 1, 1, 1, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  0, 1, 1, 1, 1, 1, 0,
  0, 0, 0, 1, 1, 0, 0,
  0, 0, 0, 0, 1, 1, 0,

/* Char 178 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 0, 1, 1, 1, 0,

/* Char 179 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 0, 0, 0,
  0, 0, 1, 1, 0, 1, 0,
  0, 0, 1, 1, 1, 1, 0,
  0, 0, 1, 1, 1, 0, 0,
  0, 1, 1, 1, 0, 0, 0,
  1, 1, 1, 1, 0, 0, 0,
  1, 0, 1, 1, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  1, 1, 1, 1, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 180 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 1, 0,
  0, 1, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 181 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 1, 0,
  1, 1, 1, 0, 1, 1, 0,
  0, 1, 1, 0, 1, 0, 0,
  0, 1, 1, 0, 0, 0, 0,
  0, 1, 1, 0, 0, 0, 0,
  0, 1, 1, 0, 0, 0, 0,
  0, 1, 1, 0, 0, 0, 0,
  0, 1, 1, 0, 0, 0, 0,
  0, 1, 1, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 182 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 1, 0,
  0, 1, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 0, 0,
  1, 1, 0, 0, 1, 1, 0,
  0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0,
  1, 1, 0, 0, 1, 1, 0,
  0, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 183 */
  0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 0, 1, 1, 0,
  0, 0, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 184 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0,
  0, 1, 1, 1, 0, 0, 0,

/* Char 185 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 0, 1, 1, 0,
  0, 0, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 0, 0,
  1, 1, 0, 0, 1, 1, 0,
  0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0,
  1, 1, 0, 0, 1, 1, 0,
  0, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 186 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 0, 0,
  1, 1, 0, 0, 1, 1, 0,
  0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0,
  1, 1, 0, 0, 1, 1, 0,
  0, 1, 1, 1, 1, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 1, 1, 0, 0, 0, 0,

/* Char 187 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 1, 0,
  0, 0, 0, 0, 1, 1, 0,
  0, 1, 1, 0, 1, 0, 0,
  0, 1, 1, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 0, 0,
  0, 1, 1, 0, 0, 0, 0,
  0, 1, 1, 0, 0, 0, 0,
  0, 1, 1, 0, 0, 0, 0,
  0, 1, 1, 0, 1, 1, 0,
  0, 0, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 188 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 1, 0,
  0, 1, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 1, 0,
  0, 0, 0, 0, 1, 1, 0,
  0, 0, 0, 1, 1, 0, 0,
  0, 1, 1, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 189 */
  0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 0, 0, 1, 1,
  1, 1, 0, 0, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 190 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 0, 1, 1, 0,
  0, 0, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 1, 0,
  0, 0, 0, 0, 1, 1, 0,
  0, 0, 0, 1, 1, 0, 0,
  0, 1, 1, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 191 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 1, 0,
  0, 0, 0, 0, 1, 1, 0,
  0, 0, 0, 1, 1, 0, 0,
  0, 1, 1, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 192 */
  0, 0, 0, 1, 1, 1, 0,
  0, 1, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 0, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 1, 1, 1, 0, 0,
  1, 1, 1, 1, 0, 0, 0,
  1, 1, 0, 1, 1, 0, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 193 */
  0, 0, 0, 1, 1, 1, 0,
  0, 1, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 0, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 1, 1, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 194 */
  0, 0, 1, 1, 0, 0, 0,
  1, 1, 0, 0, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 0, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 1, 1, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 195 */
  1, 1, 0, 0, 1, 1, 0,
  0, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 0, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 1, 1, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 196 */
  0, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 0, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 1, 1, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 197 */
  0, 0, 0, 1, 1, 1, 0,
  0, 1, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 198 */
  0, 0, 0, 1, 1, 1, 0,
  0, 1, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 0, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 1, 1, 0,
  0, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 199 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 0, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 1, 1, 0,
  0, 1, 1, 1, 1, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 1, 1, 0, 0, 0, 0,

/* Char 200 */
  0, 1, 1, 0, 1, 1, 0,
  0, 0, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 0, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 1, 1, 0,
  0, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 201 */
  0, 0, 0, 1, 1, 1, 0,
  0, 1, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 0, 0,
  1, 1, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 202 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 0, 0,
  1, 1, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 1, 0,
  0, 0, 0, 1, 1, 0, 0,
  0, 0, 0, 0, 1, 1, 0,

/* Char 203 */
  0, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 0, 0,
  1, 1, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 204 */
  0, 1, 1, 0, 1, 1, 0,
  0, 0, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 0, 0,
  1, 1, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 205 */
  0, 0, 0, 1, 1, 1, 0,
  0, 1, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 1, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  1, 1, 1, 1, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 206 */
  0, 1, 1, 1, 1, 0, 0,
  1, 1, 0, 0, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 1, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  1, 1, 1, 1, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 207 */
  0, 1, 1, 0, 1, 1, 0,
  0, 0, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 0, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 208 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 0, 0,
  0, 1, 1, 0, 1, 1, 0,
  0, 1, 1, 0, 1, 1, 0,
  1, 1, 1, 0, 1, 1, 0,
  0, 1, 1, 0, 1, 1, 0,
  0, 1, 1, 0, 1, 1, 0,
  0, 1, 1, 0, 1, 1, 0,
  1, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 209 */
  0, 0, 0, 1, 1, 1, 0,
  0, 1, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 1, 0, 1, 1, 0,
  1, 1, 1, 0, 1, 1, 0,
  1, 1, 1, 1, 1, 1, 0,
  1, 1, 0, 1, 1, 1, 0,
  1, 1, 0, 1, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 210 */
  0, 1, 1, 0, 1, 1, 0,
  0, 0, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 1, 0, 1, 1, 0,
  1, 1, 1, 0, 1, 1, 0,
  1, 1, 1, 1, 1, 1, 0,
  1, 1, 0, 1, 1, 1, 0,
  1, 1, 0, 1, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 211 */
  0, 0, 0, 1, 1, 1, 0,
  0, 1, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 0, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  0, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 212 */
  0, 1, 1, 1, 1, 0, 0,
  1, 1, 0, 0, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 0, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  0, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 213 */
  0, 1, 1, 0, 0, 1, 1,
  1, 1, 0, 0, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 0, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  0, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 214 */
  0, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 0, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  0, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 215 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 1, 1, 0,
  0, 1, 1, 1, 1, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 1, 1, 1, 1, 0, 0,
  1, 1, 0, 0, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 216 */
  0, 1, 1, 0, 1, 1, 0,
  0, 0, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 0, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 1, 1, 1, 0, 0,
  1, 1, 1, 1, 0, 0, 0,
  1, 1, 0, 1, 1, 0, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 217 */
  0, 0, 1, 1, 0, 0, 0,
  0, 1, 0, 0, 1, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  0, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 218 */
  0, 0, 0, 1, 1, 1, 0,
  0, 1, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  0, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 219 */
  0, 1, 1, 0, 0, 1, 1,
  1, 1, 0, 0, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  0, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 220 */
  0, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  0, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 221 */
  0, 0, 0, 1, 1, 1, 0,
  0, 1, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  0, 1, 1, 1, 1, 0, 0,
  0, 1, 1, 1, 1, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 222 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 1, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0,
  0, 0, 1, 1, 0, 0, 0,

/* Char 223 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 0, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 1, 1, 1, 0, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 1, 0, 1, 1, 0,
  1, 1, 0, 1, 1, 0, 0,
  1, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 224 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 1, 0,
  0, 1, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 0, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 225 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 1, 0,
  0, 1, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 1, 1, 0,
  0, 1, 1, 1, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  0, 1, 1, 1, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 226 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 1, 0, 0,
  0, 1, 1, 0, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 1, 1, 0,
  0, 1, 1, 1, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  0, 1, 1, 1, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 227 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 1, 1, 0,
  0, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 1, 1, 0,
  0, 1, 1, 1, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  0, 1, 1, 1, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 228 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 0, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 1, 1, 0,
  0, 1, 1, 1, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  0, 1, 1, 1, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 229 */
  0, 0, 0, 1, 1, 1, 0,
  0, 1, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  1, 1, 1, 1, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 230 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 1, 0,
  0, 1, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 0, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 1, 1, 0,
  0, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 231 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 0, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 1, 1, 0,
  0, 1, 1, 1, 1, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 1, 1, 0, 0, 0, 0,

/* Char 232 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 0, 1, 1, 0,
  0, 0, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 0, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 1, 1, 0,
  0, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 233 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 1, 0,
  0, 1, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 0, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 1, 1, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 1, 1, 0,
  0, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 234 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 0, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 1, 1, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 1, 1, 0,
  0, 1, 1, 1, 1, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0,

/* Char 235 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 0, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 1, 1, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 1, 1, 0,
  0, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 236 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 0, 1, 1, 0,
  0, 0, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 0, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 1, 1, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 1, 1, 0,
  0, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 237 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 1, 0,
  0, 1, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  1, 1, 1, 1, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 238 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 0, 0, 0,
  1, 1, 0, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  1, 1, 1, 1, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 239 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 1, 1,
  0, 0, 0, 1, 1, 0, 1,
  0, 0, 0, 1, 1, 1, 0,
  0, 0, 0, 1, 1, 0, 0,
  0, 1, 1, 1, 1, 0, 0,
  1, 1, 0, 1, 1, 0, 0,
  1, 1, 0, 1, 1, 0, 0,
  1, 1, 0, 1, 1, 0, 0,
  1, 1, 0, 1, 1, 0, 0,
  0, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 240 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 1, 1, 0,
  0, 0, 0, 1, 1, 1, 1,
  0, 0, 0, 0, 1, 1, 0,
  0, 1, 1, 1, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  0, 1, 1, 1, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 241 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 1, 0,
  0, 1, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 0, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 242 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 0, 1, 1, 0,
  0, 0, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 0, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 243 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 1, 0,
  0, 1, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 0, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  0, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 244 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 1, 0, 0,
  0, 1, 1, 0, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 0, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  0, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 245 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 0, 0, 1, 1,
  1, 1, 0, 0, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 0, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  0, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 246 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 0, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 0, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  0, 1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 247 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 248 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 0, 1, 1, 0,
  0, 0, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 0, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 249 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 1, 0, 0, 1, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  0, 1, 1, 1, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 250 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 1, 0,
  0, 1, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  0, 1, 1, 1, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 251 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 0, 0, 1, 1,
  1, 1, 0, 0, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  0, 1, 1, 1, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 252 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  0, 1, 1, 1, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,

/* Char 253 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 1, 0,
  0, 1, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 0,
  0, 1, 1, 1, 1, 1, 0,
  0, 0, 0, 0, 1, 1, 0,
  0, 0, 0, 0, 1, 1, 0,
  0, 1, 1, 1, 1, 0, 0,

/* Char 254 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 0, 0, 0, 0,
  0, 1, 1, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 0, 0,
  0, 1, 1, 0, 0, 0, 0,
  0, 1, 1, 0, 0, 0, 0,
  0, 1, 1, 0, 0, 0, 0,
  0, 1, 1, 0, 1, 1, 0,
  0, 0, 1, 1, 1, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 1, 1, 0, 0, 0, 0,

/* Char 255 */
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,


};

gdFont gdFontMediumBoldRep = {
  256,
  0,
  7,
  13,
  gdFontMediumBoldData
};

BGD_EXPORT_DATA_IMPL gdFontPtr gdFontMediumBold = &gdFontMediumBoldRep;

BGD_DECLARE(gdFontPtr)
gdFontGetMediumBold (void)
{
  return gdFontMediumBold;
}

/* This file has not been truncated. */
 71141       705718      553220      1193070199  200         0           100640      9   gdfonts.c `
/*
   This is a header file for gd font, generated using
   bdftogd version 0.5 by Jan Pazdziora, adelton@fi.muni.cz
   from bdf font
   -misc-fixed-medium-r-semicondensed-sans-12-116-75-75-c-60-iso8859-2
   at Thu Jan  8 14:13:20 1998.
   No copyright info was found in the original bdf.
 */


#include "gdfonts.h"

char gdFontSmallData[] = {
/* Char 0 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 1 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 1, 1, 1, 0, 0,
  1, 1, 1, 1, 1, 0,
  0, 1, 1, 1, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 2 */
  0, 0, 0, 0, 0, 0,
  0, 1, 0, 1, 0, 1,
  1, 0, 1, 0, 1, 0,
  0, 1, 0, 1, 0, 1,
  1, 0, 1, 0, 1, 0,
  0, 1, 0, 1, 0, 1,
  1, 0, 1, 0, 1, 0,
  0, 1, 0, 1, 0, 1,
  1, 0, 1, 0, 1, 0,
  0, 1, 0, 1, 0, 1,
  1, 0, 1, 0, 1, 0,
  0, 1, 0, 1, 0, 1,
  1, 0, 1, 0, 1, 0,

/* Char 3 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  1, 0, 1, 0, 0, 0,
  1, 0, 1, 0, 0, 0,
  1, 1, 1, 0, 0, 0,
  1, 0, 1, 0, 0, 0,
  1, 0, 1, 0, 0, 0,
  0, 0, 1, 1, 1, 0,
  0, 0, 0, 1, 0, 0,
  0, 0, 0, 1, 0, 0,
  0, 0, 0, 1, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 4 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  1, 1, 1, 0, 0, 0,
  1, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0,
  1, 0, 0, 0, 0, 0,
  1, 0, 1, 1, 1, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 1, 1, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 5 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 0, 0,
  1, 0, 0, 0, 0, 0,
  1, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 0, 0,
  0, 1, 1, 1, 0, 0,
  0, 1, 0, 0, 1, 0,
  0, 1, 1, 1, 0, 0,
  0, 1, 0, 1, 0, 0,
  0, 1, 0, 0, 1, 0,
  0, 0, 0, 0, 0, 0,

/* Char 6 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  1, 0, 0, 0, 0, 0,
  1, 0, 0, 0, 0, 0,
  1, 0, 0, 0, 0, 0,
  1, 1, 1, 0, 0, 0,
  0, 0, 1, 1, 1, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 1, 1, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 7 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 1, 1, 0, 0, 0,
  1, 0, 0, 1, 0, 0,
  1, 0, 0, 1, 0, 0,
  0, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 8 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  1, 1, 1, 1, 1, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 9 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  1, 0, 0, 0, 1, 0,
  1, 1, 0, 0, 1, 0,
  1, 0, 1, 0, 1, 0,
  1, 0, 0, 1, 1, 0,
  1, 0, 0, 0, 1, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 1, 1, 1, 1,
  0, 0, 0, 0, 0, 0,

/* Char 10 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 1, 0,
  0, 1, 0, 1, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 11 */
  0, 0, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  1, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 12 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  1, 1, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 0,

/* Char 13 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 1, 1,
  0, 0, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 0,

/* Char 14 */
  0, 0, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 1, 1, 1, 1,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 15 */
  0, 0, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  1, 1, 1, 1, 1, 1,
  0, 0, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 0,

/* Char 16 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 1,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 17 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 1,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 18 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 1,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 19 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 1,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 20 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 1,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 21 */
  0, 0, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 1, 1, 1, 1,
  0, 0, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 0,

/* Char 22 */
  0, 0, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  1, 1, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 0,

/* Char 23 */
  0, 0, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  1, 1, 1, 1, 1, 1,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 24 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 1,
  0, 0, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 0,

/* Char 25 */
  0, 0, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 0,

/* Char 26 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 1, 0,
  0, 0, 0, 1, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 1, 0, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 0, 1, 0, 0,
  0, 0, 0, 0, 1, 0,
  0, 1, 1, 1, 1, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 27 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  1, 0, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 0, 1, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 1, 0, 0, 0, 0,
  1, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 28 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 0,
  0, 1, 0, 1, 0, 0,
  0, 1, 0, 1, 0, 0,
  0, 1, 0, 1, 0, 0,
  0, 1, 0, 1, 0, 0,
  1, 0, 0, 1, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 29 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 1, 0,
  1, 1, 1, 1, 1, 0,
  0, 0, 1, 0, 0, 0,
  1, 1, 1, 1, 1, 0,
  1, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 30 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 0, 0,
  0, 1, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0,
  1, 1, 1, 0, 0, 0,
  0, 1, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0,
  0, 1, 0, 0, 1, 0,
  1, 0, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 31 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 32 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 33 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 34 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 1, 0, 1, 0, 0,
  0, 1, 0, 1, 0, 0,
  0, 1, 0, 1, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 35 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 1, 0, 1, 0, 0,
  0, 1, 0, 1, 0, 0,
  1, 1, 1, 1, 1, 0,
  0, 1, 0, 1, 0, 0,
  1, 1, 1, 1, 1, 0,
  0, 1, 0, 1, 0, 0,
  0, 1, 0, 1, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 36 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 1, 1, 1, 1, 0,
  1, 0, 1, 0, 0, 0,
  1, 0, 1, 0, 0, 0,
  0, 1, 1, 1, 0, 0,
  0, 0, 1, 0, 1, 0,
  0, 0, 1, 0, 1, 0,
  1, 1, 1, 1, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 37 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 1, 0, 0, 1, 0,
  1, 0, 1, 0, 1, 0,
  0, 1, 0, 1, 0, 0,
  0, 0, 0, 1, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 1, 0, 0, 0, 0,
  0, 1, 0, 1, 0, 0,
  1, 0, 1, 0, 1, 0,
  1, 0, 0, 1, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 38 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0,
  1, 0, 1, 0, 0, 0,
  1, 0, 1, 0, 0, 0,
  0, 1, 0, 0, 0, 0,
  1, 0, 1, 0, 0, 0,
  1, 0, 0, 1, 1, 0,
  1, 0, 0, 1, 0, 0,
  0, 1, 1, 0, 1, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 39 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 1, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 40 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 1, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 0, 1, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 41 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 0, 1, 0, 0,
  0, 0, 0, 1, 0, 0,
  0, 0, 0, 1, 0, 0,
  0, 0, 0, 1, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 1, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 42 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  1, 0, 1, 0, 1, 0,
  0, 1, 1, 1, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 1, 1, 1, 0, 0,
  1, 0, 1, 0, 1, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 43 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  1, 1, 1, 1, 1, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 44 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 1, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 45 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 46 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 0, 0,
  0, 0, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 47 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 1, 0,
  0, 0, 0, 0, 1, 0,
  0, 0, 0, 1, 0, 0,
  0, 0, 0, 1, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 1, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0,
  1, 0, 0, 0, 0, 0,
  1, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 48 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 1, 0, 1, 0, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 1, 0,
  0, 1, 0, 1, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 49 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 1, 1, 0, 0, 0,
  1, 0, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  1, 1, 1, 1, 1, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 50 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 0, 0,
  1, 0, 0, 0, 1, 0,
  0, 0, 0, 0, 1, 0,
  0, 0, 0, 1, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 1, 0, 0, 0, 0,
  1, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 51 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 0, 0,
  1, 0, 0, 0, 1, 0,
  0, 0, 0, 0, 1, 0,
  0, 0, 1, 1, 0, 0,
  0, 0, 0, 0, 1, 0,
  0, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 1, 0,
  0, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 52 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0,
  0, 0, 1, 1, 0, 0,
  0, 1, 0, 1, 0, 0,
  1, 0, 0, 1, 0, 0,
  1, 0, 0, 1, 0, 0,
  1, 1, 1, 1, 1, 0,
  0, 0, 0, 1, 0, 0,
  0, 0, 0, 1, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 53 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 0,
  1, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 0, 0,
  1, 0, 0, 0, 1, 0,
  0, 0, 0, 0, 1, 0,
  0, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 1, 0,
  0, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 54 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 1, 0,
  0, 1, 0, 0, 0, 0,
  1, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 0, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 1, 0,
  0, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 55 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 0,
  0, 0, 0, 0, 1, 0,
  0, 0, 0, 1, 0, 0,
  0, 0, 0, 1, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 1, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 56 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 0, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 1, 0,
  0, 1, 1, 1, 0, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 1, 0,
  0, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 57 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 0, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 1, 0,
  0, 1, 1, 1, 1, 0,
  0, 0, 0, 0, 1, 0,
  0, 0, 0, 1, 0, 0,
  1, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 58 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 0, 0,
  0, 0, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 0, 0,
  0, 0, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 59 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 0, 0,
  0, 0, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 1, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 60 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 1, 0,
  0, 0, 0, 1, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 1, 0, 0, 0, 0,
  1, 0, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 0, 1, 0, 0,
  0, 0, 0, 0, 1, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 61 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 62 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  1, 0, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 0, 1, 0, 0,
  0, 0, 0, 0, 1, 0,
  0, 0, 0, 1, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 1, 0, 0, 0, 0,
  1, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 63 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 0, 0,
  1, 0, 0, 0, 1, 0,
  0, 0, 0, 0, 1, 0,
  0, 0, 0, 1, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 64 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 0, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 1, 1, 0,
  1, 0, 1, 0, 1, 0,
  1, 0, 1, 0, 1, 0,
  1, 0, 1, 1, 0, 0,
  1, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 65 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 1, 0, 1, 0, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 1, 0,
  1, 1, 1, 1, 1, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 1, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 66 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 0, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 1, 0,
  1, 1, 1, 1, 0, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 1, 0,
  1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 67 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 0, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 0, 0,
  1, 0, 0, 0, 0, 0,
  1, 0, 0, 0, 0, 0,
  1, 0, 0, 0, 0, 0,
  1, 0, 0, 0, 1, 0,
  0, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 68 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 0, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 1, 0,
  1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 69 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 0,
  1, 0, 0, 0, 0, 0,
  1, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 0, 0,
  1, 0, 0, 0, 0, 0,
  1, 0, 0, 0, 0, 0,
  1, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 70 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 0,
  1, 0, 0, 0, 0, 0,
  1, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 0, 0,
  1, 0, 0, 0, 0, 0,
  1, 0, 0, 0, 0, 0,
  1, 0, 0, 0, 0, 0,
  1, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 71 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 0, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 0, 0,
  1, 0, 0, 0, 0, 0,
  1, 0, 0, 1, 1, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 1, 0,
  0, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 72 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 1, 0,
  1, 1, 1, 1, 1, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 1, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 73 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 74 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0,
  0, 0, 0, 1, 0, 0,
  0, 0, 0, 1, 0, 0,
  0, 0, 0, 1, 0, 0,
  0, 0, 0, 1, 0, 0,
  0, 0, 0, 1, 0, 0,
  1, 0, 0, 1, 0, 0,
  0, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 75 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 1, 0, 0,
  1, 0, 1, 0, 0, 0,
  1, 1, 1, 0, 0, 0,
  1, 0, 0, 1, 0, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 1, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 76 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  1, 0, 0, 0, 0, 0,
  1, 0, 0, 0, 0, 0,
  1, 0, 0, 0, 0, 0,
  1, 0, 0, 0, 0, 0,
  1, 0, 0, 0, 0, 0,
  1, 0, 0, 0, 0, 0,
  1, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 77 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  1, 0, 0, 0, 1, 0,
  1, 1, 0, 1, 1, 0,
  1, 0, 1, 0, 1, 0,
  1, 0, 1, 0, 1, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 1, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 78 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  1, 0, 0, 0, 1, 0,
  1, 1, 0, 0, 1, 0,
  1, 1, 0, 0, 1, 0,
  1, 0, 1, 0, 1, 0,
  1, 0, 1, 0, 1, 0,
  1, 0, 0, 1, 1, 0,
  1, 0, 0, 1, 1, 0,
  1, 0, 0, 0, 1, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 79 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 0, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 1, 0,
  0, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 80 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 0, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 1, 0,
  1, 1, 1, 1, 0, 0,
  1, 0, 0, 0, 0, 0,
  1, 0, 0, 0, 0, 0,
  1, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 81 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 0, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 1, 0, 1, 0,
  0, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 1, 0,
  0, 0, 0, 0, 0, 0,

/* Char 82 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 0, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 1, 0,
  1, 1, 1, 1, 0, 0,
  1, 0, 1, 0, 0, 0,
  1, 0, 0, 1, 0, 0,
  1, 0, 0, 0, 1, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 83 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 0, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 0, 0,
  0, 1, 1, 0, 0, 0,
  0, 0, 0, 1, 0, 0,
  0, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 1, 0,
  0, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 84 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 85 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 1, 0,
  0, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 86 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 1, 0,
  0, 1, 0, 1, 0, 0,
  0, 1, 0, 1, 0, 0,
  0, 1, 0, 1, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 87 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 1, 0, 1, 0,
  1, 0, 1, 0, 1, 0,
  1, 0, 1, 0, 1, 0,
  1, 0, 1, 0, 1, 0,
  1, 1, 0, 1, 1, 0,
  0, 1, 0, 1, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 88 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 1, 0,
  0, 1, 0, 1, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 1, 0, 1, 0, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 1, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 89 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 1, 0,
  0, 1, 0, 1, 0, 0,
  0, 1, 0, 1, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 90 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 0,
  0, 0, 0, 0, 1, 0,
  0, 0, 0, 1, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 1, 0, 0, 0, 0,
  1, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 91 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 0, 0,
  0, 1, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0,
  0, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 92 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  1, 0, 0, 0, 0, 0,
  1, 0, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 0, 1, 0, 0,
  0, 0, 0, 1, 0, 0,
  0, 0, 0, 0, 1, 0,
  0, 0, 0, 0, 1, 0,
  0, 0, 0, 0, 0, 0,

/* Char 93 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 0, 0,
  0, 0, 0, 1, 0, 0,
  0, 0, 0, 1, 0, 0,
  0, 0, 0, 1, 0, 0,
  0, 0, 0, 1, 0, 0,
  0, 0, 0, 1, 0, 0,
  0, 0, 0, 1, 0, 0,
  0, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 94 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 1, 0, 1, 0, 0,
  1, 0, 0, 0, 1, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 95 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 0,
  0, 0, 0, 0, 0, 0,

/* Char 96 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 1, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 0, 1, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 97 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 1, 0,
  0, 1, 1, 1, 1, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 1, 1, 0,
  0, 1, 1, 0, 1, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 98 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  1, 0, 0, 0, 0, 0,
  1, 0, 0, 0, 0, 0,
  1, 0, 1, 1, 0, 0,
  1, 1, 0, 0, 1, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 1, 0,
  1, 1, 0, 0, 1, 0,
  1, 0, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 99 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 0, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 0, 0,
  1, 0, 0, 0, 0, 0,
  1, 0, 0, 0, 1, 0,
  0, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 100 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 1, 0,
  0, 0, 0, 0, 1, 0,
  0, 1, 1, 0, 1, 0,
  1, 0, 0, 1, 1, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 1, 1, 0,
  0, 1, 1, 0, 1, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 101 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 0, 0,
  1, 0, 0, 0, 1, 0,
  1, 1, 1, 1, 1, 0,
  1, 0, 0, 0, 0, 0,
  1, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 102 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 0, 0,
  0, 1, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0,
  1, 1, 1, 1, 0, 0,
  0, 1, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 103 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 1, 0,
  0, 1, 1, 1, 0, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 1, 0,
  0, 1, 1, 1, 0, 0,
  1, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 0, 0,
  1, 0, 0, 0, 1, 0,
  0, 1, 1, 1, 0, 0,

/* Char 104 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  1, 0, 0, 0, 0, 0,
  1, 0, 0, 0, 0, 0,
  1, 0, 1, 1, 0, 0,
  1, 1, 0, 0, 1, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 1, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 105 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 1, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 106 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 0, 0,
  0, 0, 0, 1, 0, 0,
  0, 0, 0, 1, 0, 0,
  0, 0, 0, 1, 0, 0,
  0, 0, 0, 1, 0, 0,
  1, 0, 0, 1, 0, 0,
  1, 0, 0, 1, 0, 0,
  0, 1, 1, 0, 0, 0,

/* Char 107 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  1, 0, 0, 0, 0, 0,
  1, 0, 0, 0, 0, 0,
  1, 0, 0, 1, 0, 0,
  1, 0, 1, 0, 0, 0,
  1, 1, 0, 0, 0, 0,
  1, 0, 1, 0, 0, 0,
  1, 0, 0, 1, 0, 0,
  1, 0, 0, 0, 1, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 108 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 1, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 109 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  1, 1, 0, 1, 0, 0,
  1, 0, 1, 0, 1, 0,
  1, 0, 1, 0, 1, 0,
  1, 0, 1, 0, 1, 0,
  1, 0, 1, 0, 1, 0,
  1, 0, 0, 0, 1, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 110 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  1, 0, 1, 1, 0, 0,
  1, 1, 0, 0, 1, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 1, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 111 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 0, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 1, 0,
  0, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 112 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  1, 0, 1, 1, 0, 0,
  1, 1, 0, 0, 1, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 1, 0,
  1, 1, 0, 0, 1, 0,
  1, 0, 1, 1, 0, 0,
  1, 0, 0, 0, 0, 0,
  1, 0, 0, 0, 0, 0,

/* Char 113 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 1, 1, 0, 1, 0,
  1, 0, 0, 1, 1, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 1, 1, 0,
  0, 1, 1, 0, 1, 0,
  0, 0, 0, 0, 1, 0,
  0, 0, 0, 0, 1, 0,

/* Char 114 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  1, 0, 1, 1, 0, 0,
  1, 1, 0, 0, 1, 0,
  1, 0, 0, 0, 0, 0,
  1, 0, 0, 0, 0, 0,
  1, 0, 0, 0, 0, 0,
  1, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 115 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 0, 0,
  1, 0, 0, 0, 1, 0,
  0, 1, 1, 0, 0, 0,
  0, 0, 0, 1, 0, 0,
  1, 0, 0, 0, 1, 0,
  0, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 116 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0,
  1, 1, 1, 1, 0, 0,
  0, 1, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0,
  0, 1, 0, 0, 1, 0,
  0, 0, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 117 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 1, 1, 0,
  0, 1, 1, 0, 1, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 118 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 1, 0,
  0, 1, 0, 1, 0, 0,
  0, 1, 0, 1, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 119 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 1, 0, 1, 0,
  1, 0, 1, 0, 1, 0,
  1, 0, 1, 0, 1, 0,
  0, 1, 0, 1, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 120 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  1, 0, 0, 0, 1, 0,
  0, 1, 0, 1, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 1, 0, 1, 0, 0,
  1, 0, 0, 0, 1, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 121 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 1, 1, 0,
  0, 1, 1, 0, 1, 0,
  0, 0, 0, 0, 1, 0,
  0, 0, 0, 1, 0, 0,
  1, 1, 1, 0, 0, 0,

/* Char 122 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 0,
  0, 0, 0, 1, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 1, 0, 0, 0, 0,
  1, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 123 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  1, 1, 0, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 0, 1, 1, 0,
  0, 0, 0, 0, 0, 0,

/* Char 124 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 125 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 0, 1, 1, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  1, 1, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 126 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 1, 0, 0, 1, 0,
  1, 0, 1, 0, 1, 0,
  1, 0, 0, 1, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 127 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 128 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 129 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 130 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 131 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 132 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 133 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 134 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 135 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 136 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 137 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 138 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 139 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 140 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 141 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 142 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 143 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 144 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 145 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 146 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 147 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 148 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 149 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 150 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 151 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 152 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 153 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 154 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 155 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 156 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 157 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 158 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 159 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 160 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 161 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 1, 0, 1, 0, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 1, 0,
  1, 1, 1, 1, 1, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 1, 0,
  0, 0, 0, 1, 0, 0,
  0, 0, 0, 0, 1, 1,

/* Char 162 */
  0, 0, 0, 0, 0, 0,
  1, 0, 0, 0, 1, 0,
  0, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 163 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0,
  0, 1, 1, 0, 0, 0,
  0, 1, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 164 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  1, 0, 0, 0, 1, 0,
  0, 1, 1, 1, 0, 0,
  0, 1, 0, 1, 0, 0,
  0, 1, 0, 1, 0, 0,
  0, 1, 1, 1, 0, 0,
  1, 0, 0, 0, 1, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 165 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 0, 0,
  1, 0, 0, 1, 0, 0,
  1, 0, 1, 0, 0, 0,
  1, 0, 0, 0, 0, 0,
  1, 0, 0, 0, 0, 0,
  1, 0, 0, 0, 0, 0,
  1, 0, 0, 0, 0, 0,
  1, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 166 */
  0, 0, 0, 1, 1, 0,
  0, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 0, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 0, 0,
  0, 1, 1, 0, 0, 0,
  0, 0, 0, 1, 0, 0,
  0, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 1, 0,
  0, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 167 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 0, 0,
  0, 1, 0, 0, 1, 0,
  0, 1, 0, 0, 0, 0,
  0, 0, 1, 1, 0, 0,
  0, 1, 0, 0, 1, 0,
  0, 1, 0, 0, 1, 0,
  0, 0, 1, 1, 0, 0,
  0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 1, 0,
  0, 0, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 168 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  1, 1, 0, 1, 1, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 169 */
  0, 1, 0, 1, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 0, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 0, 0,
  0, 1, 1, 0, 0, 0,
  0, 0, 0, 1, 0, 0,
  0, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 1, 0,
  0, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 170 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 0, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 0, 0,
  0, 1, 1, 0, 0, 0,
  0, 0, 0, 1, 0, 0,
  0, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 1, 0,
  0, 1, 1, 1, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 1, 0, 0, 0, 0,

/* Char 171 */
  0, 1, 0, 1, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 172 */
  0, 0, 0, 1, 1, 0,
  0, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 0,
  0, 0, 0, 0, 1, 0,
  0, 0, 0, 1, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 1, 0, 0, 0, 0,
  1, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 173 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 174 */
  0, 1, 0, 1, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 0,
  0, 0, 0, 0, 1, 0,
  0, 0, 0, 1, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 1, 0, 0, 0, 0,
  1, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 175 */
  0, 0, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 0,
  0, 0, 0, 0, 1, 0,
  0, 0, 0, 1, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 1, 0, 0, 0, 0,
  1, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 176 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 0, 0,
  0, 1, 0, 0, 1, 0,
  0, 1, 0, 0, 1, 0,
  0, 0, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 177 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 1, 0,
  0, 1, 1, 1, 1, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 1, 1, 0,
  0, 1, 1, 0, 1, 0,
  0, 0, 0, 1, 0, 0,
  0, 0, 0, 0, 1, 1,

/* Char 178 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 0, 1, 1, 0,

/* Char 179 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 1, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 1, 1, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 1, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 180 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 1, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 181 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 1, 1,
  0, 1, 1, 0, 0, 1,
  0, 0, 1, 0, 1, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 182 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0,
  0, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 0, 0,
  1, 0, 0, 0, 1, 0,
  0, 1, 1, 0, 0, 0,
  0, 0, 0, 1, 0, 0,
  1, 0, 0, 0, 1, 0,
  0, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 183 */
  0, 0, 0, 0, 0, 0,
  1, 0, 0, 0, 1, 0,
  0, 1, 0, 1, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 184 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 0, 1, 0, 0,
  0, 1, 1, 0, 0, 0,

/* Char 185 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 1, 0, 1, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 0, 0,
  1, 0, 0, 0, 1, 0,
  0, 1, 1, 0, 0, 0,
  0, 0, 0, 1, 0, 0,
  1, 0, 0, 0, 1, 0,
  0, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 186 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 0, 0,
  1, 0, 0, 0, 1, 0,
  0, 1, 1, 0, 0, 0,
  0, 0, 0, 1, 0, 0,
  1, 0, 0, 0, 1, 0,
  0, 1, 1, 1, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 1, 0, 0, 0, 0,

/* Char 187 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0,
  0, 0, 0, 0, 1, 0,
  0, 1, 0, 1, 0, 0,
  0, 1, 0, 0, 0, 0,
  1, 1, 1, 1, 0, 0,
  0, 1, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0,
  0, 1, 0, 0, 1, 0,
  0, 0, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 188 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0,
  0, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 0,
  0, 0, 0, 1, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 1, 0, 0, 0, 0,
  1, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 189 */
  0, 0, 0, 0, 0, 0,
  0, 0, 1, 0, 0, 1,
  0, 1, 0, 0, 1, 0,
  1, 0, 0, 1, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 190 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 1, 0, 1, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 0,
  0, 0, 0, 1, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 1, 0, 0, 0, 0,
  1, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 191 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 0,
  0, 0, 0, 1, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 1, 0, 0, 0, 0,
  1, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 192 */
  0, 0, 0, 1, 1, 0,
  0, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 0, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 1, 0,
  1, 1, 1, 1, 0, 0,
  1, 0, 1, 0, 0, 0,
  1, 0, 0, 1, 0, 0,
  1, 0, 0, 0, 1, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 193 */
  0, 0, 0, 1, 1, 0,
  0, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 1, 0, 1, 0, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 1, 0,
  1, 1, 1, 1, 1, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 1, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 194 */
  0, 0, 1, 0, 0, 0,
  0, 1, 0, 1, 0, 0,
  1, 0, 0, 0, 1, 0,
  0, 0, 1, 0, 0, 0,
  0, 1, 0, 1, 0, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 1, 0,
  1, 1, 1, 1, 1, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 1, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 195 */
  1, 0, 0, 0, 1, 0,
  0, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 1, 0, 1, 0, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 1, 0,
  1, 1, 1, 1, 1, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 1, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 196 */
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 1, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 1, 0, 1, 0, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 1, 0,
  1, 1, 1, 1, 1, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 1, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 197 */
  0, 0, 0, 1, 1, 0,
  0, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  1, 0, 0, 0, 0, 0,
  1, 0, 0, 0, 0, 0,
  1, 0, 0, 0, 0, 0,
  1, 0, 0, 0, 0, 0,
  1, 0, 0, 0, 0, 0,
  1, 0, 0, 0, 0, 0,
  1, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 198 */
  0, 0, 0, 1, 1, 0,
  0, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 0, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 0, 0,
  1, 0, 0, 0, 0, 0,
  1, 0, 0, 0, 0, 0,
  1, 0, 0, 0, 0, 0,
  1, 0, 0, 0, 1, 0,
  0, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 199 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 0, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 0, 0,
  1, 0, 0, 0, 0, 0,
  1, 0, 0, 0, 0, 0,
  1, 0, 0, 0, 0, 0,
  1, 0, 0, 0, 1, 0,
  0, 1, 1, 1, 0, 0,
  0, 0, 0, 1, 0, 0,
  0, 1, 1, 0, 0, 0,

/* Char 200 */
  0, 1, 0, 1, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 0, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 0, 0,
  1, 0, 0, 0, 0, 0,
  1, 0, 0, 0, 0, 0,
  1, 0, 0, 0, 0, 0,
  1, 0, 0, 0, 1, 0,
  0, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 201 */
  0, 0, 0, 1, 1, 0,
  0, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 0,
  1, 0, 0, 0, 0, 0,
  1, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 0, 0,
  1, 0, 0, 0, 0, 0,
  1, 0, 0, 0, 0, 0,
  1, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 202 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 0,
  1, 0, 0, 0, 0, 0,
  1, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 0, 0,
  1, 0, 0, 0, 0, 0,
  1, 0, 0, 0, 0, 0,
  1, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 0, 1, 1, 0,

/* Char 203 */
  0, 1, 0, 1, 0, 0,
  0, 1, 0, 1, 0, 0,
  0, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 0,
  1, 0, 0, 0, 0, 0,
  1, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 0, 0,
  1, 0, 0, 0, 0, 0,
  1, 0, 0, 0, 0, 0,
  1, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 204 */
  0, 1, 0, 1, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 0,
  1, 0, 0, 0, 0, 0,
  1, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 0, 0,
  1, 0, 0, 0, 0, 0,
  1, 0, 0, 0, 0, 0,
  1, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 205 */
  0, 0, 0, 1, 1, 0,
  0, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 206 */
  0, 0, 1, 0, 0, 0,
  0, 1, 0, 1, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 207 */
  0, 1, 0, 1, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 0, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 1, 0,
  1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 208 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 0, 0,
  0, 1, 0, 0, 1, 0,
  0, 1, 0, 0, 1, 0,
  1, 1, 1, 0, 1, 0,
  0, 1, 0, 0, 1, 0,
  0, 1, 0, 0, 1, 0,
  0, 1, 0, 0, 1, 0,
  1, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 209 */
  0, 0, 0, 1, 1, 0,
  0, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  1, 0, 0, 0, 1, 0,
  1, 1, 0, 0, 1, 0,
  1, 1, 0, 0, 1, 0,
  1, 0, 1, 0, 1, 0,
  1, 0, 1, 0, 1, 0,
  1, 0, 0, 1, 1, 0,
  1, 0, 0, 1, 1, 0,
  1, 0, 0, 0, 1, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 210 */
  0, 1, 0, 1, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  1, 0, 0, 0, 1, 0,
  1, 1, 0, 0, 1, 0,
  1, 1, 0, 0, 1, 0,
  1, 0, 1, 0, 1, 0,
  1, 0, 1, 0, 1, 0,
  1, 0, 0, 1, 1, 0,
  1, 0, 0, 1, 1, 0,
  1, 0, 0, 0, 1, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 211 */
  0, 0, 0, 1, 1, 0,
  0, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 0, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 1, 0,
  0, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 212 */
  0, 0, 1, 0, 0, 0,
  0, 1, 0, 1, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 0, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 1, 0,
  0, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 213 */
  0, 0, 1, 0, 0, 1,
  0, 1, 0, 0, 1, 0,
  0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 0, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 1, 0,
  0, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 214 */
  0, 1, 0, 1, 0, 0,
  0, 1, 0, 1, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 0, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 1, 0,
  0, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 215 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  1, 0, 0, 0, 1, 0,
  0, 1, 0, 1, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 1, 0, 1, 0, 0,
  1, 0, 0, 0, 1, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 216 */
  0, 1, 0, 1, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 0, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 1, 0,
  1, 1, 1, 1, 0, 0,
  1, 0, 1, 0, 0, 0,
  1, 0, 0, 1, 0, 0,
  1, 0, 0, 0, 1, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 217 */
  0, 0, 1, 0, 0, 0,
  0, 1, 0, 1, 0, 0,
  0, 0, 1, 0, 0, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 1, 0,
  0, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 218 */
  0, 0, 0, 1, 1, 0,
  0, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 1, 0,
  0, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 219 */
  0, 0, 1, 0, 0, 1,
  0, 1, 0, 0, 1, 0,
  0, 0, 0, 0, 0, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 1, 0,
  0, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 220 */
  0, 1, 0, 1, 0, 0,
  0, 1, 0, 1, 0, 0,
  0, 0, 0, 0, 0, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 1, 0,
  0, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 221 */
  0, 0, 0, 1, 1, 0,
  0, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 1, 0,
  0, 1, 0, 1, 0, 0,
  0, 1, 0, 1, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 222 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 0, 1, 0, 0,
  0, 0, 1, 0, 0, 0,

/* Char 223 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 0, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 1, 0,
  1, 1, 1, 1, 0, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 1, 0,
  1, 1, 0, 0, 1, 0,
  1, 0, 1, 1, 0, 0,
  1, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 224 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0,
  0, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  1, 0, 1, 1, 0, 0,
  1, 1, 0, 0, 1, 0,
  1, 0, 0, 0, 0, 0,
  1, 0, 0, 0, 0, 0,
  1, 0, 0, 0, 0, 0,
  1, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 225 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0,
  0, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 1, 0,
  0, 1, 1, 1, 1, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 1, 1, 0,
  0, 1, 1, 0, 1, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 226 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 1, 0, 1, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 1, 0,
  0, 1, 1, 1, 1, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 1, 1, 0,
  0, 1, 1, 0, 1, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 227 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  1, 0, 0, 0, 1, 0,
  0, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 1, 0,
  0, 1, 1, 1, 1, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 1, 1, 0,
  0, 1, 1, 0, 1, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 228 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 1, 0, 0, 1, 0,
  0, 1, 0, 0, 1, 0,
  0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 1, 0,
  0, 1, 1, 1, 1, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 1, 1, 0,
  0, 1, 1, 0, 1, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 229 */
  0, 0, 0, 1, 1, 0,
  0, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 1, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 230 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0,
  0, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 0, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 0, 0,
  1, 0, 0, 0, 0, 0,
  1, 0, 0, 0, 1, 0,
  0, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 231 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 0, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 0, 0,
  1, 0, 0, 0, 0, 0,
  1, 0, 0, 0, 1, 0,
  0, 1, 1, 1, 0, 0,
  0, 0, 0, 1, 0, 0,
  0, 1, 1, 0, 0, 0,

/* Char 232 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 1, 0, 1, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 0, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 0, 0,
  1, 0, 0, 0, 0, 0,
  1, 0, 0, 0, 1, 0,
  0, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 233 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0,
  0, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 0, 0,
  1, 0, 0, 0, 1, 0,
  1, 1, 1, 1, 1, 0,
  1, 0, 0, 0, 0, 0,
  1, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 234 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 0, 0,
  1, 0, 0, 0, 1, 0,
  1, 1, 1, 1, 1, 0,
  1, 0, 0, 0, 0, 0,
  1, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 0, 1, 1, 0,

/* Char 235 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 1, 0, 1, 0, 0,
  0, 1, 0, 1, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 0, 0,
  1, 0, 0, 0, 1, 0,
  1, 1, 1, 1, 1, 0,
  1, 0, 0, 0, 0, 0,
  1, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 236 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 1, 0, 1, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 0, 0,
  1, 0, 0, 0, 1, 0,
  1, 1, 1, 1, 1, 0,
  1, 0, 0, 0, 0, 0,
  1, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 237 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0,
  0, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 1, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 238 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 1, 0, 1, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 1, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 239 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 1, 1,
  0, 0, 0, 0, 0, 1,
  0, 0, 0, 1, 1, 0,
  0, 0, 0, 1, 0, 0,
  0, 1, 0, 1, 0, 0,
  1, 0, 1, 1, 0, 0,
  1, 0, 0, 1, 0, 0,
  1, 0, 0, 1, 0, 0,
  1, 0, 0, 1, 0, 0,
  0, 1, 1, 0, 1, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 240 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 1, 0,
  0, 0, 0, 1, 1, 1,
  0, 0, 0, 0, 1, 0,
  0, 1, 1, 0, 1, 0,
  1, 0, 0, 1, 1, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 1, 1, 0,
  0, 1, 1, 0, 1, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 241 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0,
  0, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  1, 0, 1, 1, 0, 0,
  1, 1, 0, 0, 1, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 1, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 242 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 1, 0, 1, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  1, 0, 1, 1, 0, 0,
  1, 1, 0, 0, 1, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 1, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 243 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0,
  0, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 0, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 1, 0,
  0, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 244 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 1, 0, 1, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 0, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 1, 0,
  0, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 245 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 1, 0, 0, 1, 0,
  1, 0, 0, 1, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 0, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 1, 0,
  0, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 246 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 1, 0, 1, 0, 0,
  0, 1, 0, 1, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 0, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 1, 0,
  0, 1, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 247 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 248 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 1, 0, 1, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  1, 0, 1, 1, 0, 0,
  1, 1, 0, 0, 1, 0,
  1, 0, 0, 0, 0, 0,
  1, 0, 0, 0, 0, 0,
  1, 0, 0, 0, 0, 0,
  1, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 249 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 1, 0, 1, 0, 0,
  0, 0, 1, 0, 0, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 1, 1, 0,
  0, 1, 1, 0, 1, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 250 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0,
  0, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 1, 1, 0,
  0, 1, 1, 0, 1, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 251 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 1, 0, 0, 1, 0,
  1, 0, 0, 1, 0, 0,
  0, 0, 0, 0, 0, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 1, 1, 0,
  0, 1, 1, 0, 1, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 252 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 1, 0, 1, 0, 0,
  0, 1, 0, 1, 0, 0,
  0, 0, 0, 0, 0, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 1, 1, 0,
  0, 1, 1, 0, 1, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,

/* Char 253 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0,
  0, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 0, 1, 0,
  1, 0, 0, 1, 1, 0,
  0, 1, 1, 0, 1, 0,
  0, 0, 0, 0, 1, 0,
  0, 0, 0, 1, 0, 0,
  1, 1, 1, 0, 0, 0,

/* Char 254 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0,
  1, 1, 1, 1, 0, 0,
  0, 1, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0,
  0, 1, 0, 0, 1, 0,
  0, 0, 1, 1, 0, 0,
  0, 0, 0, 1, 0, 0,
  0, 0, 1, 0, 0, 0,

/* Char 255 */
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0,


};

gdFont gdFontSmallRep = {
  256,
  0,
  6,
  13,
  gdFontSmallData
};

BGD_EXPORT_DATA_IMPL gdFontPtr gdFontSmall = &gdFontSmallRep;

BGD_DECLARE(gdFontPtr)
gdFontGetSmall (void)
{
  return gdFontSmall;
}

/* This file has not been truncated. */
 39426       745244      634476      1193070199  200         0           100640      9   gdfontt.c `


/*
   This is a header file for gd font, generated using
   bdftogd version 0.5 by Jan Pazdziora, adelton@fi.muni.cz
   from bdf font
   -Misc-Fixed-Medium-R-Normal--8-80-75-75-C-50-ISO8859-2
   at Thu Jan  8 13:49:54 1998.
   The original bdf was holding following copyright:
   "Libor Skarvada, libor@informatics.muni.cz"
 */


#include "gdfontt.h"

char gdFontTinyData[] = {
/* Char 0 */
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,

/* Char 1 */
  0, 0, 0, 0, 0,
  0, 0, 1, 0, 0,
  0, 1, 1, 1, 0,
  1, 1, 1, 1, 1,
  0, 1, 1, 1, 0,
  0, 0, 1, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,

/* Char 2 */
  0, 1, 0, 1, 0,
  1, 0, 1, 0, 0,
  0, 1, 0, 1, 0,
  1, 0, 1, 0, 0,
  0, 1, 0, 1, 0,
  1, 0, 1, 0, 0,
  0, 1, 0, 1, 0,
  1, 0, 1, 0, 0,

/* Char 3 */
  0, 1, 0, 1, 0,
  0, 1, 0, 1, 0,
  0, 1, 1, 1, 0,
  0, 1, 0, 1, 0,
  0, 1, 0, 1, 0,
  0, 0, 1, 1, 1,
  0, 0, 0, 1, 0,
  0, 0, 0, 1, 0,

/* Char 4 */
  1, 1, 1, 0, 0,
  1, 0, 0, 0, 0,
  1, 1, 0, 0, 0,
  1, 0, 1, 1, 1,
  1, 0, 1, 0, 0,
  0, 0, 1, 1, 0,
  0, 0, 1, 0, 0,
  0, 0, 1, 0, 0,

/* Char 5 */
  0, 1, 1, 0, 0,
  1, 0, 0, 0, 0,
  0, 1, 1, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 1, 1, 0,
  0, 0, 1, 0, 1,
  0, 0, 1, 1, 0,
  0, 0, 1, 0, 1,

/* Char 6 */
  1, 0, 0, 0, 0,
  1, 0, 0, 0, 0,
  1, 0, 0, 0, 0,
  1, 1, 1, 0, 0,
  0, 0, 1, 1, 1,
  0, 0, 1, 0, 0,
  0, 0, 1, 1, 0,
  0, 0, 1, 0, 0,

/* Char 7 */
  0, 0, 0, 0, 0,
  0, 1, 0, 0, 0,
  1, 0, 1, 0, 0,
  0, 1, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,

/* Char 8 */
  0, 0, 0, 0, 0,
  0, 0, 1, 0, 0,
  0, 1, 1, 1, 0,
  0, 0, 1, 0, 0,
  0, 0, 0, 0, 0,
  0, 1, 1, 1, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,

/* Char 9 */
  1, 0, 0, 1, 0,
  1, 1, 0, 1, 0,
  1, 0, 1, 1, 0,
  1, 0, 0, 1, 0,
  0, 0, 1, 0, 0,
  0, 0, 1, 0, 0,
  0, 0, 1, 0, 0,
  0, 0, 1, 1, 1,

/* Char 10 */
  1, 0, 1, 0, 0,
  1, 0, 1, 0, 0,
  1, 0, 1, 0, 0,
  0, 1, 0, 0, 0,
  0, 0, 1, 1, 1,
  0, 0, 0, 1, 0,
  0, 0, 0, 1, 0,
  0, 0, 0, 1, 0,

/* Char 11 */
  0, 0, 1, 0, 0,
  0, 0, 1, 0, 0,
  0, 0, 1, 0, 0,
  1, 1, 1, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,

/* Char 12 */
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  1, 1, 1, 0, 0,
  0, 0, 1, 0, 0,
  0, 0, 1, 0, 0,
  0, 0, 1, 0, 0,
  0, 0, 1, 0, 0,

/* Char 13 */
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 1, 1, 1,
  0, 0, 1, 0, 0,
  0, 0, 1, 0, 0,
  0, 0, 1, 0, 0,
  0, 0, 1, 0, 0,

/* Char 14 */
  0, 0, 1, 0, 0,
  0, 0, 1, 0, 0,
  0, 0, 1, 0, 0,
  0, 0, 1, 1, 1,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,

/* Char 15 */
  0, 0, 1, 0, 0,
  0, 0, 1, 0, 0,
  0, 0, 1, 0, 0,
  1, 1, 1, 1, 1,
  0, 0, 1, 0, 0,
  0, 0, 1, 0, 0,
  0, 0, 1, 0, 0,
  0, 0, 1, 0, 0,

/* Char 16 */
  0, 0, 0, 0, 0,
  1, 1, 1, 1, 1,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,

/* Char 17 */
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  1, 1, 1, 1, 1,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,

/* Char 18 */
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  1, 1, 1, 1, 1,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,

/* Char 19 */
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  1, 1, 1, 1, 1,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,

/* Char 20 */
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  1, 1, 1, 1, 1,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,

/* Char 21 */
  0, 0, 1, 0, 0,
  0, 0, 1, 0, 0,
  0, 0, 1, 0, 0,
  0, 0, 1, 1, 1,
  0, 0, 1, 0, 0,
  0, 0, 1, 0, 0,
  0, 0, 1, 0, 0,
  0, 0, 1, 0, 0,

/* Char 22 */
  0, 0, 1, 0, 0,
  0, 0, 1, 0, 0,
  0, 0, 1, 0, 0,
  1, 1, 1, 0, 0,
  0, 0, 1, 0, 0,
  0, 0, 1, 0, 0,
  0, 0, 1, 0, 0,
  0, 0, 1, 0, 0,

/* Char 23 */
  0, 0, 1, 0, 0,
  0, 0, 1, 0, 0,
  0, 0, 1, 0, 0,
  1, 1, 1, 1, 1,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,

/* Char 24 */
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  1, 1, 1, 1, 1,
  0, 0, 1, 0, 0,
  0, 0, 1, 0, 0,
  0, 0, 1, 0, 0,
  0, 0, 1, 0, 0,

/* Char 25 */
  0, 0, 1, 0, 0,
  0, 0, 1, 0, 0,
  0, 0, 1, 0, 0,
  0, 0, 1, 0, 0,
  0, 0, 1, 0, 0,
  0, 0, 1, 0, 0,
  0, 0, 1, 0, 0,
  0, 0, 1, 0, 0,

/* Char 26 */
  0, 0, 0, 0, 0,
  0, 0, 0, 1, 0,
  0, 0, 1, 0, 0,
  0, 1, 0, 0, 0,
  0, 0, 1, 0, 0,
  0, 0, 0, 1, 0,
  0, 1, 1, 1, 0,
  0, 0, 0, 0, 0,

/* Char 27 */
  0, 0, 0, 0, 0,
  0, 1, 0, 0, 0,
  0, 0, 1, 0, 0,
  0, 0, 0, 1, 0,
  0, 0, 1, 0, 0,
  0, 1, 0, 0, 0,
  0, 1, 1, 1, 0,
  0, 0, 0, 0, 0,

/* Char 28 */
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  1, 1, 1, 1, 1,
  0, 1, 0, 1, 0,
  0, 1, 0, 1, 0,
  0, 1, 0, 1, 0,
  0, 0, 0, 0, 0,

/* Char 29 */
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 1, 0,
  1, 1, 1, 1, 1,
  0, 0, 1, 0, 0,
  1, 1, 1, 1, 1,
  0, 1, 0, 0, 0,
  0, 0, 0, 0, 0,

/* Char 30 */
  0, 0, 0, 0, 0,
  0, 0, 1, 1, 0,
  0, 1, 0, 0, 1,
  1, 1, 1, 0, 0,
  0, 1, 0, 0, 0,
  0, 1, 0, 0, 1,
  1, 0, 1, 1, 0,
  0, 0, 0, 0, 0,

/* Char 31 */
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 1, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,

/* Char 32 */
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,

/* Char 33 */
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 1, 0, 0,
  0, 0, 1, 0, 0,
  0, 0, 1, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 1, 0, 0,
  0, 0, 0, 0, 0,

/* Char 34 */
  0, 0, 0, 0, 0,
  0, 1, 0, 1, 0,
  0, 1, 0, 1, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,

/* Char 35 */
  0, 1, 0, 1, 0,
  0, 1, 0, 1, 0,
  1, 1, 1, 1, 1,
  0, 1, 0, 1, 0,
  1, 1, 1, 1, 1,
  0, 1, 0, 1, 0,
  0, 1, 0, 1, 0,
  0, 0, 0, 0, 0,

/* Char 36 */
  0, 0, 1, 0, 0,
  0, 1, 1, 1, 0,
  1, 0, 1, 0, 0,
  0, 1, 1, 1, 0,
  0, 0, 1, 0, 1,
  0, 1, 1, 1, 0,
  0, 0, 1, 0, 0,
  0, 0, 0, 0, 0,

/* Char 37 */
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  1, 1, 0, 0, 1,
  1, 1, 0, 1, 0,
  0, 0, 1, 0, 0,
  0, 1, 0, 1, 1,
  1, 0, 0, 1, 1,
  0, 0, 0, 0, 0,

/* Char 38 */
  0, 0, 0, 0, 0,
  0, 0, 1, 0, 0,
  0, 1, 0, 1, 0,
  0, 0, 1, 0, 0,
  0, 1, 0, 1, 0,
  0, 1, 0, 1, 0,
  0, 0, 1, 0, 1,
  0, 0, 0, 0, 0,

/* Char 39 */
  0, 0, 0, 0, 0,
  0, 1, 1, 0, 0,
  0, 0, 1, 0, 0,
  0, 1, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,

/* Char 40 */
  0, 0, 0, 0, 0,
  0, 0, 1, 0, 0,
  0, 1, 0, 0, 0,
  0, 1, 0, 0, 0,
  0, 1, 0, 0, 0,
  0, 0, 1, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,

/* Char 41 */
  0, 0, 0, 0, 0,
  0, 1, 0, 0, 0,
  0, 0, 1, 0, 0,
  0, 0, 1, 0, 0,
  0, 0, 1, 0, 0,
  0, 1, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,

/* Char 42 */
  0, 0, 0, 0, 0,
  1, 0, 0, 1, 0,
  0, 1, 1, 0, 0,
  1, 1, 1, 1, 0,
  0, 1, 1, 0, 0,
  1, 0, 0, 1, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,

/* Char 43 */
  0, 0, 0, 0, 0,
  0, 0, 1, 0, 0,
  0, 0, 1, 0, 0,
  1, 1, 1, 1, 1,
  0, 0, 1, 0, 0,
  0, 0, 1, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,

/* Char 44 */
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 1, 1, 0,
  0, 0, 1, 0, 0,
  0, 1, 0, 0, 0,
  0, 0, 0, 0, 0,

/* Char 45 */
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  1, 1, 1, 1, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,

/* Char 46 */
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 1, 1, 0, 0,
  0, 1, 1, 0, 0,
  0, 0, 0, 0, 0,

/* Char 47 */
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 1,
  0, 0, 0, 1, 0,
  0, 0, 1, 0, 0,
  0, 1, 0, 0, 0,
  1, 0, 0, 0, 0,
  0, 0, 0, 0, 0,

/* Char 48 */
  0, 0, 0, 0, 0,
  0, 0, 1, 0, 0,
  0, 1, 0, 1, 0,
  0, 1, 0, 1, 0,
  0, 1, 0, 1, 0,
  0, 1, 0, 1, 0,
  0, 0, 1, 0, 0,
  0, 0, 0, 0, 0,

/* Char 49 */
  0, 0, 0, 0, 0,
  0, 0, 1, 0, 0,
  0, 1, 1, 0, 0,
  0, 0, 1, 0, 0,
  0, 0, 1, 0, 0,
  0, 0, 1, 0, 0,
  0, 1, 1, 1, 0,
  0, 0, 0, 0, 0,

/* Char 50 */
  0, 0, 0, 0, 0,
  0, 1, 1, 0, 0,
  1, 0, 0, 1, 0,
  0, 0, 0, 1, 0,
  0, 0, 1, 0, 0,
  0, 1, 0, 0, 0,
  1, 1, 1, 1, 0,
  0, 0, 0, 0, 0,

/* Char 51 */
  0, 0, 0, 0, 0,
  0, 1, 1, 0, 0,
  1, 0, 0, 1, 0,
  0, 0, 1, 0, 0,
  0, 0, 0, 1, 0,
  1, 0, 0, 1, 0,
  0, 1, 1, 0, 0,
  0, 0, 0, 0, 0,

/* Char 52 */
  0, 0, 0, 0, 0,
  0, 0, 1, 0, 0,
  0, 1, 1, 0, 0,
  1, 0, 1, 0, 0,
  1, 1, 1, 1, 0,
  0, 0, 1, 0, 0,
  0, 0, 1, 0, 0,
  0, 0, 0, 0, 0,

/* Char 53 */
  0, 0, 0, 0, 0,
  1, 1, 1, 1, 0,
  1, 0, 0, 0, 0,
  1, 1, 1, 0, 0,
  0, 0, 0, 1, 0,
  1, 0, 0, 1, 0,
  0, 1, 1, 0, 0,
  0, 0, 0, 0, 0,

/* Char 54 */
  0, 0, 0, 0, 0,
  0, 1, 1, 0, 0,
  1, 0, 0, 0, 0,
  1, 0, 1, 0, 0,
  1, 1, 0, 1, 0,
  1, 0, 0, 1, 0,
  0, 1, 1, 0, 0,
  0, 0, 0, 0, 0,

/* Char 55 */
  0, 0, 0, 0, 0,
  1, 1, 1, 1, 0,
  0, 0, 0, 1, 0,
  0, 0, 1, 0, 0,
  0, 0, 1, 0, 0,
  0, 1, 0, 0, 0,
  0, 1, 0, 0, 0,
  0, 0, 0, 0, 0,

/* Char 56 */
  0, 0, 0, 0, 0,
  0, 1, 1, 0, 0,
  1, 0, 0, 1, 0,
  0, 1, 1, 0, 0,
  1, 0, 0, 1, 0,
  1, 0, 0, 1, 0,
  0, 1, 1, 0, 0,
  0, 0, 0, 0, 0,

/* Char 57 */
  0, 0, 0, 0, 0,
  0, 1, 1, 0, 0,
  1, 0, 0, 1, 0,
  1, 0, 1, 1, 0,
  0, 1, 0, 1, 0,
  0, 0, 0, 1, 0,
  0, 1, 1, 0, 0,
  0, 0, 0, 0, 0,

/* Char 58 */
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 1, 1, 0, 0,
  0, 1, 1, 0, 0,
  0, 0, 0, 0, 0,
  0, 1, 1, 0, 0,
  0, 1, 1, 0, 0,
  0, 0, 0, 0, 0,

/* Char 59 */
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 1, 1, 0,
  0, 0, 1, 1, 0,
  0, 0, 0, 0, 0,
  0, 0, 1, 1, 0,
  0, 0, 1, 0, 0,
  0, 1, 0, 0, 0,

/* Char 60 */
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 1, 0,
  0, 0, 1, 0, 0,
  0, 1, 0, 0, 0,
  0, 0, 1, 0, 0,
  0, 0, 0, 1, 0,
  0, 0, 0, 0, 0,

/* Char 61 */
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  1, 1, 1, 1, 0,
  0, 0, 0, 0, 0,
  1, 1, 1, 1, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,

/* Char 62 */
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 1, 0, 0, 0,
  0, 0, 1, 0, 0,
  0, 0, 0, 1, 0,
  0, 0, 1, 0, 0,
  0, 1, 0, 0, 0,
  0, 0, 0, 0, 0,

/* Char 63 */
  0, 0, 0, 0, 0,
  0, 0, 1, 0, 0,
  0, 1, 0, 1, 0,
  0, 0, 0, 1, 0,
  0, 0, 1, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 1, 0, 0,
  0, 0, 0, 0, 0,

/* Char 64 */
  0, 0, 1, 1, 0,
  0, 1, 0, 0, 1,
  1, 0, 0, 1, 1,
  1, 0, 1, 0, 1,
  1, 0, 1, 0, 1,
  1, 0, 0, 1, 0,
  0, 1, 0, 0, 0,
  0, 0, 1, 1, 0,

/* Char 65 */
  0, 0, 0, 0, 0,
  0, 1, 1, 0, 0,
  1, 0, 0, 1, 0,
  1, 0, 0, 1, 0,
  1, 1, 1, 1, 0,
  1, 0, 0, 1, 0,
  1, 0, 0, 1, 0,
  0, 0, 0, 0, 0,

/* Char 66 */
  0, 0, 0, 0, 0,
  1, 1, 1, 0, 0,
  1, 0, 0, 1, 0,
  1, 1, 1, 0, 0,
  1, 0, 0, 1, 0,
  1, 0, 0, 1, 0,
  1, 1, 1, 0, 0,
  0, 0, 0, 0, 0,

/* Char 67 */
  0, 0, 0, 0, 0,
  0, 1, 1, 0, 0,
  1, 0, 0, 1, 0,
  1, 0, 0, 0, 0,
  1, 0, 0, 0, 0,
  1, 0, 0, 1, 0,
  0, 1, 1, 0, 0,
  0, 0, 0, 0, 0,

/* Char 68 */
  0, 0, 0, 0, 0,
  1, 1, 1, 0, 0,
  1, 0, 0, 1, 0,
  1, 0, 0, 1, 0,
  1, 0, 0, 1, 0,
  1, 0, 0, 1, 0,
  1, 1, 1, 0, 0,
  0, 0, 0, 0, 0,

/* Char 69 */
  0, 0, 0, 0, 0,
  1, 1, 1, 1, 0,
  1, 0, 0, 0, 0,
  1, 1, 1, 0, 0,
  1, 0, 0, 0, 0,
  1, 0, 0, 0, 0,
  1, 1, 1, 1, 0,
  0, 0, 0, 0, 0,

/* Char 70 */
  0, 0, 0, 0, 0,
  1, 1, 1, 1, 0,
  1, 0, 0, 0, 0,
  1, 1, 1, 0, 0,
  1, 0, 0, 0, 0,
  1, 0, 0, 0, 0,
  1, 0, 0, 0, 0,
  0, 0, 0, 0, 0,

/* Char 71 */
  0, 0, 0, 0, 0,
  0, 1, 1, 0, 0,
  1, 0, 0, 1, 0,
  1, 0, 0, 0, 0,
  1, 0, 1, 1, 0,
  1, 0, 0, 1, 0,
  0, 1, 1, 1, 0,
  0, 0, 0, 0, 0,

/* Char 72 */
  0, 0, 0, 0, 0,
  1, 0, 0, 1, 0,
  1, 0, 0, 1, 0,
  1, 1, 1, 1, 0,
  1, 0, 0, 1, 0,
  1, 0, 0, 1, 0,
  1, 0, 0, 1, 0,
  0, 0, 0, 0, 0,

/* Char 73 */
  0, 0, 0, 0, 0,
  0, 1, 1, 1, 0,
  0, 0, 1, 0, 0,
  0, 0, 1, 0, 0,
  0, 0, 1, 0, 0,
  0, 0, 1, 0, 0,
  0, 1, 1, 1, 0,
  0, 0, 0, 0, 0,

/* Char 74 */
  0, 0, 0, 0, 0,
  0, 0, 1, 1, 0,
  0, 0, 0, 1, 0,
  0, 0, 0, 1, 0,
  0, 0, 0, 1, 0,
  1, 0, 0, 1, 0,
  0, 1, 1, 0, 0,
  0, 0, 0, 0, 0,

/* Char 75 */
  0, 0, 0, 0, 0,
  1, 0, 0, 1, 0,
  1, 0, 1, 0, 0,
  1, 1, 0, 0, 0,
  1, 0, 1, 0, 0,
  1, 0, 1, 0, 0,
  1, 0, 0, 1, 0,
  0, 0, 0, 0, 0,

/* Char 76 */
  0, 0, 0, 0, 0,
  1, 0, 0, 0, 0,
  1, 0, 0, 0, 0,
  1, 0, 0, 0, 0,
  1, 0, 0, 0, 0,
  1, 0, 0, 0, 0,
  1, 1, 1, 1, 0,
  0, 0, 0, 0, 0,

/* Char 77 */
  0, 0, 0, 0, 0,
  1, 0, 0, 1, 0,
  1, 1, 1, 1, 0,
  1, 1, 1, 1, 0,
  1, 0, 0, 1, 0,
  1, 0, 0, 1, 0,
  1, 0, 0, 1, 0,
  0, 0, 0, 0, 0,

/* Char 78 */
  0, 0, 0, 0, 0,
  1, 0, 0, 1, 0,
  1, 1, 0, 1, 0,
  1, 1, 1, 1, 0,
  1, 0, 1, 1, 0,
  1, 0, 1, 1, 0,
  1, 0, 0, 1, 0,
  0, 0, 0, 0, 0,

/* Char 79 */
  0, 0, 0, 0, 0,
  0, 1, 1, 0, 0,
  1, 0, 0, 1, 0,
  1, 0, 0, 1, 0,
  1, 0, 0, 1, 0,
  1, 0, 0, 1, 0,
  0, 1, 1, 0, 0,
  0, 0, 0, 0, 0,

/* Char 80 */
  0, 0, 0, 0, 0,
  1, 1, 1, 0, 0,
  1, 0, 0, 1, 0,
  1, 0, 0, 1, 0,
  1, 1, 1, 0, 0,
  1, 0, 0, 0, 0,
  1, 0, 0, 0, 0,
  0, 0, 0, 0, 0,

/* Char 81 */
  0, 0, 0, 0, 0,
  0, 1, 1, 0, 0,
  1, 0, 0, 1, 0,
  1, 0, 0, 1, 0,
  1, 1, 0, 1, 0,
  1, 0, 1, 1, 0,
  0, 1, 1, 0, 0,
  0, 0, 0, 1, 0,

/* Char 82 */
  0, 0, 0, 0, 0,
  1, 1, 1, 0, 0,
  1, 0, 0, 1, 0,
  1, 0, 0, 1, 0,
  1, 1, 1, 0, 0,
  1, 0, 1, 0, 0,
  1, 0, 0, 1, 0,
  0, 0, 0, 0, 0,

/* Char 83 */
  0, 0, 0, 0, 0,
  0, 1, 1, 1, 0,
  1, 0, 0, 0, 0,
  1, 0, 0, 0, 0,
  0, 1, 1, 0, 0,
  0, 0, 0, 1, 0,
  1, 1, 1, 0, 0,
  0, 0, 0, 0, 0,

/* Char 84 */
  0, 0, 0, 0, 0,
  1, 1, 1, 1, 1,
  0, 0, 1, 0, 0,
  0, 0, 1, 0, 0,
  0, 0, 1, 0, 0,
  0, 0, 1, 0, 0,
  0, 0, 1, 0, 0,
  0, 0, 0, 0, 0,

/* Char 85 */
  0, 0, 0, 0, 0,
  1, 0, 0, 1, 0,
  1, 0, 0, 1, 0,
  1, 0, 0, 1, 0,
  1, 0, 0, 1, 0,
  1, 0, 0, 1, 0,
  0, 1, 1, 0, 0,
  0, 0, 0, 0, 0,

/* Char 86 */
  0, 0, 0, 0, 0,
  1, 0, 0, 1, 0,
  1, 0, 0, 1, 0,
  1, 0, 0, 1, 0,
  1, 0, 0, 1, 0,
  0, 1, 1, 0, 0,
  0, 1, 1, 0, 0,
  0, 0, 0, 0, 0,

/* Char 87 */
  0, 0, 0, 0, 0,
  1, 0, 0, 1, 0,
  1, 0, 0, 1, 0,
  1, 0, 0, 1, 0,
  1, 1, 1, 1, 0,
  1, 1, 1, 1, 0,
  1, 0, 0, 1, 0,
  0, 0, 0, 0, 0,

/* Char 88 */
  0, 0, 0, 0, 0,
  1, 0, 0, 1, 0,
  1, 0, 0, 1, 0,
  0, 1, 1, 0, 0,
  0, 1, 1, 0, 0,
  1, 0, 0, 1, 0,
  1, 0, 0, 1, 0,
  0, 0, 0, 0, 0,

/* Char 89 */
  0, 0, 0, 0, 0,
  1, 0, 0, 0, 1,
  1, 0, 0, 0, 1,
  0, 1, 0, 1, 0,
  0, 0, 1, 0, 0,
  0, 0, 1, 0, 0,
  0, 0, 1, 0, 0,
  0, 0, 0, 0, 0,

/* Char 90 */
  0, 0, 0, 0, 0,
  1, 1, 1, 1, 0,
  0, 0, 0, 1, 0,
  0, 0, 1, 0, 0,
  0, 1, 0, 0, 0,
  1, 0, 0, 0, 0,
  1, 1, 1, 1, 0,
  0, 0, 0, 0, 0,

/* Char 91 */
  0, 0, 0, 0, 0,
  0, 1, 1, 1, 0,
  0, 1, 0, 0, 0,
  0, 1, 0, 0, 0,
  0, 1, 0, 0, 0,
  0, 1, 0, 0, 0,
  0, 1, 1, 1, 0,
  0, 0, 0, 0, 0,

/* Char 92 */
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  1, 0, 0, 0, 0,
  0, 1, 0, 0, 0,
  0, 0, 1, 0, 0,
  0, 0, 0, 1, 0,
  0, 0, 0, 0, 1,
  0, 0, 0, 0, 0,

/* Char 93 */
  0, 0, 0, 0, 0,
  0, 1, 1, 1, 0,
  0, 0, 0, 1, 0,
  0, 0, 0, 1, 0,
  0, 0, 0, 1, 0,
  0, 0, 0, 1, 0,
  0, 1, 1, 1, 0,
  0, 0, 0, 0, 0,

/* Char 94 */
  0, 0, 0, 0, 0,
  0, 0, 1, 0, 0,
  0, 1, 0, 1, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,

/* Char 95 */
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  1, 1, 1, 1, 1,

/* Char 96 */
  0, 0, 0, 0, 0,
  0, 1, 1, 0, 0,
  0, 1, 0, 0, 0,
  0, 0, 1, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,

/* Char 97 */
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 1, 1, 1, 0,
  1, 0, 0, 1, 0,
  1, 0, 1, 1, 0,
  0, 1, 0, 1, 0,
  0, 0, 0, 0, 0,

/* Char 98 */
  0, 0, 0, 0, 0,
  1, 0, 0, 0, 0,
  1, 0, 0, 0, 0,
  1, 1, 1, 0, 0,
  1, 0, 0, 1, 0,
  1, 0, 0, 1, 0,
  1, 1, 1, 0, 0,
  0, 0, 0, 0, 0,

/* Char 99 */
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 1, 1, 1, 0,
  1, 0, 0, 0, 0,
  1, 0, 0, 0, 0,
  0, 1, 1, 1, 0,
  0, 0, 0, 0, 0,

/* Char 100 */
  0, 0, 0, 0, 0,
  0, 0, 0, 1, 0,
  0, 0, 0, 1, 0,
  0, 1, 1, 1, 0,
  1, 0, 0, 1, 0,
  1, 0, 1, 1, 0,
  0, 1, 0, 1, 0,
  0, 0, 0, 0, 0,

/* Char 101 */
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 1, 1, 0, 0,
  1, 0, 1, 1, 0,
  1, 1, 0, 0, 0,
  0, 1, 1, 1, 0,
  0, 0, 0, 0, 0,

/* Char 102 */
  0, 0, 0, 0, 0,
  0, 0, 1, 0, 0,
  0, 1, 0, 1, 0,
  0, 1, 0, 0, 0,
  1, 1, 1, 0, 0,
  0, 1, 0, 0, 0,
  0, 1, 0, 0, 0,
  0, 0, 0, 0, 0,

/* Char 103 */
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 1, 1, 1, 0,
  1, 0, 0, 1, 0,
  0, 1, 1, 1, 0,
  0, 0, 0, 1, 0,
  0, 1, 1, 0, 0,

/* Char 104 */
  0, 0, 0, 0, 0,
  1, 0, 0, 0, 0,
  1, 0, 0, 0, 0,
  1, 1, 1, 0, 0,
  1, 0, 0, 1, 0,
  1, 0, 0, 1, 0,
  1, 0, 0, 1, 0,
  0, 0, 0, 0, 0,

/* Char 105 */
  0, 0, 0, 0, 0,
  0, 0, 1, 0, 0,
  0, 0, 0, 0, 0,
  0, 1, 1, 0, 0,
  0, 0, 1, 0, 0,
  0, 0, 1, 0, 0,
  0, 1, 1, 1, 0,
  0, 0, 0, 0, 0,

/* Char 106 */
  0, 0, 0, 0, 0,
  0, 0, 0, 1, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 1, 0,
  0, 0, 0, 1, 0,
  0, 0, 0, 1, 0,
  0, 1, 0, 1, 0,
  0, 0, 1, 0, 0,

/* Char 107 */
  0, 0, 0, 0, 0,
  1, 0, 0, 0, 0,
  1, 0, 0, 0, 0,
  1, 0, 0, 1, 0,
  1, 1, 1, 0, 0,
  1, 0, 0, 1, 0,
  1, 0, 0, 1, 0,
  0, 0, 0, 0, 0,

/* Char 108 */
  0, 0, 0, 0, 0,
  0, 1, 1, 0, 0,
  0, 0, 1, 0, 0,
  0, 0, 1, 0, 0,
  0, 0, 1, 0, 0,
  0, 0, 1, 0, 0,
  0, 1, 1, 1, 0,
  0, 0, 0, 0, 0,

/* Char 109 */
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  1, 1, 0, 1, 0,
  1, 0, 1, 0, 1,
  1, 0, 1, 0, 1,
  1, 0, 0, 0, 1,
  0, 0, 0, 0, 0,

/* Char 110 */
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  1, 0, 1, 0, 0,
  1, 1, 0, 1, 0,
  1, 0, 0, 1, 0,
  1, 0, 0, 1, 0,
  0, 0, 0, 0, 0,

/* Char 111 */
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 1, 1, 0, 0,
  1, 0, 0, 1, 0,
  1, 0, 0, 1, 0,
  0, 1, 1, 0, 0,
  0, 0, 0, 0, 0,

/* Char 112 */
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  1, 1, 1, 0, 0,
  1, 0, 0, 1, 0,
  1, 1, 1, 0, 0,
  1, 0, 0, 0, 0,
  1, 0, 0, 0, 0,

/* Char 113 */
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 1, 1, 1, 0,
  1, 0, 0, 1, 0,
  0, 1, 1, 1, 0,
  0, 0, 0, 1, 0,
  0, 0, 0, 1, 0,

/* Char 114 */
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  1, 0, 1, 0, 0,
  1, 1, 0, 1, 0,
  1, 0, 0, 0, 0,
  1, 0, 0, 0, 0,
  0, 0, 0, 0, 0,

/* Char 115 */
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 1, 1, 1, 0,
  1, 1, 0, 0, 0,
  0, 0, 1, 1, 0,
  1, 1, 1, 0, 0,
  0, 0, 0, 0, 0,

/* Char 116 */
  0, 0, 0, 0, 0,
  0, 1, 0, 0, 0,
  0, 1, 0, 0, 0,
  1, 1, 1, 0, 0,
  0, 1, 0, 0, 0,
  0, 1, 0, 1, 0,
  0, 0, 1, 0, 0,
  0, 0, 0, 0, 0,

/* Char 117 */
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  1, 0, 0, 1, 0,
  1, 0, 0, 1, 0,
  1, 0, 1, 1, 0,
  0, 1, 0, 1, 0,
  0, 0, 0, 0, 0,

/* Char 118 */
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 1, 0, 1, 0,
  0, 1, 0, 1, 0,
  0, 1, 0, 1, 0,
  0, 0, 1, 0, 0,
  0, 0, 0, 0, 0,

/* Char 119 */
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  1, 0, 0, 0, 1,
  1, 0, 1, 0, 1,
  1, 0, 1, 0, 1,
  0, 1, 1, 1, 0,
  0, 0, 0, 0, 0,

/* Char 120 */
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  1, 0, 0, 1, 0,
  0, 1, 1, 0, 0,
  0, 1, 1, 0, 0,
  1, 0, 0, 1, 0,
  0, 0, 0, 0, 0,

/* Char 121 */
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  1, 0, 0, 1, 0,
  1, 0, 0, 1, 0,
  0, 1, 1, 1, 0,
  0, 0, 0, 1, 0,
  0, 1, 1, 0, 0,

/* Char 122 */
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  1, 1, 1, 1, 0,
  0, 0, 1, 0, 0,
  0, 1, 0, 0, 0,
  1, 1, 1, 1, 0,
  0, 0, 0, 0, 0,

/* Char 123 */
  0, 0, 1, 1, 0,
  0, 1, 0, 0, 0,
  0, 0, 1, 0, 0,
  1, 1, 0, 0, 0,
  0, 0, 1, 0, 0,
  0, 1, 0, 0, 0,
  0, 0, 1, 1, 0,
  0, 0, 0, 0, 0,

/* Char 124 */
  0, 0, 0, 0, 0,
  0, 0, 1, 0, 0,
  0, 0, 1, 0, 0,
  0, 0, 1, 0, 0,
  0, 0, 1, 0, 0,
  0, 0, 1, 0, 0,
  0, 0, 1, 0, 0,
  0, 0, 0, 0, 0,

/* Char 125 */
  0, 1, 1, 0, 0,
  0, 0, 0, 1, 0,
  0, 0, 1, 0, 0,
  0, 0, 0, 1, 1,
  0, 0, 1, 0, 0,
  0, 0, 0, 1, 0,
  0, 1, 1, 0, 0,
  0, 0, 0, 0, 0,

/* Char 126 */
  0, 0, 0, 0, 0,
  0, 1, 0, 1, 0,
  1, 0, 1, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,

/* Char 127 */
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,

/* Char 128 */
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,

/* Char 129 */
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,

/* Char 130 */
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,

/* Char 131 */
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,

/* Char 132 */
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,

/* Char 133 */
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,

/* Char 134 */
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,

/* Char 135 */
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,

/* Char 136 */
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,

/* Char 137 */
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,

/* Char 138 */
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,

/* Char 139 */
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,

/* Char 140 */
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,

/* Char 141 */
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,

/* Char 142 */
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,

/* Char 143 */
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,

/* Char 144 */
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,

/* Char 145 */
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,

/* Char 146 */
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,

/* Char 147 */
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,

/* Char 148 */
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,

/* Char 149 */
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,

/* Char 150 */
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,

/* Char 151 */
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,

/* Char 152 */
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,

/* Char 153 */
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,

/* Char 154 */
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,

/* Char 155 */
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,

/* Char 156 */
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,

/* Char 157 */
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,

/* Char 158 */
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,

/* Char 159 */
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,

/* Char 160 */
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,

/* Char 161 */
  0, 0, 0, 0, 0,
  0, 1, 1, 0, 0,
  1, 0, 0, 1, 0,
  1, 0, 0, 1, 0,
  1, 1, 1, 1, 0,
  1, 0, 0, 1, 0,
  1, 0, 1, 1, 0,
  0, 0, 0, 1, 1,

/* Char 162 */
  1, 0, 0, 0, 1,
  0, 1, 1, 1, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,

/* Char 163 */
  0, 0, 0, 0, 0,
  0, 1, 0, 0, 0,
  0, 1, 0, 1, 0,
  0, 1, 1, 0, 0,
  0, 1, 0, 0, 0,
  1, 1, 0, 0, 0,
  0, 1, 1, 1, 1,
  0, 0, 0, 0, 0,

/* Char 164 */
  0, 0, 0, 0, 0,
  1, 0, 0, 0, 1,
  0, 1, 1, 1, 0,
  0, 1, 0, 1, 0,
  0, 1, 1, 1, 0,
  1, 0, 0, 0, 1,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,

/* Char 165 */
  0, 0, 1, 1, 0,
  1, 0, 0, 1, 0,
  1, 0, 1, 0, 0,
  1, 0, 0, 0, 0,
  1, 0, 0, 0, 0,
  1, 0, 0, 0, 0,
  1, 1, 1, 1, 0,
  0, 0, 0, 0, 0,

/* Char 166 */
  0, 0, 0, 1, 0,
  0, 0, 1, 0, 0,
  0, 1, 1, 1, 0,
  1, 0, 0, 0, 0,
  0, 1, 1, 0, 0,
  0, 0, 0, 1, 0,
  1, 1, 1, 0, 0,
  0, 0, 0, 0, 0,

/* Char 167 */
  0, 0, 0, 0, 0,
  0, 0, 1, 1, 0,
  0, 1, 0, 0, 0,
  0, 0, 1, 0, 0,
  0, 1, 0, 1, 0,
  0, 0, 1, 0, 0,
  0, 0, 0, 1, 0,
  0, 1, 1, 0, 0,

/* Char 168 */
  0, 1, 0, 1, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,

/* Char 169 */
  0, 1, 0, 1, 0,
  0, 0, 1, 0, 0,
  0, 1, 1, 1, 0,
  1, 0, 0, 0, 0,
  0, 1, 1, 0, 0,
  0, 0, 0, 1, 0,
  1, 1, 1, 0, 0,
  0, 0, 0, 0, 0,

/* Char 170 */
  0, 0, 0, 0, 0,
  0, 1, 1, 1, 0,
  1, 0, 0, 0, 0,
  1, 0, 0, 0, 0,
  0, 1, 1, 0, 0,
  0, 0, 0, 1, 0,
  1, 1, 1, 0, 0,
  0, 1, 0, 0, 0,

/* Char 171 */
  0, 1, 0, 1, 0,
  0, 0, 1, 0, 0,
  1, 1, 1, 1, 1,
  0, 0, 1, 0, 0,
  0, 0, 1, 0, 0,
  0, 0, 1, 0, 0,
  0, 0, 1, 0, 0,
  0, 0, 0, 0, 0,

/* Char 172 */
  0, 0, 0, 1, 0,
  0, 0, 1, 0, 0,
  1, 1, 1, 1, 0,
  0, 0, 1, 0, 0,
  0, 1, 0, 0, 0,
  1, 0, 0, 0, 0,
  1, 1, 1, 1, 0,
  0, 0, 0, 0, 0,

/* Char 173 */
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  1, 1, 1, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,

/* Char 174 */
  0, 1, 0, 1, 0,
  0, 0, 1, 0, 0,
  1, 1, 1, 1, 0,
  0, 0, 1, 0, 0,
  0, 1, 0, 0, 0,
  1, 0, 0, 0, 0,
  1, 1, 1, 1, 0,
  0, 0, 0, 0, 0,

/* Char 175 */
  0, 1, 1, 0, 0,
  0, 0, 0, 0, 0,
  1, 1, 1, 1, 0,
  0, 0, 1, 0, 0,
  0, 1, 0, 0, 0,
  1, 0, 0, 0, 0,
  1, 1, 1, 1, 0,
  0, 0, 0, 0, 0,

/* Char 176 */
  0, 0, 1, 0, 0,
  0, 1, 0, 1, 0,
  0, 0, 1, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,

/* Char 177 */
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 1, 1, 1, 0,
  1, 0, 0, 1, 0,
  1, 0, 1, 1, 0,
  0, 1, 0, 1, 0,
  0, 0, 0, 1, 1,

/* Char 178 */
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 1, 0, 0,
  0, 0, 0, 1, 1,

/* Char 179 */
  0, 0, 0, 0, 0,
  0, 1, 1, 0, 0,
  0, 0, 1, 1, 0,
  0, 0, 1, 0, 0,
  0, 1, 1, 0, 0,
  0, 0, 1, 0, 0,
  0, 1, 1, 1, 0,
  0, 0, 0, 0, 0,

/* Char 180 */
  0, 0, 0, 1, 0,
  0, 0, 1, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,

/* Char 181 */
  0, 0, 0, 1, 1,
  1, 1, 0, 0, 1,
  0, 1, 0, 1, 0,
  0, 1, 0, 0, 0,
  0, 1, 0, 0, 0,
  0, 1, 0, 0, 0,
  1, 1, 1, 0, 0,
  0, 0, 0, 0, 0,

/* Char 182 */
  0, 0, 0, 1, 0,
  0, 0, 1, 0, 0,
  0, 0, 0, 0, 0,
  0, 1, 1, 1, 0,
  1, 1, 0, 0, 0,
  0, 0, 1, 1, 0,
  1, 1, 1, 0, 0,
  0, 0, 0, 0, 0,

/* Char 183 */
  0, 1, 0, 1, 0,
  0, 0, 1, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,

/* Char 184 */
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 1, 0,
  0, 1, 1, 0, 0,

/* Char 185 */
  0, 1, 0, 1, 0,
  0, 0, 1, 0, 0,
  0, 0, 0, 0, 0,
  0, 1, 1, 1, 0,
  1, 1, 0, 0, 0,
  0, 0, 1, 1, 0,
  1, 1, 1, 0, 0,
  0, 0, 0, 0, 0,

/* Char 186 */
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 1, 1, 1, 0,
  1, 1, 0, 0, 0,
  0, 0, 1, 1, 0,
  1, 1, 1, 0, 0,
  0, 1, 0, 0, 0,

/* Char 187 */
  0, 0, 0, 1, 1,
  0, 1, 0, 0, 1,
  0, 1, 0, 1, 0,
  1, 1, 1, 0, 0,
  0, 1, 0, 0, 0,
  0, 1, 0, 1, 0,
  0, 0, 1, 0, 0,
  0, 0, 0, 0, 0,

/* Char 188 */
  0, 0, 0, 1, 0,
  0, 0, 1, 0, 0,
  0, 0, 0, 0, 0,
  1, 1, 1, 1, 0,
  0, 0, 1, 0, 0,
  0, 1, 0, 0, 0,
  1, 1, 1, 1, 0,
  0, 0, 0, 0, 0,

/* Char 189 */
  0, 1, 0, 0, 1,
  1, 0, 0, 1, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,

/* Char 190 */
  0, 1, 0, 1, 0,
  0, 0, 1, 0, 0,
  0, 0, 0, 0, 0,
  1, 1, 1, 1, 0,
  0, 0, 1, 0, 0,
  0, 1, 0, 0, 0,
  1, 1, 1, 1, 0,
  0, 0, 0, 0, 0,

/* Char 191 */
  0, 0, 0, 0, 0,
  0, 1, 1, 0, 0,
  0, 0, 0, 0, 0,
  1, 1, 1, 1, 0,
  0, 0, 1, 0, 0,
  0, 1, 0, 0, 0,
  1, 1, 1, 1, 0,
  0, 0, 0, 0, 0,

/* Char 192 */
  0, 0, 1, 0, 0,
  0, 1, 0, 0, 0,
  1, 1, 1, 0, 0,
  1, 0, 0, 1, 0,
  1, 1, 1, 0, 0,
  1, 0, 1, 0, 0,
  1, 0, 0, 1, 0,
  0, 0, 0, 0, 0,

/* Char 193 */
  0, 0, 0, 1, 0,
  0, 0, 1, 0, 0,
  0, 1, 1, 0, 0,
  1, 0, 0, 1, 0,
  1, 1, 1, 1, 0,
  1, 0, 0, 1, 0,
  1, 0, 0, 1, 0,
  0, 0, 0, 0, 0,

/* Char 194 */
  0, 1, 1, 0, 0,
  1, 0, 0, 1, 0,
  0, 1, 1, 0, 0,
  1, 0, 0, 1, 0,
  1, 1, 1, 1, 0,
  1, 0, 0, 1, 0,
  1, 0, 0, 1, 0,
  0, 0, 0, 0, 0,

/* Char 195 */
  1, 0, 0, 1, 0,
  0, 1, 1, 0, 0,
  0, 1, 1, 0, 0,
  1, 0, 0, 1, 0,
  1, 1, 1, 1, 0,
  1, 0, 0, 1, 0,
  1, 0, 0, 1, 0,
  0, 0, 0, 0, 0,

/* Char 196 */
  1, 0, 0, 1, 0,
  0, 0, 0, 0, 0,
  0, 1, 1, 0, 0,
  1, 0, 0, 1, 0,
  1, 1, 1, 1, 0,
  1, 0, 0, 1, 0,
  1, 0, 0, 1, 0,
  0, 0, 0, 0, 0,

/* Char 197 */
  0, 0, 0, 1, 0,
  0, 0, 1, 0, 0,
  1, 0, 0, 0, 0,
  1, 0, 0, 0, 0,
  1, 0, 0, 0, 0,
  1, 0, 0, 0, 0,
  1, 1, 1, 1, 0,
  0, 0, 0, 0, 0,

/* Char 198 */
  0, 0, 0, 1, 0,
  0, 0, 1, 0, 0,
  0, 1, 1, 0, 0,
  1, 0, 0, 1, 0,
  1, 0, 0, 0, 0,
  1, 0, 0, 1, 0,
  0, 1, 1, 0, 0,
  0, 0, 0, 0, 0,

/* Char 199 */
  0, 0, 0, 0, 0,
  0, 1, 1, 0, 0,
  1, 0, 0, 1, 0,
  1, 0, 0, 0, 0,
  1, 0, 0, 0, 0,
  1, 0, 0, 1, 0,
  0, 1, 1, 0, 0,
  1, 1, 0, 0, 0,

/* Char 200 */
  0, 0, 0, 1, 0,
  0, 0, 1, 0, 0,
  0, 1, 1, 0, 0,
  1, 0, 0, 1, 0,
  1, 0, 0, 0, 0,
  1, 0, 0, 1, 0,
  0, 1, 1, 0, 0,
  0, 0, 0, 0, 0,

/* Char 201 */
  0, 0, 0, 1, 0,
  0, 0, 1, 0, 0,
  1, 1, 1, 1, 0,
  1, 0, 0, 0, 0,
  1, 1, 1, 0, 0,
  1, 0, 0, 0, 0,
  1, 1, 1, 1, 0,
  0, 0, 0, 0, 0,

/* Char 202 */
  0, 0, 0, 0, 0,
  1, 1, 1, 1, 0,
  1, 0, 0, 0, 0,
  1, 1, 1, 0, 0,
  1, 0, 0, 0, 0,
  1, 0, 0, 0, 0,
  1, 1, 1, 1, 0,
  0, 0, 0, 1, 1,

/* Char 203 */
  1, 0, 0, 1, 0,
  0, 0, 0, 0, 0,
  1, 1, 1, 1, 0,
  1, 0, 0, 0, 0,
  1, 1, 1, 0, 0,
  1, 0, 0, 0, 0,
  1, 1, 1, 1, 0,
  0, 0, 0, 0, 0,

/* Char 204 */
  0, 1, 0, 1, 0,
  0, 0, 1, 0, 0,
  1, 1, 1, 1, 0,
  1, 0, 0, 0, 0,
  1, 1, 1, 0, 0,
  1, 0, 0, 0, 0,
  1, 1, 1, 1, 0,
  0, 0, 0, 0, 0,

/* Char 205 */
  0, 0, 0, 1, 0,
  0, 0, 1, 0, 0,
  0, 1, 1, 1, 0,
  0, 0, 1, 0, 0,
  0, 0, 1, 0, 0,
  0, 0, 1, 0, 0,
  0, 1, 1, 1, 0,
  0, 0, 0, 0, 0,

/* Char 206 */
  0, 0, 1, 0, 0,
  0, 1, 0, 1, 0,
  0, 0, 0, 0, 0,
  0, 1, 1, 1, 0,
  0, 0, 1, 0, 0,
  0, 0, 1, 0, 0,
  0, 1, 1, 1, 0,
  0, 0, 0, 0, 0,

/* Char 207 */
  0, 1, 0, 1, 0,
  0, 0, 1, 0, 0,
  1, 1, 1, 0, 0,
  1, 0, 0, 1, 0,
  1, 0, 0, 1, 0,
  1, 0, 0, 1, 0,
  1, 1, 1, 0, 0,
  0, 0, 0, 0, 0,

/* Char 208 */
  0, 0, 0, 0, 0,
  1, 1, 1, 0, 0,
  0, 1, 0, 1, 0,
  1, 1, 0, 1, 0,
  0, 1, 0, 1, 0,
  0, 1, 0, 1, 0,
  1, 1, 1, 0, 0,
  0, 0, 0, 0, 0,

/* Char 209 */
  0, 0, 0, 1, 0,
  0, 0, 1, 0, 0,
  1, 0, 0, 1, 0,
  1, 1, 0, 1, 0,
  1, 1, 1, 1, 0,
  1, 0, 1, 1, 0,
  1, 0, 0, 1, 0,
  0, 0, 0, 0, 0,

/* Char 210 */
  0, 1, 0, 1, 0,
  0, 0, 1, 0, 0,
  1, 0, 0, 1, 0,
  1, 1, 0, 1, 0,
  1, 1, 1, 1, 0,
  1, 0, 1, 1, 0,
  1, 0, 0, 1, 0,
  0, 0, 0, 0, 0,

/* Char 211 */
  0, 0, 0, 1, 0,
  0, 0, 1, 0, 0,
  0, 1, 1, 0, 0,
  1, 0, 0, 1, 0,
  1, 0, 0, 1, 0,
  1, 0, 0, 1, 0,
  0, 1, 1, 0, 0,
  0, 0, 0, 0, 0,

/* Char 212 */
  0, 1, 1, 0, 0,
  1, 0, 0, 1, 0,
  0, 1, 1, 0, 0,
  1, 0, 0, 1, 0,
  1, 0, 0, 1, 0,
  1, 0, 0, 1, 0,
  0, 1, 1, 0, 0,
  0, 0, 0, 0, 0,

/* Char 213 */
  0, 1, 0, 0, 1,
  1, 0, 0, 1, 0,
  0, 1, 1, 0, 0,
  1, 0, 0, 1, 0,
  1, 0, 0, 1, 0,
  1, 0, 0, 1, 0,
  0, 1, 1, 0, 0,
  0, 0, 0, 0, 0,

/* Char 214 */
  1, 0, 0, 1, 0,
  0, 0, 0, 0, 0,
  0, 1, 1, 0, 0,
  1, 0, 0, 1, 0,
  1, 0, 0, 1, 0,
  1, 0, 0, 1, 0,
  0, 1, 1, 0, 0,
  0, 0, 0, 0, 0,

/* Char 215 */
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  1, 0, 0, 1, 0,
  0, 1, 1, 0, 0,
  0, 1, 1, 0, 0,
  1, 0, 0, 1, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,

/* Char 216 */
  0, 1, 0, 1, 0,
  0, 0, 1, 0, 0,
  1, 1, 1, 0, 0,
  1, 0, 0, 1, 0,
  1, 1, 1, 0, 0,
  1, 0, 1, 0, 0,
  1, 0, 0, 1, 0,
  0, 0, 0, 0, 0,

/* Char 217 */
  0, 1, 1, 0, 0,
  0, 1, 1, 0, 0,
  1, 0, 0, 1, 0,
  1, 0, 0, 1, 0,
  1, 0, 0, 1, 0,
  1, 0, 0, 1, 0,
  0, 1, 1, 0, 0,
  0, 0, 0, 0, 0,

/* Char 218 */
  0, 0, 0, 1, 0,
  0, 0, 1, 0, 0,
  1, 0, 0, 1, 0,
  1, 0, 0, 1, 0,
  1, 0, 0, 1, 0,
  1, 0, 0, 1, 0,
  0, 1, 1, 0, 0,
  0, 0, 0, 0, 0,

/* Char 219 */
  0, 1, 0, 0, 1,
  1, 0, 0, 1, 0,
  1, 0, 0, 1, 0,
  1, 0, 0, 1, 0,
  1, 0, 0, 1, 0,
  1, 0, 0, 1, 0,
  0, 1, 1, 0, 0,
  0, 0, 0, 0, 0,

/* Char 220 */
  1, 0, 0, 1, 0,
  0, 0, 0, 0, 0,
  1, 0, 0, 1, 0,
  1, 0, 0, 1, 0,
  1, 0, 0, 1, 0,
  1, 0, 0, 1, 0,
  0, 1, 1, 0, 0,
  0, 0, 0, 0, 0,

/* Char 221 */
  0, 0, 0, 1, 0,
  0, 0, 1, 0, 0,
  1, 0, 0, 0, 1,
  0, 1, 0, 1, 0,
  0, 0, 1, 0, 0,
  0, 0, 1, 0, 0,
  0, 0, 1, 0, 0,
  0, 0, 0, 0, 0,

/* Char 222 */
  0, 0, 0, 0, 0,
  1, 1, 1, 1, 1,
  0, 0, 1, 0, 0,
  0, 0, 1, 0, 0,
  0, 0, 1, 0, 0,
  0, 0, 1, 0, 0,
  0, 0, 1, 0, 0,
  0, 1, 0, 0, 0,

/* Char 223 */
  0, 0, 0, 0, 0,
  0, 1, 1, 0, 0,
  1, 0, 0, 1, 0,
  1, 1, 1, 0, 0,
  1, 0, 0, 1, 0,
  1, 1, 0, 1, 0,
  1, 0, 1, 0, 0,
  1, 0, 0, 0, 0,

/* Char 224 */
  0, 0, 0, 1, 0,
  0, 0, 1, 0, 0,
  0, 0, 0, 0, 0,
  1, 0, 1, 0, 0,
  1, 1, 0, 1, 0,
  1, 0, 0, 0, 0,
  1, 0, 0, 0, 0,
  0, 0, 0, 0, 0,

/* Char 225 */
  0, 0, 0, 1, 0,
  0, 0, 1, 0, 0,
  0, 0, 0, 0, 0,
  0, 1, 1, 1, 0,
  1, 0, 0, 1, 0,
  1, 0, 1, 1, 0,
  0, 1, 0, 1, 0,
  0, 0, 0, 0, 0,

/* Char 226 */
  0, 0, 1, 0, 0,
  0, 1, 0, 1, 0,
  0, 0, 0, 0, 0,
  0, 1, 1, 1, 0,
  1, 0, 0, 1, 0,
  1, 0, 1, 1, 0,
  0, 1, 0, 1, 0,
  0, 0, 0, 0, 0,

/* Char 227 */
  1, 0, 0, 1, 0,
  0, 1, 1, 0, 0,
  0, 0, 0, 0, 0,
  0, 1, 1, 1, 0,
  1, 0, 0, 1, 0,
  1, 0, 1, 1, 0,
  0, 1, 0, 1, 0,
  0, 0, 0, 0, 0,

/* Char 228 */
  1, 0, 0, 1, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 1, 1, 1, 0,
  1, 0, 0, 1, 0,
  1, 0, 1, 1, 0,
  0, 1, 0, 1, 0,
  0, 0, 0, 0, 0,

/* Char 229 */
  0, 0, 0, 0, 1,
  0, 0, 0, 1, 0,
  0, 1, 1, 0, 0,
  0, 0, 1, 0, 0,
  0, 0, 1, 0, 0,
  0, 0, 1, 0, 0,
  0, 1, 1, 1, 0,
  0, 0, 0, 0, 0,

/* Char 230 */
  0, 0, 0, 1, 0,
  0, 0, 1, 0, 0,
  0, 0, 0, 0, 0,
  0, 1, 1, 1, 0,
  1, 0, 0, 0, 0,
  1, 0, 0, 0, 0,
  0, 1, 1, 1, 0,
  0, 0, 0, 0, 0,

/* Char 231 */
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 1, 1, 1, 0,
  1, 0, 0, 0, 0,
  1, 0, 0, 0, 0,
  0, 1, 1, 1, 0,
  1, 1, 1, 0, 0,

/* Char 232 */
  0, 1, 0, 1, 0,
  0, 0, 1, 0, 0,
  0, 0, 0, 0, 0,
  0, 1, 1, 1, 0,
  1, 0, 0, 0, 0,
  1, 0, 0, 0, 0,
  0, 1, 1, 1, 0,
  0, 0, 0, 0, 0,

/* Char 233 */
  0, 0, 0, 1, 0,
  0, 0, 1, 0, 0,
  0, 0, 0, 0, 0,
  0, 1, 1, 0, 0,
  1, 0, 1, 1, 0,
  1, 1, 0, 0, 0,
  0, 1, 1, 1, 0,
  0, 0, 0, 0, 0,

/* Char 234 */
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 1, 1, 0, 0,
  1, 0, 1, 1, 0,
  1, 1, 0, 0, 0,
  0, 1, 1, 1, 0,
  0, 0, 0, 1, 1,

/* Char 235 */
  0, 0, 0, 0, 0,
  1, 0, 0, 1, 0,
  0, 0, 0, 0, 0,
  0, 1, 1, 0, 0,
  1, 0, 1, 1, 0,
  1, 1, 0, 0, 0,
  0, 1, 1, 1, 0,
  0, 0, 0, 0, 0,

/* Char 236 */
  0, 1, 0, 1, 0,
  0, 0, 1, 0, 0,
  0, 0, 0, 0, 0,
  0, 1, 1, 0, 0,
  1, 0, 1, 1, 0,
  1, 1, 0, 0, 0,
  0, 1, 1, 1, 0,
  0, 0, 0, 0, 0,

/* Char 237 */
  0, 0, 0, 1, 0,
  0, 0, 1, 0, 0,
  0, 0, 0, 0, 0,
  0, 1, 1, 0, 0,
  0, 0, 1, 0, 0,
  0, 0, 1, 0, 0,
  0, 1, 1, 1, 0,
  0, 0, 0, 0, 0,

/* Char 238 */
  0, 0, 1, 0, 0,
  0, 1, 0, 1, 0,
  0, 0, 0, 0, 0,
  0, 1, 1, 0, 0,
  0, 0, 1, 0, 0,
  0, 0, 1, 0, 0,
  0, 1, 1, 1, 0,
  0, 0, 0, 0, 0,

/* Char 239 */
  0, 0, 0, 1, 1,
  0, 0, 1, 0, 1,
  0, 0, 1, 0, 1,
  0, 1, 1, 0, 0,
  1, 0, 1, 0, 0,
  1, 0, 1, 0, 0,
  0, 1, 1, 0, 0,
  0, 0, 0, 0, 0,

/* Char 240 */
  0, 0, 0, 1, 0,
  0, 0, 1, 1, 1,
  0, 0, 0, 1, 0,
  0, 1, 1, 1, 0,
  1, 0, 0, 1, 0,
  1, 0, 1, 1, 0,
  0, 1, 0, 1, 0,
  0, 0, 0, 0, 0,

/* Char 241 */
  0, 0, 0, 1, 0,
  0, 0, 1, 0, 0,
  0, 0, 0, 0, 0,
  1, 0, 1, 0, 0,
  1, 1, 0, 1, 0,
  1, 0, 0, 1, 0,
  1, 0, 0, 1, 0,
  0, 0, 0, 0, 0,

/* Char 242 */
  0, 1, 0, 1, 0,
  0, 0, 1, 0, 0,
  0, 0, 0, 0, 0,
  1, 0, 1, 0, 0,
  1, 1, 0, 1, 0,
  1, 0, 0, 1, 0,
  1, 0, 0, 1, 0,
  0, 0, 0, 0, 0,

/* Char 243 */
  0, 0, 0, 1, 0,
  0, 0, 1, 0, 0,
  0, 0, 0, 0, 0,
  0, 1, 1, 0, 0,
  1, 0, 0, 1, 0,
  1, 0, 0, 1, 0,
  0, 1, 1, 0, 0,
  0, 0, 0, 0, 0,

/* Char 244 */
  0, 1, 1, 0, 0,
  1, 0, 0, 1, 0,
  0, 0, 0, 0, 0,
  0, 1, 1, 0, 0,
  1, 0, 0, 1, 0,
  1, 0, 0, 1, 0,
  0, 1, 1, 0, 0,
  0, 0, 0, 0, 0,

/* Char 245 */
  0, 1, 0, 0, 1,
  1, 0, 0, 1, 0,
  0, 0, 0, 0, 0,
  0, 1, 1, 0, 0,
  1, 0, 0, 1, 0,
  1, 0, 0, 1, 0,
  0, 1, 1, 0, 0,
  0, 0, 0, 0, 0,

/* Char 246 */
  1, 0, 0, 1, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 1, 1, 0, 0,
  1, 0, 0, 1, 0,
  1, 0, 0, 1, 0,
  0, 1, 1, 0, 0,
  0, 0, 0, 0, 0,

/* Char 247 */
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 1, 1, 0, 0,
  0, 0, 0, 0, 0,
  1, 1, 1, 1, 0,
  0, 0, 0, 0, 0,
  0, 1, 1, 0, 0,
  0, 0, 0, 0, 0,

/* Char 248 */
  0, 1, 0, 1, 0,
  0, 0, 1, 0, 0,
  0, 0, 0, 0, 0,
  1, 0, 1, 0, 0,
  1, 1, 0, 1, 0,
  1, 0, 0, 0, 0,
  1, 0, 0, 0, 0,
  0, 0, 0, 0, 0,

/* Char 249 */
  0, 1, 1, 0, 0,
  0, 1, 1, 0, 0,
  0, 0, 0, 0, 0,
  1, 0, 0, 1, 0,
  1, 0, 0, 1, 0,
  1, 0, 1, 1, 0,
  0, 1, 0, 1, 0,
  0, 0, 0, 0, 0,

/* Char 250 */
  0, 0, 0, 1, 0,
  0, 0, 1, 0, 0,
  0, 0, 0, 0, 0,
  1, 0, 0, 1, 0,
  1, 0, 0, 1, 0,
  1, 0, 1, 1, 0,
  0, 1, 0, 1, 0,
  0, 0, 0, 0, 0,

/* Char 251 */
  0, 1, 0, 0, 1,
  1, 0, 0, 1, 0,
  0, 0, 0, 0, 0,
  1, 0, 0, 1, 0,
  1, 0, 0, 1, 0,
  1, 0, 1, 1, 0,
  0, 1, 0, 1, 0,
  0, 0, 0, 0, 0,

/* Char 252 */
  1, 0, 0, 1, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  1, 0, 0, 1, 0,
  1, 0, 0, 1, 0,
  1, 0, 1, 1, 0,
  0, 1, 0, 1, 0,
  0, 0, 0, 0, 0,

/* Char 253 */
  0, 0, 0, 1, 0,
  0, 0, 1, 0, 0,
  0, 0, 0, 0, 0,
  1, 0, 0, 1, 0,
  1, 0, 0, 1, 0,
  0, 1, 1, 1, 0,
  0, 0, 0, 1, 0,
  0, 1, 1, 0, 0,

/* Char 254 */
  0, 0, 0, 0, 0,
  0, 1, 0, 0, 0,
  0, 1, 0, 0, 0,
  1, 1, 1, 0, 0,
  0, 1, 0, 0, 0,
  0, 1, 0, 1, 0,
  0, 0, 1, 0, 0,
  0, 1, 1, 0, 0,

/* Char 255 */
  0, 0, 0, 0, 0,
  0, 0, 1, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,


};

gdFont gdFontTinyRep = {
  256,
  0,
  5,
  8,
  gdFontTinyData
};

BGD_EXPORT_DATA_IMPL gdFontPtr gdFontTiny = &gdFontTinyRep;

BGD_DECLARE(gdFontPtr)
gdFontGetTiny (void)
{
  return gdFontTiny;
}

/* This file has not been truncated. */
44252       789592      705718      1193070200  200         0           100640      6   gdft.c`

/********************************************/
/* gd interface to freetype library         */
/*                                          */
/* John Ellson   ellson@graphviz.org        */
/********************************************/

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include "gd.h"
#include "gdhelpers.h"
#include "entities.h"

/* 2.0.10: WIN32, not MSWIN32 */
#ifndef WIN32
#include <unistd.h>
#else
#include <io.h>
#define R_OK 04			/* Needed in Windows */
#endif

/* number of antialised colors for indexed bitmaps */
#define NUMCOLORS 8

static int fontConfigFlag = 0;

static char *font_path(char **fontpath, char *name_list);
/* translate a fontconfig fontpattern into a fontpath. 
	return NULL if OK, else return error string */
static char *font_pattern(char **fontpath, char *fontpattern);

/* 2.0.30: move these up here so we can build correctly without freetype
	but with fontconfig */

/*
 * The character (space) used to separate alternate fonts in the
 * fontlist parameter to gdImageStringFT. 2.0.18: space was a
 * poor choice for this.
 */
#define LISTSEPARATOR ";"

/*
 * DEFAULT_FONTPATH and PATHSEPARATOR are host type dependent and
 * are normally set by configure in config.h.  These are just
 * some last resort values that might match some Un*x system
 * if building this version of gd separate from graphviz.
 */
#ifndef DEFAULT_FONTPATH
#if defined(__APPLE__) || (defined(__MWERKS__) && defined(macintosh))
#define DEFAULT_FONTPATH "/usr/share/fonts/truetype:/System/Library/Fonts:/Library/Fonts"
#else
#define DEFAULT_FONTPATH "/usr/share/fonts/truetype"
#endif
#endif
#ifndef PATHSEPARATOR
#define PATHSEPARATOR ":"
#endif

#ifndef TRUE
#define FALSE 0
#define TRUE !FALSE
#endif

#define MAX(a,b) ((a)>(b)?(a):(b))
#define MIN(a,b) ((a)<(b)?(a):(b))


BGD_DECLARE(char *) gdImageStringTTF (gdImage * im, int *brect, int fg, char *fontlist,
		  double ptsize, double angle, int x, int y, char *string)
{
  /* 2.0.6: valid return */
  return gdImageStringFT (im, brect, fg, fontlist, ptsize,
			  angle, x, y, string);
}

#ifndef HAVE_LIBFREETYPE
BGD_DECLARE(char *) gdImageStringFTEx (gdImage * im, int *brect, int fg, char *fontlist,
		   double ptsize, double angle, int x, int y, char *string,
		   gdFTStringExtraPtr strex)
{
  return "libgd was not built with FreeType font support\n";
}

BGD_DECLARE(char *) gdImageStringFT (gdImage * im, int *brect, int fg, char *fontlist,
		 double ptsize, double angle, int x, int y, char *string)
{
  return "libgd was not built with FreeType font support\n";
}
#else

#ifndef HAVE_LIBFONTCONFIG
static char * font_pattern(char **fontpath, char *fontpattern)
{
  return "libgd was not built with FontConfig support\n";
}
#endif /* HAVE_LIBFONTCONFIG */

#include "gdcache.h"
/* 2.0.16 Christophe Thomas: starting with FreeType 2.1.6, this is
  mandatory, and it has been supported for a long while. */
#ifdef HAVE_FT2BUILD_H
#include <ft2build.h>
#include FT_FREETYPE_H
#include FT_GLYPH_H
#include FT_SIZES_H
#else
#include <freetype/freetype.h>
#include <freetype/ftglyph.h>
#include <freetype/ftsizes.h>
#endif

/* number of fonts cached before least recently used is replaced */
#define FONTCACHESIZE 6

/* number of antialias color lookups cached */
#define TWEENCOLORCACHESIZE 32

/*
 * Line separation as a factor of font height.  
 *      No space between if LINESPACE = 1.00 
 *      Line separation will be rounded up to next pixel row.
 */
#define LINESPACE 1.05

typedef struct
{
  char *fontlist;		/* key */
  int flags;			/* key */
  char *fontpath;
  FT_Library *library;
  FT_Face face;
}
font_t;

typedef struct
{
  char *fontlist;		/* key */
  int flags;			/* key */
  FT_Library *library;
}
fontkey_t;

typedef struct
{
  int pixel;			/* key */
  int bgcolor;			/* key */
  int fgcolor;			/* key *//* -ve means no antialias */
  gdImagePtr im;		/* key */
  int tweencolor;
}
tweencolor_t;

typedef struct
{
  int pixel;			/* key */
  int bgcolor;			/* key */
  int fgcolor;			/* key *//* -ve means no antialias */
  gdImagePtr im;		/* key */
}
tweencolorkey_t;

/********************************************************************
 * gdTcl_UtfToUniChar is borrowed from Tcl ...
 */
/*
 * tclUtf.c --
 *
 *      Routines for manipulating UTF-8 strings.
 *
 * Copyright (c) 1997-1998 Sun Microsystems, Inc.
 *
 * See the file "license.terms" for information on usage and redistribution
 * of this file, and for a DISCLAIMER OF ALL WARRANTIES.
 *
 * SCCS: @(#) tclUtf.c 1.25 98/01/28 18:02:43
 */

/*
 *---------------------------------------------------------------------------
 *
 * gdTcl_UtfToUniChar --
 *
 *      Extract the Tcl_UniChar represented by the UTF-8 string.  Bad
 *      UTF-8 sequences are converted to valid Tcl_UniChars and processing
 *      continues.  Equivalent to Plan 9 chartorune().
 *
 *      The caller must ensure that the source buffer is long enough that
 *      this routine does not run off the end and dereference non-existent
 *      memory looking for trail bytes.  If the source buffer is known to
 *      be '\0' terminated, this cannot happen.  Otherwise, the caller
 *      should call Tcl_UtfCharComplete() before calling this routine to
 *      ensure that enough bytes remain in the string.
 *
 * Results:
 *      *chPtr is filled with the Tcl_UniChar, and the return value is the
 *      number of bytes from the UTF-8 string that were consumed.
 *
 * Side effects:
 *      None.
 *
 *---------------------------------------------------------------------------
 */

#ifdef JISX0208
#include "jisx0208.h"
#endif

static int comp_entities(const void *e1, const void *e2) {
  struct entities_s *en1 = (struct entities_s *) e1;
  struct entities_s *en2 = (struct entities_s *) e2;
  return strcmp(en1->name, en2->name);
}

extern int any2eucjp (char *, char *, unsigned int);

/* Persistent font cache until explicitly cleared */
/* Fonts can be used across multiple images */

/* 2.0.16: thread safety (the font cache is shared) */
gdMutexDeclare (gdFontCacheMutex);
static gdCache_head_t *fontCache;
static FT_Library library;

#define Tcl_UniChar int
#define TCL_UTF_MAX 3
static int
gdTcl_UtfToUniChar (char *str, Tcl_UniChar * chPtr)
/* str is the UTF8 next character pointer */
/* chPtr is the int for the result */
{
  int byte;
  char entity_name_buf[ENTITY_NAME_LENGTH_MAX+1];
  char *p;
  struct entities_s key, *res;

  /* HTML4.0 entities in decimal form, e.g. &#197; */
  /*           or in hexadecimal form, e.g. &#x6C34; */
  byte = *((unsigned char *) str);
  if (byte == '&')
    {
      int i, n = 0;

      byte = *((unsigned char *) (str + 1));
      if (byte == '#')
	{
          byte = *((unsigned char *) (str + 2));
          if (byte == 'x' || byte == 'X')
            {
              for (i = 3; i < 8; i++)
                {
                  byte = *((unsigned char *) (str + i));
                  if (byte >= 'A' && byte <= 'F')
                    byte = byte - 'A' + 10;
                  else if (byte >= 'a' && byte <= 'f')
                    byte = byte - 'a' + 10;
                  else if (byte >= '0' && byte <= '9')
                    byte = byte - '0';
                  else
                    break;
                  n = (n * 16) + byte;
                }
            }
          else
            {
	      for (i = 2; i < 8; i++)
	        {
	          byte = *((unsigned char *) (str + i));
	          if (byte >= '0' && byte <= '9')
	            n = (n * 10) + (byte - '0');
	          else
		    break;
		}
	    }
	  if (byte == ';')
	    {
	      *chPtr = (Tcl_UniChar) n;
	      return ++i;
	    }
	}
      else
        {
          key.name = p = entity_name_buf;
          for (i = 1; i < 1 + ENTITY_NAME_LENGTH_MAX; i++)
            {
              byte = *((unsigned char *) (str + i));
              if (byte == '\0')
                break;
              if (byte == ';')
                {
                  *p++ = '\0';
                  res = bsearch(&key, entities, NR_OF_ENTITIES,
                       sizeof(entities[0]), *comp_entities);
                  if (res)
                    {
                      *chPtr = (Tcl_UniChar) res->value;
                      return ++i;
                    }
                  break;
               }
              *p++ = byte;
            }
        }
    }

  /*
   * Unroll 1 to 3 byte UTF-8 sequences, use loop to handle longer ones.
   */

  byte = *((unsigned char *) str);
#ifdef JISX0208
  if (0xA1 <= byte && byte <= 0xFE)
    {
      int ku, ten;

      ku = (byte & 0x7F) - 0x20;
      ten = (str[1] & 0x7F) - 0x20;
      if ((ku < 1 || ku > 92) || (ten < 1 || ten > 94))
	{
	  *chPtr = (Tcl_UniChar) byte;
	  return 1;
	}

      *chPtr = (Tcl_UniChar) UnicodeTbl[ku - 1][ten - 1];
      return 2;
    }
  else
#endif /* JISX0208 */
  if (byte < 0xC0)
    {
      /*
       * Handles properly formed UTF-8 characters between
       * 0x01 and 0x7F.  Also treats \0 and naked trail
       * bytes 0x80 to 0xBF as valid characters representing
       * themselves.
       */

      *chPtr = (Tcl_UniChar) byte;
      return 1;
    }
  else if (byte < 0xE0)
    {
      if ((str[1] & 0xC0) == 0x80)
	{
	  /*
	   * Two-byte-character lead-byte followed
	   * by a trail-byte.
	   */

	  *chPtr = (Tcl_UniChar) (((byte & 0x1F) << 6) | (str[1] & 0x3F));
	  return 2;
	}
      /*
       * A two-byte-character lead-byte not followed by trail-byte
       * represents itself.
       */

      *chPtr = (Tcl_UniChar) byte;
      return 1;
    }
  else if (byte < 0xF0)
    {
      if (((str[1] & 0xC0) == 0x80) && ((str[2] & 0xC0) == 0x80))
	{
	  /*
	   * Three-byte-character lead byte followed by
	   * two trail bytes.
	   */

	  *chPtr = (Tcl_UniChar) (((byte & 0x0F) << 12)
				  | ((str[1] & 0x3F) << 6) | (str[2] & 0x3F));
	  return 3;
	}
      /*
       * A three-byte-character lead-byte not followed by
       * two trail-bytes represents itself.
       */

      *chPtr = (Tcl_UniChar) byte;
      return 1;
    }
#if TCL_UTF_MAX > 3
  else
    {
      int ch, total, trail;

      total = totalBytes[byte];
      trail = total - 1;
      if (trail > 0)
	{
	  ch = byte & (0x3F >> trail);
	  do
	    {
	      str++;
	      if ((*str & 0xC0) != 0x80)
		{
		  *chPtr = byte;
		  return 1;
		}
	      ch <<= 6;
	      ch |= (*str & 0x3F);
	      trail--;
	    }
	  while (trail > 0);
	  *chPtr = ch;
	  return total;
	}
    }
#endif

  *chPtr = (Tcl_UniChar) byte;
  return 1;
}

/********************************************************************/
/* font cache functions                                             */

static int
fontTest (void *element, void *key)
{
  font_t *a = (font_t *) element;
  fontkey_t *b = (fontkey_t *) key;

  return (strcmp (a->fontlist, b->fontlist) == 0 && a->flags == b->flags);
}

static int useFontConfig(int flag)
{
	if (fontConfigFlag) {
		return (!(flag & gdFTEX_FONTPATHNAME));
	} else {
		return flag & gdFTEX_FONTCONFIG;
	}
}

static void *
fontFetch (char **error, void *key)
{
  font_t *a;
  fontkey_t *b = (fontkey_t *) key;
  char *suffix;
  FT_Error err;

  *error = NULL;

  a = (font_t *) gdMalloc (sizeof (font_t));
	if (!a) {
		return NULL;
	}

  a->fontlist = strdup (b->fontlist);
  a->flags = b->flags;
  a->library = b->library;
  a->fontpath = NULL;

#ifdef HAVE_LIBFONTCONFIG
  if (!useFontConfig(b->flags)) 
  	*error = font_path(&(a->fontpath), a->fontlist);
              else
  	*error = font_pattern(&(a->fontpath), a->fontlist);
#else
  *error = font_path(&(a->fontpath), a->fontlist);
#endif /* HAVE_LIBFONTCONFIG */
  if (*error || !a->fontpath || !a->fontpath[0])
                {
      /* 2.0.12: TBB: free these. Thanks to Frank Faubert. */
      free (a->fontlist);
      if (a->fontpath)
	free (a->fontpath);
      gdFree (a);

      if (! *error)
	*error = "font_path() returned an empty font pathname";

      return NULL;
    }

#if 0
fprintf(stderr,"fontpathname=%s\n",fullname);
#endif

  err = FT_New_Face(*b->library, a->fontpath, 0, &a->face);

  /* Read kerning metrics for Postscript fonts. */
  if (!err
      && ((suffix = strstr(a->fontpath, ".pfa"))
	  || (suffix = strstr(a->fontpath, ".pfb")))
      && ((strcpy(suffix, ".afm") && (access(a->fontpath, R_OK) == 0))
	  || (strcpy(suffix, ".pfm") && (access(a->fontpath, R_OK) == 0))))
  {
    err = FT_Attach_File(a->face, a->fontpath);
  }

  if (err)
    {
      /* 2.0.12: TBB: free these. Thanks to Frank Faubert. */
      free (a->fontlist);
      free (a->fontpath);
      gdFree (a);
      *error = "Could not read font";
      return NULL;
    }

  return (void *) a;
}

static void
fontRelease (void *element)
{
  font_t *a = (font_t *) element;

  FT_Done_Face (a->face);
  gdFree (a->fontlist);
  gdFree (a->fontpath);
  gdFree ((char *) element);
}

/********************************************************************/
/* tweencolor cache functions                                            */

static int
tweenColorTest (void *element, void *key)
{
  tweencolor_t *a = (tweencolor_t *) element;
  tweencolorkey_t *b = (tweencolorkey_t *) key;

  return (a->pixel == b->pixel
	  && a->bgcolor == b->bgcolor
	  && a->fgcolor == b->fgcolor && a->im == b->im);
}

/*
 * Computes a color in im's color table that is part way between
 * the background and foreground colors proportional to the gray
 * pixel value in the range 0-NUMCOLORS. The fg and bg colors must already
 * be in the color table for palette images. For truecolor images the
 * returned value simply has an alpha component and gdImageAlphaBlend
 * does the work so that text can be alpha blended across a complex
 * background (TBB; and for real in 2.0.2).
 */
static void *
tweenColorFetch (char **error, void *key)
{
  tweencolor_t *a;
  tweencolorkey_t *b = (tweencolorkey_t *) key;
  int pixel, npixel, bg, fg;
  gdImagePtr im;

  a = (tweencolor_t *) gdMalloc (sizeof (tweencolor_t));
	if (!a) {
		return NULL;
	}

  pixel = a->pixel = b->pixel;
  bg = a->bgcolor = b->bgcolor;
  fg = a->fgcolor = b->fgcolor;
  im = a->im = b->im;

  /* if fg is specified by a negative color idx, then don't antialias */
  if (fg < 0)
    {
      if ((pixel + pixel) >= NUMCOLORS)
	a->tweencolor = -fg;
      else
	a->tweencolor = bg;
    }
  else
    {
      npixel = NUMCOLORS - pixel;
      if (im->trueColor)
	{
	  /* 2.0.1: use gdImageSetPixel to do the alpha blending work,
	     or to just store the alpha level. All we have to do here
	     is incorporate our knowledge of the percentage of this
	     pixel that is really "lit" by pushing the alpha value
	     up toward transparency in edge regions. */
	  a->tweencolor = gdTrueColorAlpha (gdTrueColorGetRed (fg),
					    gdTrueColorGetGreen (fg),
					    gdTrueColorGetBlue (fg),
					    gdAlphaMax -
					    (gdTrueColorGetAlpha (fg) *
					     pixel / NUMCOLORS));
	}
      else
	{
	  a->tweencolor = gdImageColorResolve (im,
					       (pixel * im->red[fg] +
						npixel * im->red[bg]) /
					       NUMCOLORS,
					       (pixel * im->green[fg] +
						npixel * im->green[bg]) /
					       NUMCOLORS,
					       (pixel * im->blue[fg] +
						npixel * im->blue[bg]) /
					       NUMCOLORS);
	}
    }
  return (void *) a;
}

static void
tweenColorRelease (void *element)
{
  gdFree ((char *) element);
}

/* draw_bitmap - transfers glyph bitmap to GD image */
static char *
gdft_draw_bitmap (gdCache_head_t * tc_cache, gdImage * im, int fg,
		  FT_Bitmap bitmap, int pen_x, int pen_y)
{
  unsigned char *pixel = NULL;
  int *tpixel = NULL;
  int opixel;
  int x, y, row, col, pc, pcr;

  tweencolor_t *tc_elem;
  tweencolorkey_t tc_key;

  /* copy to image, mapping colors */
  tc_key.fgcolor = fg;
  tc_key.im = im;
  /* Truecolor version; does not require the cache */
  if (im->trueColor)
    {
      for (row = 0; row < bitmap.rows; row++)
	{
	  pc = row * bitmap.pitch;
	  pcr = pc;
	  y = pen_y + row;
	  /* clip if out of bounds */
	  /* 2.0.16: clipping rectangle, not image bounds */
	  if ((y > im->cy2) || (y < im->cy1))
	    continue;
	  for (col = 0; col < bitmap.width; col++, pc++)
	    {
	      int level;
	      if (bitmap.pixel_mode == ft_pixel_mode_grays)
		{
		  /*
		   * Scale to 128 levels of alpha for gd use.
		   * alpha 0 is opacity, so be sure to invert at the end
		   */
		  level = (bitmap.buffer[pc] * gdAlphaMax /
			   (bitmap.num_grays - 1));
		}
	      else if (bitmap.pixel_mode == ft_pixel_mode_mono)
		{
		  /* 2.0.5: mode_mono fix from Giuliano Pochini */
		  level =
		    ((bitmap.
		      buffer[(col >> 3) +
			     pcr]) & (1 << (~col & 0x07))) ?
		    gdAlphaTransparent : gdAlphaOpaque;
		}
	      else
		{
		  return "Unsupported ft_pixel_mode";
		}
              if (level == 0)  /* if background */
		continue;

	      if ((fg >= 0) && (im->trueColor))
		{
		  /* Consider alpha in the foreground color itself to be an
		     upper bound on how opaque things get, when truecolor is
		     available. Without truecolor this results in far too many
		     color indexes. */
		  level =
		    level * (gdAlphaMax -
			     gdTrueColorGetAlpha (fg)) / gdAlphaMax;
		}
	      level = gdAlphaMax - level;   /* inverting to get alpha */
	      x = pen_x + col;
	      /* clip if out of bounds */
	      /* 2.0.16: clip to clipping rectangle, Matt McNabb */
	      if ((x > im->cx2) || (x < im->cx1))
		continue;
	      /* get pixel location in gd buffer */
	      tpixel = &im->tpixels[y][x];
	      if (fg < 0)
		{
		  if (level < (gdAlphaMax / 2))
		    {
		      *tpixel = -fg;
		    }
		}
	      else
		{
		  if (im->alphaBlendingFlag)
		    {
		      opixel = *tpixel;
		      if (gdTrueColorGetAlpha(opixel) != gdAlphaTransparent)
			{
			  *tpixel = gdAlphaBlend (opixel,
				      (level << 24) + (fg & 0xFFFFFF));
			}
		      else
			{
			  *tpixel = (level << 24) + (fg & 0xFFFFFF);
			}
		    }
		  else
		    {
		      *tpixel = (level << 24) + (fg & 0xFFFFFF);
		    }
		}
	    }
	}
      return (char *) NULL;
    }
  /* Non-truecolor case, restored to its more or less original form */
  for (row = 0; row < bitmap.rows; row++)
    {
      int pcr;
      pc = row * bitmap.pitch;
      pcr = pc;
      if (bitmap.pixel_mode == ft_pixel_mode_mono)
	pc *= 8;		/* pc is measured in bits for monochrome images */

      y = pen_y + row;

      /* clip if out of bounds */
      if (y > im->cy2 || y < im->cy1)
	continue;

      for (col = 0; col < bitmap.width; col++, pc++)
	{
	  if (bitmap.pixel_mode == ft_pixel_mode_grays)
	    {
	      /*
	       * Round to NUMCOLORS levels of antialiasing for
	       * index color images since only 256 colors are
	       * available.
	       */
	      tc_key.pixel = ((bitmap.buffer[pc] * NUMCOLORS)
			      + bitmap.num_grays / 2)
		/ (bitmap.num_grays - 1);
	    }
	  else if (bitmap.pixel_mode == ft_pixel_mode_mono)
	    {
	      tc_key.pixel = ((bitmap.buffer[pc / 8]
			       << (pc % 8)) & 128) ? NUMCOLORS : 0;
	      /* 2.0.5: mode_mono fix from Giuliano Pochini */
	      tc_key.pixel =
		((bitmap.
		  buffer[(col >> 3) +
			 pcr]) & (1 << (~col & 0x07))) ? NUMCOLORS : 0;
	    }
	  else
	    {
	      return "Unsupported ft_pixel_mode";
	    }
	  if (tc_key.pixel == 0)	/* if background */
	    continue;

	  x = pen_x + col;

	  /* clip if out of bounds */
	  if (x > im->cx2 || x < im->cx1)
	    continue;
	  /* get pixel location in gd buffer */
	  pixel = &im->pixels[y][x];
	  if (tc_key.pixel == NUMCOLORS)
	    {
	      /* use fg color directly. gd 2.0.2: watch out for
	         negative indexes (thanks to David Marwood). */
	      *pixel = (fg < 0) ? -fg : fg;
	    }
	  else
	    {
	      /* find antialised color */

	      tc_key.bgcolor = *pixel;
	      tc_elem = (tweencolor_t *) gdCacheGet (tc_cache, &tc_key);
	      *pixel = tc_elem->tweencolor;
	    }
	}
    }
  return (char *) NULL;
}

BGD_DECLARE(void) gdFreeFontCache ()
{
  gdFontCacheShutdown ();
}

BGD_DECLARE(void) gdFontCacheShutdown ()
{
  if (fontCache)
    {
			gdMutexLock(gdFontCacheMutex);
      gdCacheDelete (fontCache);
      /* 2.0.16: Gustavo Scotti: make sure we don't free this twice */
      fontCache = 0;
			gdMutexUnlock(gdFontCacheMutex);
      gdMutexShutdown (gdFontCacheMutex);
      FT_Done_FreeType (library);
    }
}

/********************************************************************/
/* gdImageStringFT -  render a utf8 string onto a gd image          */

BGD_DECLARE(char *) gdImageStringFT (gdImage * im, int *brect, int fg, char *fontlist,
		 double ptsize, double angle, int x, int y, char *string)
{
  return gdImageStringFTEx (im, brect, fg, fontlist,
			    ptsize, angle, x, y, string, 0);
}

BGD_DECLARE(int) gdFontCacheSetup (void)
{
  if (fontCache)
    {
      /* Already set up */
      return 0;
    }
  gdMutexSetup (gdFontCacheMutex);
  if (FT_Init_FreeType (&library))
    {
      gdMutexShutdown (gdFontCacheMutex);
      return -1;
    }
  fontCache = gdCacheCreate (FONTCACHESIZE, fontTest, fontFetch, fontRelease);
	if (!fontCache) {
		return -2;
	}
  return 0;
}

/* the platform-independent resolution used for size and position calculations */
/*    the size of the error introduced by rounding is affected by this number */
#define METRIC_RES 300

BGD_DECLARE(char *) gdImageStringFTEx (gdImage * im, int *brect, int fg, char *fontlist,
		   double ptsize, double angle, int x, int y, char *string,
		   gdFTStringExtraPtr strex)
{
  FT_Matrix matrix;
  FT_Vector penf, oldpenf, delta, total_min = {0,0}, total_max = {0,0}, glyph_min, glyph_max;
  FT_Face face;
  FT_CharMap charmap = NULL;
  FT_Glyph image;
  FT_GlyphSlot slot;
  FT_Error err;
  FT_UInt glyph_index, previous;
  double sin_a = sin (angle);
  double cos_a = cos (angle);
  int len, i, ch;
  font_t *font;
  fontkey_t fontkey;
  char *next;
  char *tmpstr = 0;
  int render = (im && (im->trueColor || (fg <= 255 && fg >= -255)));
  FT_BitmapGlyph bm;
  /* 2.0.13: Bob Ostermann: don't force autohint, that's just for testing 
     freetype and doesn't look as good */
  int render_mode = FT_LOAD_DEFAULT;
  int encoding, encodingfound;
  /* Now tuneable thanks to Wez Furlong */
  double linespace = LINESPACE;
  /* 2.0.6: put this declaration with the other declarations! */
  /*
   *   make a new tweenColorCache on every call
   *   because caching colormappings between calls
   *   is not safe. If the im-pointer points to a
   *   brand new image, the cache gives out bogus
   *   colorindexes.          -- 27.06.2001 <krisku@arrak.fi>
   */
  gdCache_head_t *tc_cache;
  /* Tuneable horizontal and vertical resolution in dots per inch */
  int hdpi, vdpi, horiAdvance, xshow_alloc = 0, xshow_pos = 0;
  FT_Size platform_specific, platform_independent;

  if (strex)
    {
      if ((strex->flags & gdFTEX_LINESPACE) == gdFTEX_LINESPACE)
	{
	  linespace = strex->linespacing;
	}
    }
  tc_cache = gdCacheCreate (TWEENCOLORCACHESIZE,
			    tweenColorTest, tweenColorFetch,
			    tweenColorRelease);

/***** initialize font library and font cache on first call ******/
  if (!fontCache)
    {
      if (gdFontCacheSetup () != 0)
	{
	  gdCacheDelete (tc_cache);
	  return "Failure to initialize font library";
	}
    }
/*****/
  gdMutexLock (gdFontCacheMutex);
  /* get the font (via font cache) */
  fontkey.fontlist = fontlist;
  if (strex)
  	fontkey.flags = strex->flags & (gdFTEX_FONTPATHNAME |
		gdFTEX_FONTCONFIG);
  else
	fontkey.flags = 0;
  fontkey.library = &library;
  font = (font_t *) gdCacheGet (fontCache, &fontkey);
  if (!font)
    {
      gdCacheDelete (tc_cache);
      gdMutexUnlock (gdFontCacheMutex);
      return fontCache->error;
    }
  face = font->face;		/* shortcut */
  slot = face->glyph;		/* shortcut */

   if (brect)
     {
       total_min.x = total_min.y = 0;
       total_max.x = total_max.y = 0;
     }

  /*
   * Added hdpi and vdpi to support images at non-screen resolutions, i.e. 300 dpi TIFF,
   *    or 100h x 50v dpi FAX format. 2.0.23.
   * 2004/02/27 Mark Shackelford, mark.shackelford@acs-inc.com
   */
  hdpi = GD_RESOLUTION;
  vdpi = GD_RESOLUTION;
  encoding = gdFTEX_Unicode;
  if (strex)
    {
      if (strex->flags & gdFTEX_RESOLUTION)
    {
      hdpi = strex->hdpi;
      vdpi = strex->vdpi;
    }
      if (strex->flags & gdFTEX_XSHOW)
        {
          strex->xshow = NULL;
        }
      /* 2.0.12: allow explicit specification of the preferred map;
         but we still fall back if it is not available. */
      if (strex->flags & gdFTEX_CHARMAP)
        {
          encoding = strex->charmap;
        }
      /* 2.0.29: we can return the font path if desired */
      if (strex->flags & gdFTEX_RETURNFONTPATHNAME) 
        strex->fontpath = strdup(font->fontpath);
      else
        strex->fontpath = 0;
    }

  matrix.xx = (FT_Fixed) (cos_a * (1 << 16));
  matrix.yx = (FT_Fixed) (sin_a * (1 << 16));
  matrix.xy = -matrix.yx;
  matrix.yy = matrix.xx;

  /* set rotation transform */
  FT_Set_Transform (face, &matrix, NULL);

  FT_New_Size (face, &platform_independent);
  FT_Activate_Size (platform_independent);
  if (FT_Set_Char_Size (face, 0, (FT_F26Dot6)(ptsize*64), METRIC_RES, METRIC_RES))
    {
      gdCacheDelete (tc_cache);
      gdMutexUnlock (gdFontCacheMutex);
      return "Could not set character size";
    }

  if (render)
    {
      FT_New_Size (face, &platform_specific);
      FT_Activate_Size (platform_specific);
      if (FT_Set_Char_Size (face, 0, (FT_F26Dot6)(ptsize*64), hdpi, vdpi))
        {
          gdCacheDelete (tc_cache);
          gdMutexUnlock (gdFontCacheMutex);
          return "Could not set character size";
        }
    }

  if (fg < 0)
      render_mode |= FT_LOAD_MONOCHROME;

  /* find requested charmap */
  encodingfound = 0;
  for (i = 0; i < face->num_charmaps; i++)
    {
      charmap = face->charmaps[i];

#if ((defined(FREETYPE_MAJOR)) && (((FREETYPE_MAJOR == 2) && (((FREETYPE_MINOR == 1) && (FREETYPE_PATCH >= 3)) || (FREETYPE_MINOR > 1))) || (FREETYPE_MAJOR > 2)))
      if (encoding == gdFTEX_Unicode)
	{
	  if (charmap->encoding == FT_ENCODING_MS_SYMBOL
	      || charmap->encoding == FT_ENCODING_UNICODE
	      || charmap->encoding == FT_ENCODING_ADOBE_CUSTOM
	      || charmap->encoding == FT_ENCODING_ADOBE_STANDARD)
	    {
	      encodingfound++;
	      break;
	    }
	}
      else if (encoding == gdFTEX_Adobe_Custom)
	{
	  if (charmap->encoding == FT_ENCODING_ADOBE_CUSTOM)
	    {
	      encodingfound++;
	      break;
	    }
	}
      else if (encoding == gdFTEX_Big5)
	{
/* renamed sometime after freetype-2.1.4 */
#ifndef FT_ENCODING_BIG5
#define FT_ENCODING_BIG5 FT_ENCODING_MS_BIG5
#endif
	  if (charmap->encoding == FT_ENCODING_BIG5)
	    {
	      encodingfound++;
	      break;
	    }
	}
      else if (encoding == gdFTEX_Shift_JIS)
	{
/* renamed sometime after freetype-2.1.4 */
#ifndef FT_ENCODING_SJIS
#define FT_ENCODING_SJIS FT_ENCODING_MS_SJIS
#endif
	  if (charmap->encoding == FT_ENCODING_SJIS)
	    {
	      encodingfound++;
	      break;
	    }
	}
#else
      if (encoding == gdFTEX_Unicode)
	{
	  if ((charmap->platform_id = 3 && charmap->encoding_id == 1)     /* Windows Unicode */
	      || (charmap->platform_id == 3 && charmap->encoding_id == 0) /* Windows Symbol */
	      || (charmap->platform_id == 2 && charmap->encoding_id == 1) /* ISO Unicode */
	      || (charmap->platform_id == 0))                          /* Apple Unicode */
	    {
	      encodingfound++;
	      break;
	    }
	}
      else if (encoding == gdFTEX_Big5)
	{
          if (charmap->platform_id == 3 && charmap->encoding_id == 4)     /* Windows Big5 */
	    {
	      encodingfound++;
	      break;
	    }
	}
      else if (encoding == gdFTEX_Shift_JIS)
	{
          if (charmap->platform_id == 3 && charmap->encoding_id == 2)     /* Windows Sjis */
	    {
	      encodingfound++;
	      break;
	    }
	}
#endif
    }
  if (encodingfound)
    {
      FT_Set_Charmap(face, charmap);
    }
  else
    {
      /* No character set found! */
      gdMutexUnlock (gdFontCacheMutex);
      return "No character set found";
    }

#ifndef JISX0208
  if (encoding == gdFTEX_Shift_JIS)
    {
#endif
      if ((tmpstr = (char *) gdMalloc (BUFSIZ)))
	{
	  any2eucjp (tmpstr, string, BUFSIZ);
	  next = tmpstr;
	}
      else
	{
	  next = string;
	}
#ifndef JISX0208
    }
  else
    {
      next = string;
    }
#endif

#if 0
fprintf(stderr,"dpi=%d,%d metric_res=%d ptsize=%g\n",hdpi,vdpi,METRIC_RES,ptsize);
#endif

  oldpenf.x = oldpenf.y = 0; /* for postscript xshow operator */
  penf.x = penf.y = 0;	/* running position of non-rotated glyphs */
  previous = 0;		/* index of previous glyph for kerning calculations */
  for (i=0; *next; i++)
    {
      FT_Activate_Size (platform_independent);

      ch = *next;

      /* carriage returns */
      if (ch == '\r')
	{
	  penf.x = 0;
	  previous = 0;		/* clear kerning flag */
	  next++;
	  continue;
	}
      /* newlines */
      if (ch == '\n')
	{
	  /* 2.0.13: reset penf.x. Christopher J. Grayce */
	  penf.x = 0;
	  penf.y += linespace * ptsize * 64 * METRIC_RES / 72;
	  penf.y &= ~63;	/* round down to 1/METRIC_RES */
	  previous = 0;		/* clear kerning flag */
	  next++;
	  continue;
	}


        switch (encoding)
	  {
	  case gdFTEX_Unicode:
	    {
	      /* use UTF-8 mapping from ASCII */
	      len = gdTcl_UtfToUniChar (next, &ch);
/* EAM DEBUG */
/* TBB: get this exactly right: 2.1.3 *or better*, all possible cases. */
/* 2.0.24: David R. Morrison: use the more complete ifdef here. */
#if ((defined(FREETYPE_MAJOR)) && (((FREETYPE_MAJOR == 2) && (((FREETYPE_MINOR == 1) && (FREETYPE_PATCH >= 3)) || (FREETYPE_MINOR > 1))) || (FREETYPE_MAJOR > 2)))
      	      if (charmap->encoding == FT_ENCODING_MS_SYMBOL)
#else
	      if (charmap->platform_id == 3 && charmap->encoding_id == 0)
#endif /* Freetype 2.1 or better */
		{
		  /* I do not know the significance of the constant 0xf000. */
		  /* It was determined by inspection of the character codes */
		  /* stored in Microsoft font symbol.ttf                    */
		  ch |= 0xf000;
		}
/* EAM DEBUG */
	      next += len;
	    }
	    break;
	  case gdFTEX_Shift_JIS:
	    {
	      unsigned char c;
	      int jiscode;
	      c = *next;
	      if (0xA1 <= c && c <= 0xFE)
	        {
	          next++;
	          jiscode = 0x100 * (c & 0x7F) + ((*next) & 0x7F);
      
		  ch = (jiscode >> 8) & 0xFF;
		  jiscode &= 0xFF;

		  if (ch & 1)
		    jiscode += 0x40 - 0x21;
		  else
		    jiscode += 0x9E - 0x21;

		  if (jiscode >= 0x7F)
		    jiscode++;
		  ch = (ch - 0x21) / 2 + 0x81;
		  if (ch >= 0xA0)
		    ch += 0x40;

		  ch = (ch << 8) + jiscode;
		}
	      else
		{
		  ch = c & 0xFF;	/* don't extend sign */
		}
				if (*next) next++;
	    }
	    break;
	  case gdFTEX_Big5:
	    {
	      /*
	       * Big 5 mapping:
	       * use "JIS-8 half-width katakana" coding from 8-bit characters. Ref:
	       * ftp://ftp.ora.com/pub/examples/nutshell/ujip/doc/japan.inf-032092.sjs
	       */
	      ch = (*next) & 0xFF;	/* don't extend sign */
	      next++;
	      if (ch >= 161	/* first code of JIS-8 pair */
		  && *next)
		{		/* don't advance past '\0' */
		  /* TBB: Fix from Kwok Wah On: & 255 needed */
		  ch = (ch * 256) + ((*next) & 255);
		  next++;
		}
	    }
	    break;

	  case gdFTEX_Adobe_Custom:
	  default:
			ch &= 0xFF;
	    next++;
	    break;
	  }

      /* Convert character code to glyph index */
      glyph_index = FT_Get_Char_Index (face, ch);

      /* retrieve kerning distance */
      if ( ! (strex && (strex->flags & gdFTEX_DISABLE_KERNING))
		&& ! FT_IS_FIXED_WIDTH(face)
		&& FT_HAS_KERNING(face)
		&& previous
		&& glyph_index)
        FT_Get_Kerning (face, previous, glyph_index, ft_kerning_default, &delta);
      else
	delta.x = delta.y = 0;

	  penf.x += delta.x;

      /* When we know the position of the second or subsequent character,
	save the (kerned) advance from the preceeding character in the
	xshow vector */
      if (i && strex && (strex->flags & gdFTEX_XSHOW))
        {
	  /* make sure we have enough allocation for two numbers
		so we don't have to recheck for the terminating number */
	  if (! xshow_alloc) {
			xshow_alloc = 100;
			strex->xshow = gdMalloc(xshow_alloc);
			if (!strex->xshow) {
				return 0;
			}
			xshow_pos = 0;
	  } 
	  else if (xshow_pos + 20 > xshow_alloc) {
		xshow_alloc += 100;
		strex->xshow = gdRealloc(strex->xshow, xshow_alloc);
		if (!strex->xshow) {
			return 0;
		}
	}
	  xshow_pos += sprintf(strex->xshow + xshow_pos, "%g ",
		(double)(penf.x - oldpenf.x) * hdpi / (64 * METRIC_RES));
        }
      oldpenf.x = penf.x;

      /* load glyph image into the slot (erase previous one) */
      err = FT_Load_Glyph (face, glyph_index, render_mode);
      if (err)
	{
	  gdCacheDelete (tc_cache);
	  gdMutexUnlock (gdFontCacheMutex);
	  return "Problem loading glyph";
	}

      horiAdvance = slot->metrics.horiAdvance;

      if (brect)
	{			/* only if need brect */

	  glyph_min.x = penf.x + slot->metrics.horiBearingX;
	  glyph_min.y = penf.y - slot->metrics.horiBearingY;

#if 0
	  if (ch == ' ')        /* special case for trailing space */
            {
              glyph_max.x = penf.x + horiAdvance;
            }
          else
            {
	      glyph_max.x = glyph_min.x + slot->metrics.width;
            }
#else
          glyph_max.x = penf.x + horiAdvance;
#endif
	  glyph_max.y = glyph_min.y + slot->metrics.height;

	  if (i==0)
	    {
	      total_min = glyph_min;
	      total_max = glyph_max;
	    }
	  else
	    {
              if (glyph_min.x < total_min.x)
                  total_min.x = glyph_min.x;
              if (glyph_min.y < total_min.y)
                  total_min.y = glyph_min.y;
              if (glyph_max.x > total_max.x)
                  total_max.x = glyph_max.x;
              if (glyph_max.y > total_max.y)
                  total_max.y = glyph_max.y;
	    }
	}

      if (render)
	{
          FT_Activate_Size (platform_specific);

          /* load glyph again into the slot (erase previous one)  - this time with scaling */
          err = FT_Load_Glyph (face, glyph_index, render_mode);
          if (err)
	    {
	      gdCacheDelete (tc_cache);
	      gdMutexUnlock (gdFontCacheMutex);
	      return "Problem loading glyph";
	    }

          /* load and transform glyph image */
          FT_Get_Glyph (slot, &image);

	  if (image->format != ft_glyph_format_bitmap)
	    {
	      err = FT_Glyph_To_Bitmap (&image, ft_render_mode_normal, 0, 1);
	      if (err)
		{
		  gdCacheDelete (tc_cache);
		  gdMutexUnlock (gdFontCacheMutex);
		  return "Problem rendering glyph";
		}
	    }

	  /* now, draw to our target surface */
	  bm = (FT_BitmapGlyph) image;
          /* position rounded down to nearest pixel at current dpi
		 (the estimate was rounded up to next 1/METRIC_RES, so this should fit) */
	  gdft_draw_bitmap (tc_cache, im, fg, bm->bitmap,
                    x + (penf.x * cos_a + penf.y * sin_a)*hdpi/(METRIC_RES*64) + bm->left,
                    y - (penf.x * sin_a - penf.y * cos_a)*vdpi/(METRIC_RES*64) - bm->top);

          FT_Done_Glyph (image);
	}

      /* record current glyph index for kerning */
      previous = glyph_index;

      penf.x += horiAdvance;
    }

  /* Save the (unkerned) advance from the last character in the xshow vector */
  if (strex && (strex->flags & gdFTEX_XSHOW) && strex->xshow)
    {
	sprintf(strex->xshow + xshow_pos, "%g",
                (double)(penf.x - oldpenf.x) * hdpi / (64 * METRIC_RES) );
    }

  if (brect)
    {				/* only if need brect */
			double scalex = (double)hdpi / (64 * METRIC_RES);
			double scaley = (double)vdpi / (64 * METRIC_RES);

      /* increase by 1 pixel to allow for rounding */
      total_min.x -= METRIC_RES;
      total_min.y -= METRIC_RES;
      total_max.x += METRIC_RES;
      total_max.y += METRIC_RES;
 
      /* rotate bounding rectangle, scale and round to int pixels, and translate */
			brect[0] = x + (total_min.x * cos_a + total_max.y * sin_a)*scalex;
			brect[1] = y - (total_min.x * sin_a - total_max.y * cos_a)*scaley;
			brect[2] = x + (total_max.x * cos_a + total_max.y * sin_a)*scalex;
      brect[3] = y - (total_max.x * sin_a - total_max.y * cos_a)*scaley;
      brect[4] = x + (total_max.x * cos_a + total_min.y * sin_a)*scalex;
      brect[5] = y - (total_max.x * sin_a - total_min.y * cos_a)*scaley;
      brect[6] = x + (total_min.x * cos_a + total_min.y * sin_a)*scalex;
      brect[7] = y - (total_min.x * sin_a - total_min.y * cos_a)*scaley;
    }

  FT_Done_Size (platform_independent);
  if (render)
    FT_Done_Size (platform_specific);

  if (tmpstr)
    gdFree (tmpstr);
  gdCacheDelete (tc_cache);
  gdMutexUnlock (gdFontCacheMutex);
  return (char *) NULL;
}

#endif /* HAVE_LIBFREETYPE */

#ifdef HAVE_LIBFONTCONFIG
/* Code to find font path, with special mapping for Postscript font names.
 *
 * Dag Lem <dag@nimrod.no>
 */

#include <fontconfig/fontconfig.h>

/* #define NO_POSTSCRIPT_ALIAS 1 */
#ifndef NO_POSTSCRIPT_ALIAS
typedef struct _PostscriptAlias {
  char* name;
  char* family;
  char* style;
} PostscriptAlias;

/* This table maps standard Postscript font names to URW Type 1 fonts.
   The mapping is converted from Ghostscript (Fontmap.GS)
   for use with fontconfig. */
static PostscriptAlias postscript_alias[] = {
  { "AvantGarde-Book", "URW Gothic L", "Book" },
  { "AvantGarde-BookOblique", "URW Gothic L", "Book Oblique" },
  { "AvantGarde-Demi", "URW Gothic L", "Demi" },
  { "AvantGarde-DemiOblique", "URW Gothic L", "Demi Oblique" },

  { "Bookman-Demi", "URW Bookman L", "Demi Bold" },
  { "Bookman-DemiItalic", "URW Bookman L", "Demi Bold Italic" },
  { "Bookman-Light", "URW Bookman L", "Light" },
  { "Bookman-LightItalic", "URW Bookman L", "Light Italic" },

  { "Courier", "Nimbus Mono L", "Regular" },
  { "Courier-Oblique", "Nimbus Mono L", "Regular Oblique" },
  { "Courier-Bold", "Nimbus Mono L", "Bold" },
  { "Courier-BoldOblique", "Nimbus Mono L", "Bold Oblique" },
  
  { "Helvetica", "Nimbus Sans L", "Regular" },
  { "Helvetica-Oblique", "Nimbus Sans L", "Regular Italic" },
  { "Helvetica-Bold", "Nimbus Sans L", "Bold" },
  { "Helvetica-BoldOblique", "Nimbus Sans L", "Bold Italic" },

  { "Helvetica-Narrow", "Nimbus Sans L", "Regular Condensed" },
  { "Helvetica-Narrow-Oblique", "Nimbus Sans L", "Regular Condensed Italic" },
  { "Helvetica-Narrow-Bold", "Nimbus Sans L", "Bold Condensed" },
  { "Helvetica-Narrow-BoldOblique", "Nimbus Sans L", "Bold Condensed Italic" },

  { "NewCenturySchlbk-Roman", "Century Schoolbook L", "Roman" },
  { "NewCenturySchlbk-Italic", "Century Schoolbook L", "Italic" },
  { "NewCenturySchlbk-Bold", "Century Schoolbook L", "Bold" },
  { "NewCenturySchlbk-BoldItalic", "Century Schoolbook L", "Bold Italic" },

  { "Palatino-Roman", "URW Palladio L", "Roman" },
  { "Palatino-Italic", "URW Palladio L", "Italic" },
  { "Palatino-Bold", "URW Palladio L", "Bold" },
  { "Palatino-BoldItalic", "URW Palladio L", "Bold Italic" },

  { "Symbol", "Standard Symbols L", "Regular" },

  { "Times-Roman", "Nimbus Roman No9 L", "Regular" },
  { "Times-Italic", "Nimbus Roman No9 L", "Regular Italic" },
  { "Times-Bold", "Nimbus Roman No9 L", "Medium" },
  { "Times-BoldItalic", "Nimbus Roman No9 L", "Medium Italic" },

  { "ZapfChancery-MediumItalic", "URW Chancery L", "Medium Italic" },

  { "ZapfDingbats", "Dingbats", "" },
};
#endif


static FcPattern* find_font(FcPattern* pattern)
{
  FcResult result;

  FcConfigSubstitute(0, pattern, FcMatchPattern);
  FcConfigSubstitute(0, pattern, FcMatchFont);
  FcDefaultSubstitute(pattern);

  return FcFontMatch(0, pattern, &result);
}


#ifndef NO_POSTSCRIPT_ALIAS
static char* find_postscript_font(FcPattern **fontpattern, char* fontname)
{
  FcPattern* font = NULL;
  int i;

  *fontpattern = NULL;
  for (i = 0; i < sizeof(postscript_alias)/sizeof(*postscript_alias); i++) {
    if (strcmp(fontname, postscript_alias[i].name) == 0) {
      FcChar8* family;

      FcPattern* pattern =
	FcPatternBuild(0,
		       FC_FAMILY, FcTypeString, postscript_alias[i].family,
		       FC_STYLE, FcTypeString, postscript_alias[i].style,
		       (char*)0);
      font = find_font(pattern);
      FcPatternDestroy(pattern);

      if (!font || FcPatternGetString(font, FC_FAMILY, 0, &family) != FcResultMatch)
	return "fontconfig: Couldn't retrieve font family name.";
      
      /* Check whether we got the font family we wanted. */
      if (strcmp((const char *)family, postscript_alias[i].family) != 0) {
	FcPatternDestroy(font);
	return "fontconfig: Didn't find expected font family. Perhaps URW Type 1 fonts need installing?";
      }
      break;
    }
  }

  *fontpattern = font;
  return NULL;
}
#endif

static char * font_pattern(char **fontpath, char *fontpattern)
{
  FcPattern* font = NULL;
  FcChar8* file;
  FcPattern* pattern;
#ifndef NO_POSTSCRIPT_ALIAS
  char *error;
#endif

  *fontpath = NULL;
#ifndef NO_POSTSCRIPT_ALIAS
  error = find_postscript_font(&font, fontpattern);

  if (!font) {
    if (error)
      return error;
#endif
    pattern = FcNameParse((const FcChar8 *)fontpattern);
    font = find_font(pattern);
    FcPatternDestroy(pattern);
#ifndef NO_POSTSCRIPT_ALIAS
  }
#endif

  if (!font || FcPatternGetString(font, FC_FILE, 0, &file) != FcResultMatch)
    return "fontconfig: Couldn't retrieve font file name.";

  *fontpath = strdup((const char *)file);

  FcPatternDestroy(font);

  return NULL;
}

#endif /* HAVE_LIBFONTCONFIG */

/* Look up font using font names as file names. */
static char * font_path(char **fontpath, char *name_list)
{
  int font_found = 0;
  char *fontsearchpath, *fontlist;
  char *fullname = NULL;
  char *name, *path, *dir;
  char *strtok_ptr;

  /*
   * Search the pathlist for any of a list of font names.
   */
  *fontpath = NULL;
  fontsearchpath = getenv ("GDFONTPATH");
  if (!fontsearchpath)
    fontsearchpath = DEFAULT_FONTPATH;
  fontlist = strdup (name_list);

  /*
   * Must use gd_strtok_r else pointer corrupted by strtok in nested loop.
   */
  for (name = gd_strtok_r (fontlist, LISTSEPARATOR, &strtok_ptr); name;
       name = gd_strtok_r (0, LISTSEPARATOR, &strtok_ptr))
    {

      /* make a fresh copy each time - strtok corrupts it. */
      path = strdup (fontsearchpath);
      /*
       * Allocate an oversized buffer that is guaranteed to be
       * big enough for all paths to be tested.
       */
      /* 2.0.22: Thorben Kundinger: +8 is needed, not +6. */
      fullname = gdRealloc (fullname,
                          strlen (fontsearchpath) + strlen (name) + 8);
      /* if name is an absolute or relative pathname then test directly */
#ifdef NETWARE
      /* netware uses the format "volume:/path" or the standard "/path" */
      if (name[0] != 0 && (strstr(name, ":/") || name[0] == '/'))
#else
      if (strchr (name, '/')
	  || (name[0] != 0 && name[1] == ':'
	      && (name[2] == '/' || name[2] == '\\')))
#endif
	{
	  sprintf (fullname, "%s", name);
	  if (access (fullname, R_OK) == 0)
	    {
	      font_found++;
              /* 2.0.16: memory leak fixed, Gustavo Scotti */
              gdFree (path);
	      break;
	    }
	}
      for (dir = strtok (path, PATHSEPARATOR); dir;
	   dir = strtok (0, PATHSEPARATOR))
	{
          if (strchr (name, '.'))
	    {
	      sprintf (fullname, "%s/%s", dir, name);
	      if (access (fullname, R_OK) == 0)
	        {
	          font_found++;
	          break;
	        }
	      else
		{
		  continue;
		}
            }
	  sprintf (fullname, "%s/%s.ttf", dir, name);
	  if (access (fullname, R_OK) == 0)
	    {
	      font_found++;
	      break;
	    }
	  sprintf (fullname, "%s/%s.pfa", dir, name);
	  if (access (fullname, R_OK) == 0)
	    {
	      font_found++;
	      break;
	    }
	  sprintf (fullname, "%s/%s.pfb", dir, name);
	  if (access (fullname, R_OK) == 0)
	    {
	      font_found++;
	      break;
	    }
	  sprintf (fullname, "%s/%s.dfont", dir, name);
	  if (access (fullname, R_OK) == 0)
	    {
	      font_found++;
	      break;
	    }
	}
      gdFree (path);
      if (font_found)
	break;
    }
  gdFree (fontlist);
  if (!font_found)
    {
      gdFree (fullname);
      return "Could not find/open font";
    }

  *fontpath = fullname;
  return NULL;
}

BGD_DECLARE(int) gdFTUseFontConfig(int flag)
{
#ifdef HAVE_LIBFONTCONFIG
	fontConfigFlag = 1;
	return 1;
#else
	return 0;
#endif /* HAVE_LIBFONTCONFIG */
}

12942       802630      745244      1193070200  200         0           100640      6   gdfx.c`
#include "gd.h"
#include <math.h>

/* In tests this is sufficient to prevent obvious artifacts */
#define MAG 4

#define PI 3.141592
#define DEG2RAD(x) ((x)*PI/180.)

#define MAX(x,y) ((x) > (y) ? (x) : (y))
#define MIN(x,y) ((x) < (y) ? (x) : (y))

#define MAX4(x,y,z,w) \
	((MAX((x),(y))) > (MAX((z),(w))) ? (MAX((x),(y))) : (MAX((z),(w))))
#define MIN4(x,y,z,w) \
	((MIN((x),(y))) < (MIN((z),(w))) ? (MIN((x),(y))) : (MIN((z),(w))))

#define MAXX(x) MAX4(x[0],x[2],x[4],x[6])
#define MINX(x) MIN4(x[0],x[2],x[4],x[6])
#define MAXY(x) MAX4(x[1],x[3],x[5],x[7])
#define MINY(x) MIN4(x[1],x[3],x[5],x[7])

BGD_DECLARE(char *)
gdImageStringFTCircle (gdImagePtr im,
		       int cx,
		       int cy,
		       double radius,
		       double textRadius,
		       double fillPortion,
		       char *font,
		       double points, char *top, char *bottom, int fgcolor)
{
  char *err;
  int w;
  int brect[8];
  int sx1, sx2, sy1, sy2, sx, sy;
  int x, y;
  int fr, fg, fb, fa;
  int ox, oy;
  double prop;
  gdImagePtr im1;
  gdImagePtr im2;
  gdImagePtr im3;
  /* obtain brect so that we can size the image */
  err = gdImageStringFT ((gdImagePtr) NULL,
			 &brect[0], 0, font, points * MAG, 0, 0, 0, bottom);
  if (err)
    {
      return err;
    }
  sx1 = MAXX (brect) - MINX (brect) + 6;
  sy1 = MAXY (brect) - MINY (brect) + 6;
  err = gdImageStringFT ((gdImagePtr) NULL,
			 &brect[0], 0, font, points * MAG, 0, 0, 0, top);
  if (err)
    {
      return err;
    }
  sx2 = MAXX (brect) - MINX (brect) + 6;
  sy2 = MAXY (brect) - MINY (brect) + 6;
  /* Pad by 4 pixels to allow for slight errors
     observed in the bounding box returned by freetype */
  if (sx1 > sx2)
    {
      sx = sx1 * 2 + 4;
    }
  else
    {
      sx = sx2 * 2 + 4;
    }
  if (sy1 > sy2)
    {
      sy = sy1;
    }
  else
    {
      sy = sy2;
    }
  im1 = gdImageCreateTrueColor (sx, sy);
  if (!im1)
    {
      return "could not create first image";
    }
  err = gdImageStringFT (im1, 0, gdTrueColor (255, 255, 255),
			 font, points * MAG,
			 0, ((sx / 2) - sx1) / 2, points * MAG, bottom);
  if (err)
    {
      gdImageDestroy (im1);
      return err;
    }
  /* We don't know the descent, which would be needed to do this
     with the angle parameter. Instead, implement a simple
     flip operation ourselves. */
  err = gdImageStringFT (im1, 0, gdTrueColor (255, 255, 255),
			 font, points * MAG,
			 0, sx / 2 + ((sx / 2) - sx2) / 2, points * MAG, top);
  if (err)
    {
      gdImageDestroy (im1);
      return err;
    }
  /* Flip in place is tricky, be careful not to double-swap things */
  if (sy & 1)
    {
      for (y = 0; (y <= (sy / 2)); y++)
	{
	  int xlimit = sx - 2;
	  if (y == (sy / 2))
	    {
	      /* If there is a "middle" row, be careful
	         not to swap twice! */
	      xlimit -= (sx / 4);
	    }
	  for (x = (sx / 2) + 2; (x < xlimit); x++)
	    {
	      int t;
	      int ox = sx - x + (sx / 2) - 1;
	      int oy = sy - y - 1;
	      t = im1->tpixels[oy][ox];
	      im1->tpixels[oy][ox] = im1->tpixels[y][x];
	      im1->tpixels[y][x] = t;
	    }
	}
    }
  else
    {
      for (y = 0; (y < (sy / 2)); y++)
	{
	  int xlimit = sx - 2;
	  for (x = (sx / 2) + 2; (x < xlimit); x++)
	    {
	      int t;
	      int ox = sx - x + (sx / 2) - 1;
	      int oy = sy - y - 1;
	      t = im1->tpixels[oy][ox];
	      im1->tpixels[oy][ox] = im1->tpixels[y][x];
	      im1->tpixels[y][x] = t;
	    }
	}
    }
#if STEP_PNGS
  {
    FILE *out = fopen ("gdfx1.png", "wb");
    gdImagePng (im1, out);
    fclose (out);
  }
#endif /* STEP_PNGS */
  /* Resample taller; the exact proportions of the text depend on the
     ratio of textRadius to radius, and the value of fillPortion */
  if (sx > sy * 10)
    {
      w = sx;
    }
  else
    {
      w = sy * 10;
    }
  im2 = gdImageCreateTrueColor (w, w);
  if (!im2)
    {
      gdImageDestroy (im1);
      return "could not create resampled image";
    }
  prop = textRadius / radius;
  gdImageCopyResampled (im2, im1,
			gdImageSX (im2) * (1.0 - fillPortion) / 4,
			sy * 10 * (1.0 - prop),
			0, 0,
			gdImageSX (im2) * fillPortion / 2, sy * 10 * prop,
			gdImageSX (im1) / 2, gdImageSY (im1));
  gdImageCopyResampled (im2, im1,
			(gdImageSX (im2) / 2) +
			gdImageSX (im2) * (1.0 - fillPortion) / 4,
			sy * 10 * (1.0 - prop),
			gdImageSX (im1) / 2, 0,
			gdImageSX (im2) * fillPortion / 2, sy * 10 * prop,
			gdImageSX (im1) / 2, gdImageSY (im1));
#if STEP_PNGS
  {
    FILE *out = fopen ("gdfx2.png", "wb");
    gdImagePng (im2, out);
    fclose (out);
  }
#endif /* STEP_PNGS */
  /* Ready to produce a circle */
  im3 = gdImageSquareToCircle (im2, radius);
  gdImageDestroy (im1);
  gdImageDestroy (im2);
  /* Now blend im3 with the destination. Cheat a little. The
     source (im3) is white-on-black, so we can use the
     red component as a basis for alpha as long as we're
     careful to shift off the extra bit and invert
     (alpha ranges from 0 to 127 where 0 is OPAQUE). 
     Also be careful to allow for an alpha component
     in the fgcolor parameter itself (gug!) */
  fr = gdTrueColorGetRed (fgcolor);
  fg = gdTrueColorGetGreen (fgcolor);
  fb = gdTrueColorGetBlue (fgcolor);
  fa = gdTrueColorGetAlpha (fgcolor);
  ox = cx - (im3->sx / 2);
  oy = cy - (im3->sy / 2);
  for (y = 0; (y < im3->sy); y++)
    {
      for (x = 0; (x < im3->sx); x++)
	{
	  int a = gdTrueColorGetRed (im3->tpixels[y][x]) >> 1;
	  a *= (127 - fa);
	  a /= 127;
	  a = 127 - a;
	  gdImageSetPixel (im, x + ox, y + oy,
			   gdTrueColorAlpha (fr, fg, fb, a));
	}
    }
  gdImageDestroy (im3);
  return 0;
}

#if GDFX_MAIN

int
main (int argc, char *argv[])
{
  FILE *in;
  FILE *out;
  gdImagePtr im;
  int radius;
  /* Create an image of text on a circle, with an
     alpha channel so that we can copy it onto a
     background */
  in = fopen ("eleanor.jpg", "rb");
  if (!in)
    {
      im = gdImageCreateTrueColor (300, 300);
    }
  else
    {
      im = gdImageCreateFromJpeg (in);
      fclose (in);
    }
  if (gdImageSX (im) < gdImageSY (im))
    {
      radius = gdImageSX (im) / 2;
    }
  else
    {
      radius = gdImageSY (im) / 2;
    }
  gdStringFTCircle (im,
		    gdImageSX (im) / 2,
		    gdImageSY (im) / 2,
		    radius,
		    radius / 2,
		    0.8,
		    "arial",
		    24,
		    "top text",
		    "bottom text", gdTrueColorAlpha (240, 240, 255, 32));
  out = fopen ("gdfx.png", "wb");
  if (!out)
    {
      fprintf (stderr, "Can't create gdfx.png\n");
      return 1;
    }
  gdImagePng (im, out);
  fclose (out);
  gdImageDestroy (im);
  return 0;
}

#endif /* GDFX_MAIN */

/* Note: don't change these */
#define SUPER 2
#define SUPERBITS1 1
#define SUPERBITS2 2

BGD_DECLARE(gdImagePtr)
gdImageSquareToCircle (gdImagePtr im, int radius)
{
  int x, y;
  double c;
  gdImagePtr im2;
  if (im->sx != im->sy)
    {
      /* Source image must be square */
      return 0;
    }
  im2 = gdImageCreateTrueColor (radius * 2, radius * 2);
  /* Supersampling for a nicer result */
  c = (im2->sx / 2) * SUPER;
  for (y = 0; (y < im2->sy * SUPER); y++)
    {
      for (x = 0; (x < im2->sx * SUPER); x++)
	{
	  double rho = sqrt ((x - c) * (x - c) + (y - c) * (y - c));
	  int pix;
	  int cpix;
	  double theta;
	  double ox;
	  double oy;
	  int red, green, blue, alpha;
	  if (rho > c)
	    {
	      continue;
	    }
	  theta = atan2 (x - c, y - c) + PI / 2;
	  if (theta < 0)
	    {
	      theta += 2 * PI;
	    }
	  /* Undo supersampling */
	  oy = (rho * im->sx) / (im2->sx * SUPER / 2);
	  ox = theta * im->sx / (3.141592653 * 2);
	  pix = gdImageGetPixel (im, ox, oy);
	  cpix = im2->tpixels[y >> SUPERBITS1][x >> SUPERBITS1];
	  red =
	    (gdImageRed (im, pix) >> SUPERBITS2) + gdTrueColorGetRed (cpix);
	  green =
	    (gdImageGreen (im, pix) >> SUPERBITS2) +
	    gdTrueColorGetGreen (cpix);
	  blue =
	    (gdImageBlue (im, pix) >> SUPERBITS2) + gdTrueColorGetBlue (cpix);
	  alpha =
	    (gdImageAlpha (im, pix) >> SUPERBITS2) +
	    gdTrueColorGetAlpha (cpix);
	  im2->tpixels[y >> SUPERBITS1][x >> SUPERBITS1] =
	    gdTrueColorAlpha (red, green, blue, alpha);
	}
    }
  /* Restore full dynamic range, 0-63 yields 0-252. Replication of
     first 2 bits in last 2 bits has the desired effect. Note
     slightly different arithmetic for alpha which is 7-bit. 
     NOTE: only correct for SUPER == 2 */
  for (y = 0; (y < im2->sy); y++)
    {
      for (x = 0; (x < im2->sx); x++)
	{
	  /* Copy first 2 bits to last 2 bits, matching the
	     dynamic range of the original cheaply */
	  int cpix = im2->tpixels[y][x];

	  im2->tpixels[y][x] = gdTrueColorAlpha ((gdTrueColorGetRed (cpix) &
						  0xFC) +
						 ((gdTrueColorGetRed (cpix) &
						   0xC0) >> 6),
						 (gdTrueColorGetGreen (cpix) &
						  0xFC) +
						 ((gdTrueColorGetGreen (cpix)
						   & 0xC0) >> 6),
						 (gdTrueColorGetBlue (cpix) &
						  0xFC) +
						 ((gdTrueColorGetBlue (cpix) &
						   0xC0) >> 6),
						 (gdTrueColorGetAlpha (cpix) &
						  0x7C) +
						 ((gdTrueColorGetAlpha (cpix)
						   & 0x60) >> 6));
	}
    }
  return im2;
}

/* 2.0.16: Called by gdImageSharpen to avoid excessive code repetition
    Added on 2003-11-19 by
    Paul Troughton (paul<dot>troughton<at>ieee<dot>org)
    Given filter coefficents and colours of three adjacent pixels, 
returns new colour for centre pixel
*/

int
gdImageSubSharpen (int pc, int c, int nc, float inner_coeff, float
		   outer_coeff)
{
  float red, green, blue, alpha;

  red = inner_coeff * gdTrueColorGetRed (c) + outer_coeff *
    (gdTrueColorGetRed (pc) + gdTrueColorGetRed (nc));
  green = inner_coeff * gdTrueColorGetGreen (c) + outer_coeff *
    (gdTrueColorGetGreen (pc) + gdTrueColorGetGreen (nc));
  blue = inner_coeff * gdTrueColorGetBlue (c) + outer_coeff *
    (gdTrueColorGetBlue (pc) + gdTrueColorGetBlue (nc));
  alpha = gdTrueColorGetAlpha (c);

  /* Clamping, as can overshoot bounds in either direction */
  if (red > 255.0f)
    {
      red = 255.0f;
    }
  if (green > 255.0f)
    {
      green = 255.0f;
    }
  if (blue > 255.0f)
    {
      blue = 255.0f;
    }
  if (red < 0.0f)
    {
      red = 0.0f;
    }
  if (green < 0.0f)
    {
      green = 0.0f;
    }
  if (blue < 0.0f)
    {
      blue = 0.0f;
    }

  return gdTrueColorAlpha ((int) red, (int) green, (int) blue, (int) alpha);
}

/*
  * Sharpen function added on 2003-11-19
  * by Paul Troughton (paul<dot>troughton<at>ieee<dot>org)
  * Simple 3x3 convolution kernel
  * Makes use of seperability
  * Faster, but less flexible, than full-blown unsharp masking
  * pct is sharpening percentage, and can be greater than 100
  * Silently does nothing to non-truecolor images
  * Silently does nothing for pct<0, as not a useful blurring function
  * Leaves transparency/alpha-channel untouched
  */
BGD_DECLARE(void)
gdImageSharpen (gdImagePtr im, int pct)
{
  int x, y;
  int sx, sy;
  float inner_coeff, outer_coeff;

  sx = im->sx;
  sy = im->sy;

  /* Must sum to 1 to avoid overall change in brightness.
   * Scaling chosen so that pct=100 gives 1-D filter [-1 6 -1]/4,
   * resulting in a 2-D filter [1 -6 1; -6 36 -6; 1 -6 1]/16,
   * which gives noticeable, but not excessive, sharpening
   */

  outer_coeff = -pct / 400.0;
  inner_coeff = 1 - 2 * outer_coeff;

  /* Don't try to do anything with non-truecolor images, as 
     pointless,
     * nor for pct<=0, as small kernel size leads to nasty 
     artefacts when blurring
   */
  if ((im->trueColor) && (pct > 0))
    {

      /* First pass, 1-D convolution column-wise */
      for (x = 0; x < sx; x++)
	{

	  /* pc is colour of previous pixel; c of the 
	     current pixel and nc of the next */
	  int pc, c, nc;

	  /* Replicate edge pixel at image boundary */
	  pc = gdImageGetPixel (im, x, 0);

	  /* Stop looping before last pixel to avoid 
	     conditional within loop */
	  for (y = 0; y < sy - 1; y++)
	    {

	      c = gdImageGetPixel (im, x, y);

	      nc = gdImageGetTrueColorPixel (im, x, y + 1);

	      /* Update centre pixel to new colour */
	      gdImageSetPixel (im, x, y,
			       gdImageSubSharpen (pc, c, nc, inner_coeff,
						  outer_coeff));

	      /* Save original colour of current 
	         pixel for next time round */
	      pc = c;
	    }

	  /* Deal with last pixel, replicating current 
	     pixel at image boundary */
	  c = gdImageGetPixel (im, x, y);
	  gdImageSetPixel (im, x, y, gdImageSubSharpen
			   (pc, c, c, inner_coeff, outer_coeff));
	}

      /* Second pass, 1-D convolution row-wise */
      for (y = 0; y < sy; y++)
	{
	  int pc, c;
	  pc = gdImageGetPixel (im, 0, y);
	  for (x = 0; x < sx - 1; x++)
	    {
	      int c, nc;
	      c = gdImageGetPixel (im, x, y);
	      nc = gdImageGetTrueColorPixel (im, x + 1, y);
	      gdImageSetPixel (im, x, y,
			       gdImageSubSharpen (pc, c, nc, inner_coeff,
						  outer_coeff));
	      pc = c;
	    }
	  c = gdImageGetPixel (im, x, y);
	  gdImageSetPixel (im, x, y, gdImageSubSharpen
			   (pc, c, c, inner_coeff, outer_coeff));
	}
    }
}

1467        804200      789592      1193070200  200         0           100640      11  gdhelpers.c `
#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include "gd.h"
#include "gdhelpers.h"
#include <stdlib.h>
#include <string.h>

/* TBB: gd_strtok_r is not portable; provide an implementation */

#define SEP_TEST (separators[*((unsigned char *) s)])

char *
gd_strtok_r (char *s, char *sep, char **state)
{
  char separators[256];
  char *result = 0;
  memset (separators, 0, sizeof (separators));
  while (*sep)
    {
      separators[*((unsigned char *) sep)] = 1;
      sep++;
    }
  if (!s)
    {
      /* Pick up where we left off */
      s = *state;
    }
  /* 1. EOS */
  if (!(*s))
    {
      *state = s;
      return 0;
    }
  /* 2. Leading separators, if any */
  if (SEP_TEST)
    {
      do
	{
	  s++;
	}
      while (SEP_TEST);
      /* 2a. EOS after separators only */
      if (!(*s))
	{
	  *state = s;
	  return 0;
	}
    }
  /* 3. A token */
  result = s;
  do
    {
      /* 3a. Token at end of string */
      if (!(*s))
	{
	  *state = s;
	  return result;
	}
      s++;
    }
  while (!SEP_TEST);
  /* 4. Terminate token and skip trailing separators */
  *s = '\0';
  do
    {
      s++;
    }
  while (SEP_TEST);
  /* 5. Return token */
  *state = s;
  return result;
}

void *
gdCalloc (size_t nmemb, size_t size)
{
  return calloc (nmemb, size);
}

void *
gdMalloc (size_t size)
{
  return malloc (size);
}

void *
gdRealloc (void *ptr, size_t size)
{
  return realloc (ptr, size);
}

BGD_DECLARE(void) gdFree (void *ptr)
{
  free (ptr);
}
 12934       817234      802630      1193070200  200         0           100640      9   gdkanji.c `
/* gdkanji.c (Kanji code converter)                            */
/*                 written by Masahito Yamaga (ma@yama-ga.com) */

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "gd.h"
#include "gdhelpers.h"

#ifdef HAVE_ERRNO_H
#include <errno.h>
#endif

#include <stdarg.h>
#if defined(HAVE_ICONV_H)
#include <iconv.h>
#endif

#ifndef HAVE_ICONV_T_DEF
typedef void *iconv_t;
#endif

#ifndef HAVE_ICONV
#define ICONV_CONST /**/
  iconv_t iconv_open (const char *, const char *);
size_t iconv (iconv_t, ICONV_CONST char **, size_t *, char **, size_t *);
int iconv_close (iconv_t);

iconv_t
iconv_open (const char *tocode, const char *fromcode)
{
  return (iconv_t) (-1);
}

size_t
iconv (iconv_t cd, ICONV_CONST char **inbuf, size_t * inbytesleft,
       char **outbuf, size_t * outbytesleft)
{
  return 0;
}

int
iconv_close (iconv_t cd)
{
  return 0;
}

#endif /* !HAVE_ICONV */

#define LIBNAME "any2eucjp()"

#if defined(__MSC__) || defined(__BORLANDC__) || defined(__TURBOC__) || defined(_Windows) || defined(MSDOS)
#ifndef SJISPRE
#define SJISPRE 1
#endif
#endif

#ifdef TRUE
#undef TRUE
#endif
#ifdef FALSE
#undef FALSE
#endif

#define TRUE  1
#define FALSE 0

#define NEW 1
#define OLD 2
#define ESCI 3
#define NEC 4
#define EUC 5
#define SJIS 6
#define EUCORSJIS 7
#define ASCII 8

#define NEWJISSTR "JIS7"
#define OLDJISSTR "jis"
#define EUCSTR    "eucJP"
#define SJISSTR   "SJIS"

#define ESC 27
#define SS2 142

static void
debug (const char *format, ...)
{
#ifdef DEBUG
  va_list args;

  va_start (args, format);
  fprintf (stdout, "%s: ", LIBNAME);
  vfprintf (stdout, format, args);
  fprintf (stdout, "\n");
  va_end (args);
#endif
}

static void
error (const char *format, ...)
{
  va_list args;

  va_start (args, format);
  fprintf (stderr, "%s: ", LIBNAME);
  vfprintf (stderr, format, args);
  fprintf (stderr, "\n");
  va_end (args);
}

/* DetectKanjiCode() derived from DetectCodeType() by Ken Lunde. */

static int
DetectKanjiCode (unsigned char *str)
{
  static int whatcode = ASCII;
  int oldcode = ASCII;
  int c, i;
  char *lang = NULL;

  c = '\1';
  i = 0;

  if (whatcode != EUCORSJIS && whatcode != ASCII)
    {
      oldcode = whatcode;
      whatcode = ASCII;
    }

  while ((whatcode == EUCORSJIS || whatcode == ASCII) && c != '\0')
    {
      if ((c = str[i++]) != '\0')
	{
	  if (c == ESC)
	    {
	      c = str[i++];
	      if (c == '$')
		{
		  c = str[i++];
		  if (c == 'B')
		    whatcode = NEW;
		  else if (c == '@')
		    whatcode = OLD;
		}
	      else if (c == '(')
		{
		  c = str[i++];
		  if (c == 'I')
		    whatcode = ESCI;
		}
	      else if (c == 'K')
		whatcode = NEC;
	    }
	  else if ((c >= 129 && c <= 141) || (c >= 143 && c <= 159))
	    whatcode = SJIS;
	  else if (c == SS2)
	    {
	      c = str[i++];
	      if ((c >= 64 && c <= 126) || (c >= 128 && c <= 160)
		  || (c >= 224 && c <= 252))
		whatcode = SJIS;
	      else if (c >= 161 && c <= 223)
		whatcode = EUCORSJIS;
	    }
	  else if (c >= 161 && c <= 223)
	    {
	      c = str[i++];
	      if (c >= 240 && c <= 254)
		whatcode = EUC;
	      else if (c >= 161 && c <= 223)
		whatcode = EUCORSJIS;
	      else if (c >= 224 && c <= 239)
		{
		  whatcode = EUCORSJIS;
		  while (c >= 64 && c != '\0' && whatcode == EUCORSJIS)
		    {
		      if (c >= 129)
			{
			  if (c <= 141 || (c >= 143 && c <= 159))
			    whatcode = SJIS;
			  else if (c >= 253 && c <= 254)
			    whatcode = EUC;
			}
		      c = str[i++];
		    }
		}
	      else if (c <= 159)
		whatcode = SJIS;
	    }
	  else if (c >= 240 && c <= 254)
	    whatcode = EUC;
	  else if (c >= 224 && c <= 239)
	    {
	      c = str[i++];
	      if ((c >= 64 && c <= 126) || (c >= 128 && c <= 160))
		whatcode = SJIS;
	      else if (c >= 253 && c <= 254)
		whatcode = EUC;
	      else if (c >= 161 && c <= 252)
		whatcode = EUCORSJIS;
	    }
	}
    }

#ifdef DEBUG
  if (whatcode == ASCII)
    debug ("Kanji code not included.");
  else if (whatcode == EUCORSJIS)
    debug ("Kanji code not detected.");
  else
    debug ("Kanji code detected at %d byte.", i);
#endif

  if (whatcode == EUCORSJIS && oldcode != ASCII)
    whatcode = oldcode;

  if (whatcode == EUCORSJIS)
    {
      if (getenv ("LC_ALL"))
	lang = getenv ("LC_ALL");
      else if (getenv ("LC_CTYPE"))
	lang = getenv ("LC_CTYPE");
      else if (getenv ("LANG"))
	lang = getenv ("LANG");

      if (lang)
	{
	  if (strcmp (lang, "ja_JP.SJIS") == 0 ||
#ifdef hpux
	      strcmp (lang, "japanese") == 0 ||
#endif
	      strcmp (lang, "ja_JP.mscode") == 0 ||
	      strcmp (lang, "ja_JP.PCK") == 0)
	    whatcode = SJIS;
	  else if (strncmp (lang, "ja", 2) == 0)
#ifdef SJISPRE
	    whatcode = SJIS;
#else
	    whatcode = EUC;
#endif
	}
    }

  if (whatcode == EUCORSJIS)
#ifdef SJISPRE
    whatcode = SJIS;
#else
    whatcode = EUC;
#endif

  return whatcode;
}

/* SJIStoJIS() is sjis2jis() by Ken Lunde. */

static void
SJIStoJIS (int *p1, int *p2)
{
  register unsigned char c1 = *p1;
  register unsigned char c2 = *p2;
  register int adjust = c2 < 159;
  register int rowOffset = c1 < 160 ? 112 : 176;
  register int cellOffset = adjust ? (31 + (c2 > 127)) : 126;

  *p1 = ((c1 - rowOffset) << 1) - adjust;
  *p2 -= cellOffset;
}

/* han2zen() was derived from han2zen() written by Ken Lunde. */

#define IS_DAKU(c) ((c >= 182 && c <= 196) || (c >= 202 && c <= 206) || (c == 179))
#define IS_HANDAKU(c) (c >= 202 && c <= 206)

static void
han2zen (int *p1, int *p2)
{
  int c = *p1;
  int daku = FALSE;
  int handaku = FALSE;
  int mtable[][2] = {
    {129, 66},
    {129, 117},
    {129, 118},
    {129, 65},
    {129, 69},
    {131, 146},
    {131, 64},
    {131, 66},
    {131, 68},
    {131, 70},
    {131, 72},
    {131, 131},
    {131, 133},
    {131, 135},
    {131, 98},
    {129, 91},
    {131, 65},
    {131, 67},
    {131, 69},
    {131, 71},
    {131, 73},
    {131, 74},
    {131, 76},
    {131, 78},
    {131, 80},
    {131, 82},
    {131, 84},
    {131, 86},
    {131, 88},
    {131, 90},
    {131, 92},
    {131, 94},
    {131, 96},
    {131, 99},
    {131, 101},
    {131, 103},
    {131, 105},
    {131, 106},
    {131, 107},
    {131, 108},
    {131, 109},
    {131, 110},
    {131, 113},
    {131, 116},
    {131, 119},
    {131, 122},
    {131, 125},
    {131, 126},
    {131, 128},
    {131, 129},
    {131, 130},
    {131, 132},
    {131, 134},
    {131, 136},
    {131, 137},
    {131, 138},
    {131, 139},
    {131, 140},
    {131, 141},
    {131, 143},
    {131, 147},
    {129, 74},
    {129, 75}
  };

  if (*p2 == 222 && IS_DAKU (*p1))
    daku = TRUE;		/* Daku-ten */
  else if (*p2 == 223 && IS_HANDAKU (*p1))
    handaku = TRUE;		/* Han-daku-ten */

  *p1 = mtable[c - 161][0];
  *p2 = mtable[c - 161][1];

  if (daku)
    {
      if ((*p2 >= 74 && *p2 <= 103) || (*p2 >= 110 && *p2 <= 122))
	(*p2)++;
      else if (*p2 == 131 && *p2 == 69)
	*p2 = 148;
    }
  else if (handaku && *p2 >= 110 && *p2 <= 122)
    (*p2) += 2;
}

/* Recast strcpy to handle unsigned chars used below. */
#define ustrcpy(A,B) (strcpy((char*)(A),(const char*)(B)))

static void
do_convert (unsigned char **to_p, unsigned char **from_p, const char *code)
{
unsigned char *to = *to_p;
unsigned char *from = *from_p;
#ifdef HAVE_ICONV
  iconv_t cd;
  size_t from_len, to_len;

  if ((cd = iconv_open (EUCSTR, code)) == (iconv_t) - 1)
    {
      error ("iconv_open() error");
#ifdef HAVE_ERRNO_H
      if (errno == EINVAL)
	error ("invalid code specification: \"%s\" or \"%s\"", EUCSTR, code);
#endif
      ustrcpy (to, from);
      return;
    }

  from_len = strlen ((const char *)from) + 1;
  to_len = BUFSIZ;

  if ((int) (iconv (cd, (char **)from_p, &from_len, (char **)to_p, &to_len))
      == -1)
    {
#ifdef HAVE_ERRNO_H
      if (errno == EINVAL)
	error ("invalid end of input string");
      else if (errno == EILSEQ)
	error ("invalid code in input string");
      else if (errno == E2BIG)
	error ("output buffer overflow at do_convert()");
      else
#endif
	error ("something happen");
      ustrcpy (to, from);
      return;
    }

  if (iconv_close (cd) != 0)
    {
      error ("iconv_close() error");
    }
#else
  int p1, p2, i, j;
  int jisx0208 = FALSE;
  int hankaku = FALSE;

  j = 0;
  if (strcmp (code, NEWJISSTR) == 0 || strcmp (code, OLDJISSTR) == 0)
    {
      for (i = 0; from[i] != '\0' && j < BUFSIZ; i++)
	{
	  if (from[i] == ESC)
	    {
	      i++;
	      if (from[i] == '$')
		{
		  jisx0208 = TRUE;
		  hankaku = FALSE;
		  i++;
		}
	      else if (from[i] == '(')
		{
		  jisx0208 = FALSE;
		  i++;
		  if (from[i] == 'I')	/* Hankaku Kana */
		    hankaku = TRUE;
		  else
		    hankaku = FALSE;
		}
	    }
	  else
	    {
	      if (jisx0208)
		to[j++] = from[i] + 128;
	      else if (hankaku)
		{
		  to[j++] = SS2;
		  to[j++] = from[i] + 128;
		}
	      else
		to[j++] = from[i];
	    }
	}
    }
  else if (strcmp (code, SJISSTR) == 0)
    {
      for (i = 0; from[i] != '\0' && j < BUFSIZ; i++)
	{
	  p1 = from[i];
	  if (p1 < 127)
	    to[j++] = p1;
	  else if ((p1 >= 161) && (p1 <= 223))
	    {			/* Hankaku Kana */
	      to[j++] = SS2;
	      to[j++] = p1;
	    }
	  else
	    {
	      p2 = from[++i];
	      SJIStoJIS (&p1, &p2);
	      to[j++] = p1 + 128;
	      to[j++] = p2 + 128;
	    }
	}
    }
  else
    {
      error ("invalid code specification: \"%s\"", code);
      return;
    }

  if (j >= BUFSIZ)
    {
      error ("output buffer overflow at do_convert()");
      ustrcpy (to, from);
    }
  else
    to[j] = '\0';
#endif /* HAVE_ICONV */
}

static int
do_check_and_conv (unsigned char *to, unsigned char *from)
{
  static unsigned char tmp[BUFSIZ];
  unsigned char *tmp_p = &tmp[0];
  int p1, p2, i, j;
  int kanji = TRUE;

  switch (DetectKanjiCode (from))
    {
    case NEW:
      debug ("Kanji code is New JIS.");
      do_convert (&tmp_p, &from, NEWJISSTR);
      break;
    case OLD:
      debug ("Kanji code is Old JIS.");
      do_convert (&tmp_p, &from, OLDJISSTR);
      break;
    case ESCI:
      debug
	("This string includes Hankaku-Kana (jisx0201) escape sequence [ESC] + ( + I.");
      do_convert (&tmp_p, &from, NEWJISSTR);
      break;
    case NEC:
      debug ("Kanji code is NEC Kanji.");
      error ("cannot convert NEC Kanji.");
      ustrcpy (tmp, from);
      kanji = FALSE;
      break;
    case EUC:
      debug ("Kanji code is EUC.");
      ustrcpy (tmp, from);
      break;
    case SJIS:
      debug ("Kanji code is SJIS.");
      do_convert (&tmp_p, &from, SJISSTR);
      break;
    case EUCORSJIS:
      debug ("Kanji code is EUC or SJIS.");
      ustrcpy (tmp, from);
      kanji = FALSE;
      break;
    case ASCII:
      debug ("This is ASCII string.");
      ustrcpy (tmp, from);
      kanji = FALSE;
      break;
    default:
      debug ("This string includes unknown code.");
      ustrcpy (tmp, from);
      kanji = FALSE;
      break;
    }

  /* Hankaku Kana ---> Zenkaku Kana */
  if (kanji)
    {
      j = 0;
      for (i = 0; tmp[i] != '\0' && j < BUFSIZ; i++)
	{
	  if (tmp[i] == SS2)
	    {
	      p1 = tmp[++i];
	      if (tmp[i + 1] == SS2)
		{
		  p2 = tmp[i + 2];
		  if (p2 == 222 || p2 == 223)
		    i += 2;
		  else
		    p2 = 0;
		}
	      else
		p2 = 0;
	      han2zen (&p1, &p2);
	      SJIStoJIS (&p1, &p2);
	      to[j++] = p1 + 128;
	      to[j++] = p2 + 128;
	    }
	  else
	    to[j++] = tmp[i];
	}

      if (j >= BUFSIZ)
	{
	  error ("output buffer overflow at Hankaku --> Zenkaku");
	  ustrcpy (to, tmp);
	}
      else
	to[j] = '\0';
    }
  else
    ustrcpy (to, tmp);

  return kanji;
}

int
any2eucjp (unsigned char *dest, unsigned char *src, unsigned int dest_max)
{
  static unsigned char tmp_dest[BUFSIZ];
  int ret;

  if (strlen ((const char *) src) >= BUFSIZ)
    {
      error ("input string too large");
      return -1;
    }
  if (dest_max > BUFSIZ)
    {
      error
	("invalid maximum size of destination\nit should be less than %d.",
	 BUFSIZ);
      return -1;
    }
  ret = do_check_and_conv (tmp_dest, src);
  if (strlen ((const char *) tmp_dest) >= dest_max)
    {
      error ("output buffer overflow");
      ustrcpy (dest, src);
      return -1;
    }
  ustrcpy (dest, tmp_dest);
  return ret;
}

#if 0
unsigned int
strwidth (unsigned char *s)
{
  unsigned char *t;
  unsigned int i;

  t = (unsigned char *) gdMalloc (BUFSIZ);
  any2eucjp (t, s, BUFSIZ);
  i = strlen (t);
  gdFree (t);
  return i;
}

#ifdef DEBUG
int
main ()
{
  unsigned char input[BUFSIZ];
  unsigned char *output;
  unsigned char *str;
  int c, i = 0;

  while ((c = fgetc (stdin)) != '\n' && i < BUFSIZ)
    input[i++] = c;
  input[i] = '\0';

  printf ("input : %d bytes\n", strlen ((const char *) input));
  printf ("output: %d bytes\n", strwidth (input));

  output = (unsigned char *) gdMalloc (BUFSIZ);
  any2eucjp (output, input, BUFSIZ);
  str = output;
  while (*str != '\0')
    putchar (*(str++));
  putchar ('\n');
  gdFree (output);

  return 0;
}
#endif
#endif
1348        818686      804200      1193070200  200         0           100640      13  gdparttopng.c `

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include <stdio.h>
#include <stdlib.h>		/* For atoi */
#include "gd.h"

/* A short program which converts a .png file into a .gd file, for
   your convenience in creating images on the fly from a
   basis image that must be loaded quickly. The .gd format
   is not intended to be a general-purpose format. */

int
main (int argc, char **argv)
{
  gdImagePtr im;
  FILE *in, *out;
  int x, y, w, h;

  if (argc != 7)
    {
      fprintf (stderr,
	       "Usage: gdparttopng filename.gd filename.png x y w h\n");
      exit (1);
    }
  in = fopen (argv[1], "rb");
  if (!in)
    {
      fprintf (stderr, "Input file does not exist!\n");
      exit (1);
    }

  x = atoi (argv[3]);
  y = atoi (argv[4]);
  w = atoi (argv[5]);
  h = atoi (argv[6]);

  printf ("Extracting from (%d, %d), size is %dx%d\n", x, y, w, h);

  im = gdImageCreateFromGd2Part (in, x, y, w, h);
  fclose (in);
  if (!im)
    {
      fprintf (stderr, "Input is not in PNG format!\n");
      exit (1);
    }
  out = fopen (argv[2], "wb");
  if (!out)
    {
      fprintf (stderr, "Output file cannot be written to!\n");
      gdImageDestroy (im);
      exit (1);
    }
#ifdef HAVE_LIBPNG
  gdImagePng (im, out);
#else
  fprintf (stderr, "No PNG library support.\n");
#endif
  fclose (out);
  gdImageDestroy (im);

  return 0;
}
5490        824276      817234      1193070200  200         0           100640      10  gdtables.c`

int gdCosT[] = {
  1024,
  1023,
  1023,
  1022,
  1021,
  1020,
  1018,
  1016,
  1014,
  1011,
  1008,
  1005,
  1001,
  997,
  993,
  989,
  984,
  979,
  973,
  968,
  962,
  955,
  949,
  942,
  935,
  928,
  920,
  912,
  904,
  895,
  886,
  877,
  868,
  858,
  848,
  838,
  828,
  817,
  806,
  795,
  784,
  772,
  760,
  748,
  736,
  724,
  711,
  698,
  685,
  671,
  658,
  644,
  630,
  616,
  601,
  587,
  572,
  557,
  542,
  527,
  512,
  496,
  480,
  464,
  448,
  432,
  416,
  400,
  383,
  366,
  350,
  333,
  316,
  299,
  282,
  265,
  247,
  230,
  212,
  195,
  177,
  160,
  142,
  124,
  107,
  89,
  71,
  53,
  35,
  17,
  0,
  -17,
  -35,
  -53,
  -71,
  -89,
  -107,
  -124,
  -142,
  -160,
  -177,
  -195,
  -212,
  -230,
  -247,
  -265,
  -282,
  -299,
  -316,
  -333,
  -350,
  -366,
  -383,
  -400,
  -416,
  -432,
  -448,
  -464,
  -480,
  -496,
  -512,
  -527,
  -542,
  -557,
  -572,
  -587,
  -601,
  -616,
  -630,
  -644,
  -658,
  -671,
  -685,
  -698,
  -711,
  -724,
  -736,
  -748,
  -760,
  -772,
  -784,
  -795,
  -806,
  -817,
  -828,
  -838,
  -848,
  -858,
  -868,
  -877,
  -886,
  -895,
  -904,
  -912,
  -920,
  -928,
  -935,
  -942,
  -949,
  -955,
  -962,
  -968,
  -973,
  -979,
  -984,
  -989,
  -993,
  -997,
  -1001,
  -1005,
  -1008,
  -1011,
  -1014,
  -1016,
  -1018,
  -1020,
  -1021,
  -1022,
  -1023,
  -1023,
  -1024,
  -1023,
  -1023,
  -1022,
  -1021,
  -1020,
  -1018,
  -1016,
  -1014,
  -1011,
  -1008,
  -1005,
  -1001,
  -997,
  -993,
  -989,
  -984,
  -979,
  -973,
  -968,
  -962,
  -955,
  -949,
  -942,
  -935,
  -928,
  -920,
  -912,
  -904,
  -895,
  -886,
  -877,
  -868,
  -858,
  -848,
  -838,
  -828,
  -817,
  -806,
  -795,
  -784,
  -772,
  -760,
  -748,
  -736,
  -724,
  -711,
  -698,
  -685,
  -671,
  -658,
  -644,
  -630,
  -616,
  -601,
  -587,
  -572,
  -557,
  -542,
  -527,
  -512,
  -496,
  -480,
  -464,
  -448,
  -432,
  -416,
  -400,
  -383,
  -366,
  -350,
  -333,
  -316,
  -299,
  -282,
  -265,
  -247,
  -230,
  -212,
  -195,
  -177,
  -160,
  -142,
  -124,
  -107,
  -89,
  -71,
  -53,
  -35,
  -17,
  0,
  17,
  35,
  53,
  71,
  89,
  107,
  124,
  142,
  160,
  177,
  195,
  212,
  230,
  247,
  265,
  282,
  299,
  316,
  333,
  350,
  366,
  383,
  400,
  416,
  432,
  448,
  464,
  480,
  496,
  512,
  527,
  542,
  557,
  572,
  587,
  601,
  616,
  630,
  644,
  658,
  671,
  685,
  698,
  711,
  724,
  736,
  748,
  760,
  772,
  784,
  795,
  806,
  817,
  828,
  838,
  848,
  858,
  868,
  877,
  886,
  895,
  904,
  912,
  920,
  928,
  935,
  942,
  949,
  955,
  962,
  968,
  973,
  979,
  984,
  989,
  993,
  997,
  1001,
  1005,
  1008,
  1011,
  1014,
  1016,
  1018,
  1020,
  1021,
  1022,
  1023,
  1023
};

int gdSinT[] = {
  0,
  17,
  35,
  53,
  71,
  89,
  107,
  124,
  142,
  160,
  177,
  195,
  212,
  230,
  247,
  265,
  282,
  299,
  316,
  333,
  350,
  366,
  383,
  400,
  416,
  432,
  448,
  464,
  480,
  496,
  512,
  527,
  542,
  557,
  572,
  587,
  601,
  616,
  630,
  644,
  658,
  671,
  685,
  698,
  711,
  724,
  736,
  748,
  760,
  772,
  784,
  795,
  806,
  817,
  828,
  838,
  848,
  858,
  868,
  877,
  886,
  895,
  904,
  912,
  920,
  928,
  935,
  942,
  949,
  955,
  962,
  968,
  973,
  979,
  984,
  989,
  993,
  997,
  1001,
  1005,
  1008,
  1011,
  1014,
  1016,
  1018,
  1020,
  1021,
  1022,
  1023,
  1023,
  1024,
  1023,
  1023,
  1022,
  1021,
  1020,
  1018,
  1016,
  1014,
  1011,
  1008,
  1005,
  1001,
  997,
  993,
  989,
  984,
  979,
  973,
  968,
  962,
  955,
  949,
  942,
  935,
  928,
  920,
  912,
  904,
  895,
  886,
  877,
  868,
  858,
  848,
  838,
  828,
  817,
  806,
  795,
  784,
  772,
  760,
  748,
  736,
  724,
  711,
  698,
  685,
  671,
  658,
  644,
  630,
  616,
  601,
  587,
  572,
  557,
  542,
  527,
  512,
  496,
  480,
  464,
  448,
  432,
  416,
  400,
  383,
  366,
  350,
  333,
  316,
  299,
  282,
  265,
  247,
  230,
  212,
  195,
  177,
  160,
  142,
  124,
  107,
  89,
  71,
  53,
  35,
  17,
  0,
  -17,
  -35,
  -53,
  -71,
  -89,
  -107,
  -124,
  -142,
  -160,
  -177,
  -195,
  -212,
  -230,
  -247,
  -265,
  -282,
  -299,
  -316,
  -333,
  -350,
  -366,
  -383,
  -400,
  -416,
  -432,
  -448,
  -464,
  -480,
  -496,
  -512,
  -527,
  -542,
  -557,
  -572,
  -587,
  -601,
  -616,
  -630,
  -644,
  -658,
  -671,
  -685,
  -698,
  -711,
  -724,
  -736,
  -748,
  -760,
  -772,
  -784,
  -795,
  -806,
  -817,
  -828,
  -838,
  -848,
  -858,
  -868,
  -877,
  -886,
  -895,
  -904,
  -912,
  -920,
  -928,
  -935,
  -942,
  -949,
  -955,
  -962,
  -968,
  -973,
  -979,
  -984,
  -989,
  -993,
  -997,
  -1001,
  -1005,
  -1008,
  -1011,
  -1014,
  -1016,
  -1018,
  -1020,
  -1021,
  -1022,
  -1023,
  -1023,
  -1024,
  -1023,
  -1023,
  -1022,
  -1021,
  -1020,
  -1018,
  -1016,
  -1014,
  -1011,
  -1008,
  -1005,
  -1001,
  -997,
  -993,
  -989,
  -984,
  -979,
  -973,
  -968,
  -962,
  -955,
  -949,
  -942,
  -935,
  -928,
  -920,
  -912,
  -904,
  -895,
  -886,
  -877,
  -868,
  -858,
  -848,
  -838,
  -828,
  -817,
  -806,
  -795,
  -784,
  -772,
  -760,
  -748,
  -736,
  -724,
  -711,
  -698,
  -685,
  -671,
  -658,
  -644,
  -630,
  -616,
  -601,
  -587,
  -572,
  -557,
  -542,
  -527,
  -512,
  -496,
  -480,
  -464,
  -448,
  -432,
  -416,
  -400,
  -383,
  -366,
  -350,
  -333,
  -316,
  -299,
  -282,
  -265,
  -247,
  -230,
  -212,
  -195,
  -177,
  -160,
  -142,
  -124,
  -107,
  -89,
  -71,
  -53,
  -35,
  -17
};
5835        830212      818686      1193070201  200         0           100640      10  gdtestft.c`

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include "gd.h"
#include <string.h>
#include <stdlib.h>

#define PI 3.141592
#define DEG2RAD(x) ((x)*PI/180.)

#define MAX(x,y) ((x) > (y) ? (x) : (y))
#define MIN(x,y) ((x) < (y) ? (x) : (y))

#define MAX4(x,y,z,w) \
	((MAX((x),(y))) > (MAX((z),(w))) ? (MAX((x),(y))) : (MAX((z),(w))))
#define MIN4(x,y,z,w) \
	((MIN((x),(y))) < (MIN((z),(w))) ? (MIN((x),(y))) : (MIN((z),(w))))

#define MAXX(x) MAX4(x[0],x[2],x[4],x[6])
#define MINX(x) MIN4(x[0],x[2],x[4],x[6])
#define MAXY(x) MAX4(x[1],x[3],x[5],x[7])
#define MINY(x) MIN4(x[1],x[3],x[5],x[7])

int
main (int argc, char *argv[])
{
#ifndef HAVE_LIBFREETYPE
  fprintf (stderr, "gd was not compiled with HAVE_LIBFREETYPE defined.\n");
  fprintf (stderr, "Install the FreeType library, including the\n");
  fprintf (stderr, "header files. Then edit the gd Makefile, type\n");
  fprintf (stderr, "make clean, and type make again.\n");
  return 1;
#else
  gdImagePtr im;
  int blue;
  int blueAlpha;
  int white;
  int brect[8];
  int x, y, sx, sy;
  char *err;
  FILE *out;
#ifdef JISX0208
  char *s = "Hello.  Qyjpqg,";	/* String to draw. */
#else
  char *s = "Hello.  Qyjpqg,";	/* String to draw. */
#endif

  double sz = 40.;

#if 0
  double angle = 0.;
#else
  double angle = DEG2RAD (90);
#endif
  char *f;
  if (argc == 2)
    {
      f = argv[1];
    }
  else
    {
      /* 2.02: usage message. Defaulting to Times wasn't working well for the
         many people with no /usr/share/fonts/truetype. */
      fprintf (stderr, "Usage: gdtestft fontfilename\n");
      fprintf (stderr,
	       "If fontfilename is not a full or relative path, GDFONTPATH is searched for\n"
	       "it. If GDFONTPATH is not set, /usr/share/fonts/truetype is searched.\n");
      exit (1);
    }
  /* obtain brect so that we can size the image */
  err =
    gdImageStringFT ((gdImagePtr) NULL, &brect[0], 0, f, sz, angle, 0, 0, s);
  if (err)
    {
      fprintf (stderr, err);
      return 1;
    }

  /* create an image just big enough for the string (x3) */
  sx = MAXX (brect) - MINX (brect) + 6;
  sy = MAXY (brect) - MINY (brect) + 6;
#if 0
  /* Would be palette color 8-bit (which of course is still allowed,
     but not impressive when used with a JPEG background and antialiasing
     and alpha channel and so on!) */
  im = gdImageCreate (sx * 3, sy);
#else
  /* gd 2.0: true color images can use freetype too,
     and they can do antialiasing against arbitrary
     complex backgrounds. */
  im = gdImageCreateTrueColor (sx * 3, sy);
#endif
  /* Background color. gd 2.0: fill the image with it; truecolor
     images have a black background otherwise. */
  white = gdImageColorResolve (im, 255, 255, 255);
  /* Load a pretty background and resample it to cover the entire image */
  {
    FILE *in = fopen ("eleanor.jpg", "rb");
    gdImagePtr imb;
    if (in)
      {
#ifdef HAVE_LIBJPEG
	imb = gdImageCreateFromJpeg (in);
#else
	fprintf (stderr, "No JPEG library support.\n");
#endif
	if (!imb)
	  {
	    fprintf (stderr, "gdImageCreateFromJpeg failed\n");
	    exit (1);
	  }
	if (!im->trueColor)
	  {
	    /* If destination is not truecolor, convert the JPEG to a
	       reasonably high-quality palette version. This is not as good
	       as creating a truecolor output file, of course. Leave many
	       colors for text smoothing. */
#if 1
	    gdImageTrueColorToPalette (imb, 0, 128);
#endif
	  }
	/* Resample background image to cover new image exactly */
	gdImageCopyResampled (im, imb, 0, 0, 0, 0, sx * 3, sy,
			      gdImageSX (imb), gdImageSY (imb));
      }
    else
      {
	/* Can't get background, so paint a simple one */
	/* Truecolor images start out black, so paint it white */
	gdImageFilledRectangle (im, 0, 0, sx * 3, sy, white);
      }
  }
  /* TBB 2.0.2: only black was working, and I didn't know it because
     the test program used black. Funny, huh? Let's do a more interesting
     color this time.  */
  blue = gdImageColorResolve (im, 128, 192, 255);
  /* Almost-transparent blue (alpha blending), with antialiasing */
  blueAlpha = gdImageColorResolveAlpha (im, 128, 192, 255, gdAlphaMax / 2);
  /* render the string, offset origin to center string */
  x = 0 - MINX (brect) + 3;
  y = 0 - MINY (brect) + 3;

  /* With antialiasing (positive color value) */
  err = gdImageStringFT (im, NULL, blue, f, sz, angle, x, y, s);
  if (err)
    {
      fprintf (stderr, err);
      return 1;
    }
  /* Without antialiasing (negative color value) */
  err = gdImageStringFT (im, NULL, -blue, f, sz, angle, sx + x, y, s);
  if (err)
    {
      fprintf (stderr, err);
      return 1;
    }
  /* With antialiasing, and 50% alpha blending (truecolor only) */
  err = gdImageStringFT (im, NULL, blueAlpha, f, sz, angle, sx * 2 + x, y, s);
  if (err)
    {
      fprintf (stderr, err);
      return 1;
    }
  /* TBB: Write img to test/fttest.jpg or test/fttest.png */
  if (im->trueColor)
    {
      out = fopen ("test/fttest.jpg", "wb");
      if (!out)
	{
	  fprintf (stderr, "Can't create test/fttest.jpg\n");
	  exit (1);
	}
      /* Fairly high JPEG quality setting */
#ifdef HAVE_LIBJPEG
      gdImageJpeg (im, out, 90);
#else
      fprintf (stderr, "No JPEG library support.\n");
#endif
      fclose (out);
      fprintf (stderr, "Test image written to test/fttest.jpg\n");
    }
  else
    {
      out = fopen ("test/fttest.png", "wb");
      if (!out)
	{
	  fprintf (stderr, "Can't create test/fttest.png\n");
	  exit (1);
	}
      /* 2.0.10: correct ifdef, thanks to Gabriele Verzeletti */
#ifdef HAVE_LIBPNG
      gdImagePng (im, out);
#else
      fprintf (stderr, "No PNG library support.\n");
#endif
      fclose (out);
      fprintf (stderr, "Test image written to test/fttest.png\n");
    }
  /* Destroy it */
  gdImageDestroy (im);

  return 0;
#endif /* HAVE_LIBFREETYPE */
}
 1117        831430      824276      1193070201  200         0           100640      9   gdtopng.c `

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include <stdio.h>
#include <stdlib.h>
#include "gd.h"

/* A short program which converts a .png file into a .gd file, for
   your convenience in creating images on the fly from a
   basis image that must be loaded quickly. The .gd format
   is not intended to be a general-purpose format. */

int
main (int argc, char **argv)
{
  gdImagePtr im;
  FILE *in, *out;
  if (argc != 3)
    {
      fprintf (stderr, "Usage: gdtopng filename.gd filename.png\n");
      exit (1);
    }
  in = fopen (argv[1], "rb");
  if (!in)
    {
      fprintf (stderr, "Input file does not exist!\n");
      exit (1);
    }
  im = gdImageCreateFromGd (in);
  fclose (in);
  if (!im)
    {
      fprintf (stderr, "Input is not in PNG format!\n");
      exit (1);
    }
  out = fopen (argv[2], "wb");
  if (!out)
    {
      fprintf (stderr, "Output file cannot be written to!\n");
      gdImageDestroy (im);
      exit (1);
    }
#ifdef HAVE_LIBPNG
  gdImagePng (im, out);
#else
  fprintf (stderr, "No PNG library support.\n");
#endif
  fclose (out);
  gdImageDestroy (im);

  return 0;
}
 3512        835040      830212      1193070201  200         0           100640      7   gdxpm.c `

/* 
   add ability to load xpm files to gd, requires the xpm
   library.
   Caolan.McNamara@ul.ie 
   http://www.csn.ul.ie/~caolan
 */

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "gd.h"
#include "gdhelpers.h"

#ifndef HAVE_LIBXPM
BGD_DECLARE(gdImagePtr) gdImageCreateFromXpm (char *filename)
{
  fprintf (stderr, "libgd was not built with xpm support\n");
  return (NULL);
}

#else

#include <X11/xpm.h>

BGD_DECLARE(gdImagePtr) gdImageCreateFromXpm (char *filename)
{
  XpmInfo info;
  XpmImage image;
  int i, j, k, number;
  char buf[5];
  gdImagePtr im = 0;
  int *pointer;
  int red = 0, green = 0, blue = 0;
  int *colors;
  int ret;

  ret = XpmReadFileToXpmImage (filename, &image, &info);
  if (ret != XpmSuccess)
    return 0;

  if (!(im = gdImageCreate (image.width, image.height)))
    return 0;

  number = image.ncolors;
	if (overflow2(sizeof (int), number)) {
		return 0;
	}
  colors = (int *) gdMalloc (sizeof (int) * number);
  if (colors == NULL)
    return (0);
  for (i = 0; i < number; i++)
    {
      switch (strlen (image.colorTable[i].c_color))
	{
	case 4:
	  buf[1] = '\0';
	  buf[0] = image.colorTable[i].c_color[1];
	  red = strtol (buf, NULL, 16);

	  buf[0] = image.colorTable[i].c_color[3];
	  green = strtol (buf, NULL, 16);

	  buf[0] = image.colorTable[i].c_color[5];
	  blue = strtol (buf, NULL, 16);
	  break;
	case 7:
	  buf[2] = '\0';
	  buf[0] = image.colorTable[i].c_color[1];
	  buf[1] = image.colorTable[i].c_color[2];
	  red = strtol (buf, NULL, 16);

	  buf[0] = image.colorTable[i].c_color[3];
	  buf[1] = image.colorTable[i].c_color[4];
	  green = strtol (buf, NULL, 16);

	  buf[0] = image.colorTable[i].c_color[5];
	  buf[1] = image.colorTable[i].c_color[6];
	  blue = strtol (buf, NULL, 16);
	  break;
	case 10:
	  buf[3] = '\0';
	  buf[0] = image.colorTable[i].c_color[1];
	  buf[1] = image.colorTable[i].c_color[2];
	  buf[2] = image.colorTable[i].c_color[3];
	  red = strtol (buf, NULL, 16);
	  red /= 64;

	  buf[0] = image.colorTable[i].c_color[4];
	  buf[1] = image.colorTable[i].c_color[5];
	  buf[2] = image.colorTable[i].c_color[6];
	  green = strtol (buf, NULL, 16);
	  green /= 64;

	  buf[0] = image.colorTable[i].c_color[7];
	  buf[1] = image.colorTable[i].c_color[8];
	  buf[2] = image.colorTable[i].c_color[9];
	  blue = strtol (buf, NULL, 16);
	  blue /= 64;
	  break;
	case 13:
	  buf[4] = '\0';
	  buf[0] = image.colorTable[i].c_color[1];
	  buf[1] = image.colorTable[i].c_color[2];
	  buf[2] = image.colorTable[i].c_color[3];
	  buf[3] = image.colorTable[i].c_color[4];
	  red = strtol (buf, NULL, 16);
	  red /= 256;

	  buf[0] = image.colorTable[i].c_color[5];
	  buf[1] = image.colorTable[i].c_color[6];
	  buf[2] = image.colorTable[i].c_color[7];
	  buf[3] = image.colorTable[i].c_color[8];
	  green = strtol (buf, NULL, 16);
	  green /= 256;

	  buf[0] = image.colorTable[i].c_color[9];
	  buf[1] = image.colorTable[i].c_color[10];
	  buf[2] = image.colorTable[i].c_color[11];
	  buf[3] = image.colorTable[i].c_color[12];
	  blue = strtol (buf, NULL, 16);
	  blue /= 256;
	  break;
	}


      colors[i] = gdImageColorResolve (im, red, green, blue);
      if (colors[i] == -1)
	fprintf (stderr, "ARRRGH\n");
    }

  pointer = (int *) image.data;
  for (i = 0; i < image.height; i++)
    {
      for (j = 0; j < image.width; j++)
	{
	  k = *pointer++;
	  gdImageSetPixel (im, j, i, colors[k]);
	}
    }
  gdFree (colors);
  return (im);
}
#endif /* HAVE_LIBXPM */
758         835902      831430      1193070201  200         0           100640      13  gifanimtest.c `
#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include "gd.h"

int main (int argc, char *argv[])
{
	gdImagePtr im;
	gdImagePtr last, cim;
	int black;
	int blue;
	FILE *out;
	int i;
	im = gdImageCreate(100, 100);
	black = gdImageColorAllocate(im, 0, 0, 0);
	blue = gdImageColorAllocate(im, 0, 0, 255);
	out = fopen("gifanim.gif", "wb");
	gdImageGifAnimBegin(im, out, 1, 10);
	last = 0;
	for (i = 0; (i <= 100); i += 2) {
		cim = gdImageCreate(100, 100);
		gdImagePaletteCopy(cim, im);
		gdImageArc(cim, 50, 50, i, i, 0, 360, blue);
		gdImageGifAnimAdd(cim, out, 0, 0, 0, 10, gdDisposalNone, last);
		if (last) {
			gdImageDestroy(last);
		}
		last = cim;
	}	
	gdImageDestroy(last);
	gdImageGifAnimEnd(out);
	fclose(out);
	gdImageDestroy(im);
	return 0;
}

1103        837106      835040      1193070201  200         0           100640      10  giftogd2.c`
#include <stdio.h>
#include <stdlib.h>

#include "gd.h"

/* A short program which converts a .gif file into a .gd file, for
	your convenience in creating images on the fly from a
	basis image that must be loaded quickly. The .gd format
	is not intended to be a general-purpose format. */

int main(int argc, char **argv)
{
	gdImagePtr im;
	FILE *in, *out;
	int	cs, fmt;

	if (argc != 5) {
		fprintf(stderr, "Usage: giftogd2 filename.gif filename.gd2 cs fmt\n");
                fprintf(stderr, "    where cs is the chunk size\n");
		fprintf(stderr, "          fmt is 1 for raw, 2 for compressed\n");
		exit(1);
	}
	in = fopen(argv[1], "rb");
	if (!in) {
		fprintf(stderr, "Input file does not exist!\n");
		exit(1);
	}
	im = gdImageCreateFromGif(in);
	fclose(in);
	if (!im) {
		fprintf(stderr, "Input is not in GIF format!\n");
		exit(1);
	}
	out = fopen(argv[2], "wb");
	if (!out) {
		fprintf(stderr, "Output file cannot be written to!\n");
		gdImageDestroy(im);
		exit(1);	
	}
	cs = atoi(argv[3]);
	fmt = atoi(argv[4]);
	gdImageGd2(im, out, cs, fmt);
	fclose(out);
	gdImageDestroy(im);

	return 0;
}

 1127        838334      835902      1193070202  200         0           100640      9   pngtogd.c `

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include <stdio.h>
#include <stdlib.h>
#include "gd.h"

/* A short program which converts a .png file into a .gd file, for
   your convenience in creating images on the fly from a
   basis image that must be loaded quickly. The .gd format
   is not intended to be a general-purpose format. */

int
main (int argc, char **argv)
{
  gdImagePtr im;
  FILE *in, *out;
  if (argc != 3)
    {
      fprintf (stderr, "Usage: pngtogd filename.png filename.gd\n");
      exit (1);
    }
  in = fopen (argv[1], "rb");
  if (!in)
    {
      fprintf (stderr, "Input file does not exist!\n");
      exit (1);
    }
#ifdef HAVE_LIBPNG
  im = gdImageCreateFromPng (in);
#else
  fprintf (stderr, "No PNG library support available.\n");
#endif
  fclose (in);
  if (!im)
    {
      fprintf (stderr, "Input is not in PNG format!\n");
      exit (1);
    }
  out = fopen (argv[2], "wb");
  if (!out)
    {
      fprintf (stderr, "Output file cannot be written to!\n");
      gdImageDestroy (im);
      exit (1);
    }
  gdImageGd (im, out);
  fclose (out);
  gdImageDestroy (im);

  return 0;
}
 1345        839780      837106      1193070202  200         0           100640      10  pngtogd2.c`

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include <stdio.h>
#include <stdlib.h>
#include "gd.h"

/* A short program which converts a .png file into a .gd2 file, for
   your convenience in creating images on the fly from a
   basis image that must be loaded quickly. The .gd2 format
   is not intended to be a general-purpose format. */

int
main (int argc, char **argv)
{
  gdImagePtr im;
  FILE *in, *out;
  int cs, fmt;

  if (argc != 5)
    {
      fprintf (stderr, "Usage: pngtogd2 filename.png filename.gd2 cs fmt\n");
      fprintf (stderr, "    where cs is the chunk size\n");
      fprintf (stderr, "          fmt is 1 for raw, 2 for compressed\n");
      exit (1);
    }
  in = fopen (argv[1], "rb");
  if (!in)
    {
      fprintf (stderr, "Input file does not exist!\n");
      exit (1);
    }
#ifdef HAVE_LIBPNG
  im = gdImageCreateFromPng (in);
#else
  fprintf (stderr, "No PNG library support available.\n");
#endif
  fclose (in);
  if (!im)
    {
      fprintf (stderr, "Input is not in PNG format!\n");
      exit (1);
    }
  out = fopen (argv[2], "wb");
  if (!out)
    {
      fprintf (stderr, "Output file cannot be written to!\n");
      gdImageDestroy (im);
      exit (1);
    }
  cs = atoi (argv[3]);
  fmt = atoi (argv[4]);
  gdImageGd2 (im, out, cs, fmt);
  fclose (out);
  gdImageDestroy (im);

  return 0;
}
 2689        842570      838334      1193070202  200         0           100644      9   strlcpy.c `
/* $Id: strlcpy.c,v 1.1.2.1 2007/02/26 23:39:43 pajoye Exp $ */
#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

/*	$OpenBSD: strlcpy.c,v 1.4 1999/05/01 18:56:41 millert Exp $	*/

/*
 * Copyright (c) 1998 Todd C. Miller <Todd.Miller@courtesan.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL
 * THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#if defined(LIBC_SCCS) && !defined(lint)
static char *rcsid = "$OpenBSD: strlcpy.c,v 1.4 1999/05/01 18:56:41 millert Exp $";
#endif /* LIBC_SCCS and not lint */

#include <sys/types.h>
#include <string.h>

/*
 * Copy src to string dst of size siz.  At most siz-1 characters
 * will be copied.  Always NUL terminates (unless siz == 0).
 * Returns strlen(src); if retval >= siz, truncation occurred.
 */
size_t gd_strlcpy(char *dst, const char *src, size_t siz)
{
	register char *d = dst;
	register const char *s = src;
	register size_t n = siz;

	/* Copy as many bytes as will fit */
	if (n != 0 && --n != 0) {
		do {
			if ((*d++ = *s++) == 0)
				break;
		} while (--n != 0);
	}

	/* Not enough room in dst, add NUL and traverse rest of src */
	if (n == 0) {
		if (siz != 0)
			*d = '\0';		/* NUL-terminate dst */
		while (*s++)
			;
	}

	return(s - src - 1);	/* count does not include NUL */
}

/*
 * Local variables:
 * tab-width: 4
 * c-basic-offset: 4
 * End:
 * vim600: sw=4 ts=4 fdm=marker
 * vim<600: sw=4 ts=4
 */
 6978        849644      839780      1193070204  200         0           100640      6   wbmp.c`

/* WBMP
   ** ----
   ** WBMP Level 0: B/W, Uncompressed
   ** This implements the WBMP format as specified in WAPSpec 1.1 and 1.2.
   ** It does not support ExtHeaders as defined in the spec. The spec states
   ** that a WAP client does not need to implement ExtHeaders.
   **
   ** (c) 2000 Johan Van den Brande <johan@vandenbrande.com>
 */

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include <stdio.h>
#include <stddef.h>
#include <stdlib.h>
#include <string.h>

#include "wbmp.h"
#include "gd.h"
#include "gdhelpers.h"

#ifdef NOTDEF
#define __TEST			/* Compile with main function */
#define __DEBUG			/* Extra verbose when with __TEST */
#define __WRITE			/* readwbmp and writewbmp(stdout) */
#define __VIEW			/* view the wbmp on stdout */
#endif

/* getmbi
   ** ------
   ** Get a multibyte integer from a generic getin function 
   ** 'getin' can be getc, with in = NULL
   ** you can find getin as a function just above the main function
   ** This way you gain a lot of flexibilty about how this package
   ** reads a wbmp file.
 */
int
getmbi (int (*getin) (void *in), void *in)
{
  int i, mbi = 0;

  do
    {
      i = getin (in);
      if (i < 0)
	return (-1);
      mbi = (mbi << 7) | (i & 0x7f);
    }
  while (i & 0x80);

  return (mbi);
}


/* putmbi
   ** ------
   ** Put a multibyte intgerer in some kind of output stream
   ** I work here with a function pointer, to make it as generic
   ** as possible. Look at this function as an iterator on the
   ** mbi integers it spits out.
   **
 */
void
putmbi (int i, void (*putout) (int c, void *out), void *out)
{
  int cnt, l, accu;

  /* Get number of septets */
  cnt = 0;
  accu = 0;
  while (accu != i)
    accu += i & 0x7f << 7 * cnt++;

  /* Produce the multibyte output */
  for (l = cnt - 1; l > 0; l--)
    putout (0x80 | (i & 0x7f << 7 * l) >> 7 * l, out);

  putout (i & 0x7f, out);

}



/* skipheader
   ** ----------
   ** Skips the ExtHeader. Not needed for the moment
   **
 */
int
skipheader (int (*getin) (void *in), void *in)
{
  int i;

  do
    {
      i = getin (in);
      if (i < 0)
	return (-1);
    }
  while (i & 0x80);

  return (0);
}

/* create wbmp
   ** -----------
   ** create an empty wbmp
   **
 */
Wbmp *
createwbmp (int width, int height, int color)
{
  int i;

  Wbmp *wbmp;
  if ((wbmp = (Wbmp *) gdMalloc (sizeof (Wbmp))) == NULL)
    return (NULL);

  if (overflow2(sizeof (int), width)) {
    gdFree(wbmp);
    return NULL;
  }
  if (overflow2(sizeof (int) * width, height)) {
    gdFree(wbmp);
    return NULL;
  }
  if ((wbmp->bitmap =
       (int *) gdMalloc (sizeof (int) * width * height)) == NULL)
    {
      gdFree (wbmp);
      return (NULL);
    }

  wbmp->width = width;
  wbmp->height = height;

  for (i = 0; i < width * height; wbmp->bitmap[i++] = color);

  return (wbmp);
}



/* readwbmp
   ** -------
   ** Actually reads the WBMP format from an open file descriptor
   ** It goes along by returning a pointer to a WBMP struct.
   **
 */
int
readwbmp (int (*getin) (void *in), void *in, Wbmp ** return_wbmp)
{
  int row, col, byte, pel, pos;
  Wbmp *wbmp;

  if ((wbmp = (Wbmp *) gdMalloc (sizeof (Wbmp))) == NULL)
    return (-1);

  wbmp->type = getin (in);
  if (wbmp->type != 0)
    {
      gdFree (wbmp);
      return (-1);
    }

  if (skipheader (getin, in))
    return (-1);


  wbmp->width = getmbi (getin, in);
  if (wbmp->width == -1)
    {
      gdFree (wbmp);
      return (-1);
    }

  wbmp->height = getmbi (getin, in);
  if (wbmp->height == -1)
    {
      gdFree (wbmp);
      return (-1);
    }

#ifdef __DEBUG
  printf ("W: %d, H: %d\n", wbmp->width, wbmp->height);
#endif

  if (overflow2(sizeof (int), wbmp->width) ||
    overflow2(sizeof (int) * wbmp->width, wbmp->height))
    {
      gdFree(wbmp);
      return (-1);
    }
  if ((wbmp->bitmap =
       (int *) gdMalloc (sizeof (int) * wbmp->width * wbmp->height)) == NULL)
    {
      gdFree (wbmp);
      return (-1);
    }

#ifdef __DEBUG
  printf ("DATA CONSTRUCTED\n");
#endif

  pos = 0;
  for (row = 0; row < wbmp->height; row++)
    {
      for (col = 0; col < wbmp->width;)
	{
	  byte = getin (in);

	  for (pel = 7; pel >= 0; pel--)
	    {
	      if (col++ < wbmp->width)
		{
		  if (byte & 1 << pel)
		    {
		      wbmp->bitmap[pos] = WBMP_WHITE;
		    }
		  else
		    {
		      wbmp->bitmap[pos] = WBMP_BLACK;
		    }
		  pos++;
		}
	    }
	}
    }

  *return_wbmp = wbmp;

  return (0);
}


/* writewbmp
   ** ---------
   ** Write a wbmp to a file descriptor
   **
   ** Why not just giving a filedescriptor to this function?
   ** Well, the incentive to write this function was the complete
   ** integration in gd library from www.libgd.org. They use
   ** their own io functions, so the passing of a function seemed to be 
   ** a logic(?) decision ...
   **
 */
int
writewbmp (Wbmp * wbmp, void (*putout) (int c, void *out), void *out)
{
  int row, col;
  int bitpos, octet;

  /* Generate the header */
  putout (0, out);		/* WBMP Type 0: B/W, Uncompressed bitmap */
  putout (0, out);		/* FixHeaderField */



  /* Size of the image */
  putmbi (wbmp->width, putout, out);	/* width */
  putmbi (wbmp->height, putout, out);	/* height */


  /* Image data */
  for (row = 0; row < wbmp->height; row++)
    {
      bitpos = 8;
      octet = 0;
      for (col = 0; col < wbmp->width; col++)
	{
	  octet |=
	    ((wbmp->bitmap[row * wbmp->width + col] ==
	      1) ? WBMP_WHITE : WBMP_BLACK) << --bitpos;
	  if (bitpos == 0)
	    {
	      bitpos = 8;
	      putout (octet, out);
	      octet = 0;
	    }
	}
      if (bitpos != 8)
	putout (octet, out);

    }
  return (0);

}


/* freewbmp
   ** --------
   ** gdFrees up memory occupied by a WBMP structure
   **
 */
void
freewbmp (Wbmp * wbmp)
{
  gdFree (wbmp->bitmap);
  gdFree (wbmp);
}


/* printwbmp
   ** ---------
   ** print a WBMP to stdout for visualisation
   **
 */
void
printwbmp (Wbmp * wbmp)
{
  int row, col;
  for (row = 0; row < wbmp->height; row++)
    {
      for (col = 0; col < wbmp->width; col++)
	{
	  if (wbmp->bitmap[wbmp->width * row + col] == WBMP_BLACK)
	    {
	      putchar ('#');
	    }
	  else
	    {
	      putchar (' ');
	    }
	}
      putchar ('\n');
    }
}

#ifdef __TEST

/* putout to file descriptor
   ** -------------------------
 */
int
putout (int c, void *out)
{
  return (putc (c, (FILE *) out));
}

/* getin from file descriptor 
   ** --------------------------
 */
int
getin (void *in)
{
  return (getc ((FILE *) in));
}


/* Main function
   ** -------------
   **
 */
int
main (int argc, char *argv[])
{
  FILE *wbmp_file;
  Wbmp *wbmp;

  wbmp_file = fopen (argv[1], "rb");
  if (wbmp_file)
    {
      readwbmp (&getin, wbmp_file, &wbmp);

#ifdef __VIEW

#ifdef __DEBUG
      printf ("\nVIEWING IMAGE\n");
#endif

      printwbmp (wbmp);
#endif

#ifdef __WRITE

#ifdef __DEBUG
      printf ("\nDUMPING WBMP to STDOUT\n");
#endif

      writewbmp (wbmp, &putout, stdout);
#endif

      freewbmp (wbmp);
      fclose (wbmp_file);
    }
}
#endif
6702        856444      842570      1193070204  200         0           100640      8   webpng.c`
#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

/* Bring in the gd library functions */
#include "gd.h"

/* Bring in standard I/O and string manipulation functions */
#include <stdio.h>
#include <stdlib.h>		/* for atoi() */
#include <string.h>

#ifdef _WIN32
#include <process.h>
int
getpid ()
{
  return _getpid ();
}
#else
#include <unistd.h>		/* for getpid(), unlink() */
#endif
int
main (int argc, char **argv)
{
  FILE *in;
  FILE *out;
  char outFn[20];
  int useStdinStdout = 0;

  /* Declare our image pointer */
  gdImagePtr im = 0;
  int i;
  /* We'll clear 'no' once we know the user has made a
     reasonable request. */
  int no = 1;
  /* We'll set 'write' once we know the user's request
     requires that the image be written back to disk. */
  int write = 0;
  /* C programs always get at least one argument; we want at
     least one more (the image), more in practice. */
  if (argc < 2 || !strcmp (argv[1], "--help"))
    {
      no = 1;
      goto usage;
    }

  /* The last argument should be the image. Open the file. */
  if (strcmp ("-", argv[argc - 1]) == 0)
    {				/* - is synonymous with STDIN */
      useStdinStdout = 1;
      in = stdin;
    }
  else
    {
      in = fopen (argv[argc - 1], "rb");
    }
  if (!in)
    {
      fprintf (stderr, "Error: can't open file %s.\n", argv[argc - 1]);
      exit (1);
    }
  /* Now load the image. */
#ifdef HAVE_LIBPNG
  im = gdImageCreateFromPng (in);
#else
  fprintf (stderr, "No PNG library support.\n");
#endif
  fclose (in);
  /* If the load failed, it must not be a PNG file. */
  if (!im)
    {
      fprintf (stderr,
	       "Error: %s is not a valid PNG file.\n", argv[argc - 1]);
      exit (1);
    }
  /* Consider each argument in turn. */
  for (i = 1; (i < (argc - 1)); i++)
    {
      /* -i turns on and off interlacing. */
      if (!strcmp (argv[i], "--help"))
	{
	  /* Every program should use this for help! :) */
	  no = 1;
	  goto usage;
	}
      else if (!strcmp (argv[i], "-i"))
	{
	  if (i == (argc - 2))
	    {
	      fprintf (stderr, "Error: -i specified without y or n.\n");
	      no = 1;
	      goto usage;
	    }
	  if (!strcmp (argv[i + 1], "y"))
	    {
	      /* Set interlace. */
	      gdImageInterlace (im, 1);
	    }
	  else if (!strcmp (argv[i + 1], "n"))
	    {
	      /* Clear interlace. */
	      gdImageInterlace (im, 0);
	    }
	  else
	    {
	      fprintf (stderr, "Error: -i specified without y or n.\n");
	      no = 1;
	      goto usage;
	    }
	  i++;
	  no = 0;
	  write = 1;
	}
      else if (!strcmp (argv[i], "-t"))
	{
	  /* Set transparent index (or none). */
	  int index;
	  if (i == (argc - 2))
	    {
	      fprintf (stderr,
		       "Error: -t specified without a color table index.\n");
	      no = 1;
	      goto usage;
	    }
	  if (!strcmp (argv[i + 1], "none"))
	    {
	      /* -1 means not transparent. */
	      gdImageColorTransparent (im, -1);
	    }
	  else
	    {
	      /* OK, get an integer and set the index. */
	      index = atoi (argv[i + 1]);
	      gdImageColorTransparent (im, index);
	    }
	  i++;
	  write = 1;
	  no = 0;
	}
      else if (!strcmp (argv[i], "-l"))
	{
	  /* List the colors in the color table. */
	  int j;
	  if (!im->trueColor)
	    {
	      /* Tabs used below. */
	      printf ("Index	Red	Green	Blue Alpha\n");
	      for (j = 0; (j < gdImageColorsTotal (im)); j++)
		{
		  /* Use access macros to learn colors. */
		  printf ("%d	%d	%d	%d	%d\n",
			  j,
			  gdImageRed (im, j),
			  gdImageGreen (im, j),
			  gdImageBlue (im, j), gdImageAlpha (im, j));
		}
	    }
	  else
	    {
	      printf ("Truecolor image, no palette entries to list.\n");
	    }
	  no = 0;
	}
      else if (!strcmp (argv[i], "-d"))
	{
	  /* Output dimensions, etc. */
	  int t;
	  printf ("Width: %d Height: %d Colors: %d\n",
		  gdImageSX (im), gdImageSY (im), gdImageColorsTotal (im));
	  t = gdImageGetTransparent (im);
	  if (t != (-1))
	    {
	      printf ("First 100%% transparent index: %d\n", t);
	    }
	  else
	    {
	      /* -1 means the image is not transparent. */
	      printf ("First 100%% transparent index: none\n");
	    }
	  if (gdImageGetInterlaced (im))
	    {
	      printf ("Interlaced: yes\n");
	    }
	  else
	    {
	      printf ("Interlaced: no\n");
	    }
	  no = 0;
	}
      else if (!strcmp (argv[i], "-a"))
	{
	  /* Alpha channel info -- thanks to Wez Furlong */
	  int maxx, maxy, x, y, alpha, pix, nalpha = 0;

	  maxx = gdImageSX (im);
	  maxy = gdImageSY (im);

	  printf ("alpha channel information:\n");

	  if (im->trueColor)
	    {
	      for (y = 0; y < maxy; y++)
		{
		  for (x = 0; x < maxx; x++)
		    {
		      pix = gdImageGetPixel (im, x, y);
		      alpha = gdTrueColorGetAlpha (pix);

		      if (alpha > gdAlphaOpaque)
			{
			  /* Use access macros to learn colors. */
			  printf ("%d	%d	%d	%d\n",
				  gdTrueColorGetRed (pix),
				  gdTrueColorGetGreen (pix),
				  gdTrueColorGetBlue (pix), alpha);
			  nalpha++;
			}

		    }
		}
	    }
	  else
	    printf ("NOT a true color image\n");
	  no = 0;
	  printf ("%d alpha channels\n", nalpha);

	}
      else
	{
	  fprintf (stderr, "Unknown argument: %s\n", argv[i]);
	  break;
	}
    }
usage:
  if (no)
    {
      /* If the command failed, output an explanation. */
      fprintf (stderr,
	       "Usage: webpng [-i y|n ] [-l] [-t index|none ] [-d] pngname.png\n"
	       "  -i [y|n]   Turns on/off interlace\n"
	       "  -l         Prints the table of color indexes\n"
	       "  -t [index] Set the transparent color to the specified index (0-255 or \"none\")\n"
	       "  -d         Reports the dimensions and other characteristics of the image.\n"
	       "  -a         Prints all alpha channels that are not 100%% opaque.\n"
	       "\n"
	       "If you specify '-' as the input file, stdin/stdout will be used input/output.\n");
    }
  if (write)
    {
      if (useStdinStdout)
	{
	  out = stdout;
	}
      else
	{
	  /* Open a temporary file. */

	  /* "temp.tmp" is not good temporary filename. */
	  sprintf (outFn, "webpng.tmp%d", getpid ());
	  out = fopen (outFn, "wb");

	  if (!out)
	    {
	      fprintf (stderr, "Unable to write to %s -- exiting\n", outFn);
	      exit (1);
	    }
	}

      /* Write the new PNG. */
#ifdef HAVE_LIBPNG
      gdImagePng (im, out);
#else
      fprintf (stderr, "No PNG library support.\n");
#endif
      if (!useStdinStdout)
	{
	  fclose (out);
	  /* Erase the old PNG. */
	  unlink (argv[argc - 1]);
	  /* Rename the new to the old. */
	  if (rename (outFn, argv[argc - 1]) != 0)
	    {
	      perror ("rename");
	      exit (1);
	    }
	}
    }
  /* Delete the image from memory. */
  if (im)
    {
      gdImageDestroy (im);
    }
  /* All's well that ends well. */
  return 0;
}
991         0           849644      0           0           0           0           0   `
44          68          4826        83546       85054       86438       87478       89124       95030       118088      136468      168144      171156      179912      182534      185542      214764      240044      240840      242016      306904      312592      318074      320078      325918      442002      553220      634476      705718      745244      789592      802630      804200      817234      818686      824276      830212      831430      835040      835902      837106      838334      839780      842570      849644      annotate.c gd.c gd2copypal.c gd2time.c gd2togif.c gd2topng.c gd_gd.c gd_gd2.c gd_gif_in.c gd_gif_out.c gd_io.c gd_io_dp.c gd_io_file.c gd_io_ss.c gd_jpeg.c gd_png.c gd_security.c gd_ss.c gd_topal.c gd_wbmp.c gdcache.c gdcmpgif.c gddemo.c gdfontg.c gdfontl.c gdfontmb.c gdfonts.c gdfontt.c gdft.c gdfx.c gdhelpers.c gdkanji.c gdparttopng.c gdtables.c gdtestft.c gdtopng.c gdxpm.c gifanimtest.c giftogd2.c pngtogd.c pngtogd2.c strlcpy.c wbmp.c webpng.c  